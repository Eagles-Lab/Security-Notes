# PHP调用MySQL

## 一、课程目标
通过本课程的学习，学生将掌握：
- PHP连接MySQL数据库的多种方式
- 数据库和数据表的创建与管理
- 安全的数据插入、查询、更新和删除操作
- 预处理语句的使用和SQL注入防护
- 数据库连接池和事务处理
- 在Web安全开发中的数据库最佳实践

## 二、PHP连接MySQL基础

### 2.1 连接方式对比
PHP提供了三种连接MySQL的方式：

1. **MySQL扩展（已弃用）**
2. **MySQLi扩展（推荐）**
3. **PDO扩展（推荐）**

### 2.2 MySQLi连接方式
```php
<?php
// MySQLi面向对象方式
$servername = "localhost";
$username = "root";
$password = "password";
$dbname = "security_db";

// 创建连接
$mysqli = new mysqli($servername, $username, $password, $dbname);

// 检查连接
if ($mysqli->connect_error) {
    die("连接失败: " . $mysqli->connect_error);
}

echo "连接成功\n";

// 设置字符集
$mysqli->set_charset("utf8mb4");

// MySQLi面向过程方式
$connection = mysqli_connect($servername, $username, $password, $dbname);

if (!$connection) {
    die("连接失败: " . mysqli_connect_error());
}

echo "面向过程方式连接成功\n";
mysqli_set_charset($connection, "utf8mb4");
?>
```

### 2.3 PDO连接方式
```php
<?php
$servername = "localhost";
$username = "root";
$password = "password";
$dbname = "security_db";

try {
    // 创建PDO连接
    $dsn = "mysql:host=$servername;dbname=$dbname;charset=utf8mb4";
    $options = [
        PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,
        PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC,
        PDO::ATTR_EMULATE_PREPARES => false,
        PDO::ATTR_PERSISTENT => false
    ];
    
    $pdo = new PDO($dsn, $username, $password, $options);
    echo "PDO连接成功\n";
    
} catch(PDOException $e) {
    die("连接失败: " . $e->getMessage());
}
?>
```

### 2.4 安全的数据库连接类
```php
<?php
class DatabaseConnection {
    private $host;
    private $username;
    private $password;
    private $database;
    private $connection;
    private $connectionType;
    
    public function __construct($config, $type = 'pdo') {
        $this->host = $config['host'];
        $this->username = $config['username'];
        $this->password = $config['password'];
        $this->database = $config['database'];
        $this->connectionType = $type;
    }
    
    public function connect() {
        try {
            switch ($this->connectionType) {
                case 'mysqli':
                    $this->connection = new mysqli(
                        $this->host, 
                        $this->username, 
                        $this->password, 
                        $this->database
                    );
                    
                    if ($this->connection->connect_error) {
                        throw new Exception("MySQLi连接失败: " . $this->connection->connect_error);
                    }
                    
                    $this->connection->set_charset("utf8mb4");
                    break;
                    
                case 'pdo':
                default:
                    $dsn = "mysql:host={$this->host};dbname={$this->database};charset=utf8mb4";
                    $options = [
                        PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,
                        PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC,
                        PDO::ATTR_EMULATE_PREPARES => false,
                        PDO::ATTR_PERSISTENT => false,
                        PDO::MYSQL_ATTR_INIT_COMMAND => "SET NAMES utf8mb4"
                    ];
                    
                    $this->connection = new PDO($dsn, $this->username, $this->password, $options);
                    break;
            }
            
            return $this->connection;
            
        } catch (Exception $e) {
            $this->logError("数据库连接错误", $e->getMessage());
            throw $e;
        }
    }
    
    public function getConnection() {
        if (!$this->connection) {
            $this->connect();
        }
        return $this->connection;
    }
    
    public function close() {
        if ($this->connectionType === 'mysqli' && $this->connection) {
            $this->connection->close();
        }
        $this->connection = null;
    }
    
    private function logError($context, $message) {
        $logEntry = date('Y-m-d H:i:s') . " [$context] $message" . PHP_EOL;
        file_put_contents('database_errors.log', $logEntry, FILE_APPEND);
    }
}

// 使用示例
$config = [
    'host' => 'localhost',
    'username' => 'security_user',
    'password' => 'SecurePassword123!',
    'database' => 'security_system'
];

$db = new DatabaseConnection($config, 'pdo');
$pdo = $db->connect();
echo "安全连接建立成功\n";
?>
```

## 三、创建数据库和数据表

### 3.1 创建数据库
```php
<?php
// 使用MySQLi创建数据库
function createDatabase($connection, $dbName) {
    $sql = "CREATE DATABASE IF NOT EXISTS $dbName 
            CHARACTER SET utf8mb4 
            COLLATE utf8mb4_unicode_ci";
    
    if ($connection->query($sql) === TRUE) {
        echo "数据库 '$dbName' 创建成功\n";
        return true;
    } else {
        echo "创建数据库错误: " . $connection->error . "\n";
        return false;
    }
}

// 使用PDO创建数据库
function createDatabasePDO($pdo, $dbName) {
    try {
        $sql = "CREATE DATABASE IF NOT EXISTS `$dbName` 
                CHARACTER SET utf8mb4 
                COLLATE utf8mb4_unicode_ci";
        
        $pdo->exec($sql);
        echo "数据库 '$dbName' 创建成功\n";
        return true;
        
    } catch (PDOException $e) {
        echo "创建数据库错误: " . $e->getMessage() . "\n";
        return false;
    }
}

// 创建安全系统数据库
$servername = "localhost";
$username = "root";
$password = "password";

try {
    $pdo = new PDO("mysql:host=$servername", $username, $password);
    $pdo->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
    
    createDatabasePDO($pdo, 'security_system');
    
    // 切换到新创建的数据库
    $pdo->exec("USE security_system");
    
} catch (PDOException $e) {
    die("操作失败: " . $e->getMessage());
}
?>
```

### 3.2 创建用户管理表
```php
<?php
function createUsersTable($pdo) {
    try {
        $sql = "
        CREATE TABLE IF NOT EXISTS users (
            id INT AUTO_INCREMENT PRIMARY KEY,
            username VARCHAR(50) UNIQUE NOT NULL,
            email VARCHAR(100) UNIQUE NOT NULL,
            password_hash VARCHAR(255) NOT NULL,
            salt VARCHAR(32) NOT NULL,
            role ENUM('admin', 'user', 'guest') DEFAULT 'user',
            status ENUM('active', 'inactive', 'banned') DEFAULT 'active',
            last_login DATETIME NULL,
            failed_login_attempts INT DEFAULT 0,
            locked_until DATETIME NULL,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
            INDEX idx_username (username),
            INDEX idx_email (email),
            INDEX idx_status (status)
        ) ENGINE=InnoDB CHARACTER SET=utf8mb4 COLLATE=utf8mb4_unicode_ci
        ";
        
        $pdo->exec($sql);
        echo "用户表创建成功\n";
        return true;
        
    } catch (PDOException $e) {
        echo "创建用户表失败: " . $e->getMessage() . "\n";
        return false;
    }
}

function createLogTable($pdo) {
    try {
        $sql = "
        CREATE TABLE IF NOT EXISTS security_logs (
            id BIGINT AUTO_INCREMENT PRIMARY KEY,
            user_id INT NULL,
            action VARCHAR(50) NOT NULL,
            resource VARCHAR(100) NULL,
            ip_address VARCHAR(45) NOT NULL,
            user_agent TEXT NULL,
            success BOOLEAN NOT NULL DEFAULT TRUE,
            error_message TEXT NULL,
            additional_data JSON NULL,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE SET NULL,
            INDEX idx_user_id (user_id),
            INDEX idx_action (action),
            INDEX idx_created_at (created_at),
            INDEX idx_ip_address (ip_address)
        ) ENGINE=InnoDB CHARACTER SET=utf8mb4 COLLATE=utf8mb4_unicode_ci
        ";
        
        $pdo->exec($sql);
        echo "日志表创建成功\n";
        return true;
        
    } catch (PDOException $e) {
        echo "创建日志表失败: " . $e->getMessage() . "\n";
        return false;
    }
}

function createSessionTable($pdo) {
    try {
        $sql = "
        CREATE TABLE IF NOT EXISTS user_sessions (
            id VARCHAR(128) PRIMARY KEY,
            user_id INT NOT NULL,
            ip_address VARCHAR(45) NOT NULL,
            user_agent VARCHAR(500) NULL,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            last_activity TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
            expires_at TIMESTAMP NOT NULL,
            is_active BOOLEAN DEFAULT TRUE,
            FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
            INDEX idx_user_id (user_id),
            INDEX idx_expires_at (expires_at),
            INDEX idx_last_activity (last_activity)
        ) ENGINE=InnoDB CHARACTER SET=utf8mb4 COLLATE=utf8mb4_unicode_ci
        ";
        
        $pdo->exec($sql);
        echo "会话表创建成功\n";
        return true;
        
    } catch (PDOException $e) {
        echo "创建会话表失败: " . $e->getMessage() . "\n";
        return false;
    }
}

// 创建所有表
createUsersTable($pdo);
createLogTable($pdo);
createSessionTable($pdo);
?>
```

### 3.3 创建权限管理表
```php
<?php
function createRBACTables($pdo) {
    try {
        // 角色表
        $sql_roles = "
        CREATE TABLE IF NOT EXISTS roles (
            id INT AUTO_INCREMENT PRIMARY KEY,
            name VARCHAR(50) UNIQUE NOT NULL,
            description TEXT NULL,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
        ) ENGINE=InnoDB CHARACTER SET=utf8mb4 COLLATE=utf8mb4_unicode_ci
        ";
        
        // 权限表
        $sql_permissions = "
        CREATE TABLE IF NOT EXISTS permissions (
            id INT AUTO_INCREMENT PRIMARY KEY,
            name VARCHAR(50) UNIQUE NOT NULL,
            description TEXT NULL,
            resource VARCHAR(50) NOT NULL,
            action VARCHAR(50) NOT NULL,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        ) ENGINE=InnoDB CHARACTER SET=utf8mb4 COLLATE=utf8mb4_unicode_ci
        ";
        
        // 角色权限关联表
        $sql_role_permissions = "
        CREATE TABLE IF NOT EXISTS role_permissions (
            role_id INT NOT NULL,
            permission_id INT NOT NULL,
            granted_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            PRIMARY KEY (role_id, permission_id),
            FOREIGN KEY (role_id) REFERENCES roles(id) ON DELETE CASCADE,
            FOREIGN KEY (permission_id) REFERENCES permissions(id) ON DELETE CASCADE
        ) ENGINE=InnoDB CHARACTER SET=utf8mb4 COLLATE=utf8mb4_unicode_ci
        ";
        
        // 用户角色关联表
        $sql_user_roles = "
        CREATE TABLE IF NOT EXISTS user_roles (
            user_id INT NOT NULL,
            role_id INT NOT NULL,
            assigned_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            expires_at TIMESTAMP NULL,
            assigned_by INT NULL,
            PRIMARY KEY (user_id, role_id),
            FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
            FOREIGN KEY (role_id) REFERENCES roles(id) ON DELETE CASCADE,
            FOREIGN KEY (assigned_by) REFERENCES users(id) ON DELETE SET NULL
        ) ENGINE=InnoDB CHARACTER SET=utf8mb4 COLLATE=utf8mb4_unicode_ci
        ";
        
        $pdo->exec($sql_roles);
        echo "角色表创建成功\n";
        
        $pdo->exec($sql_permissions);
        echo "权限表创建成功\n";
        
        $pdo->exec($sql_role_permissions);
        echo "角色权限关联表创建成功\n";
        
        $pdo->exec($sql_user_roles);
        echo "用户角色关联表创建成功\n";
        
        return true;
        
    } catch (PDOException $e) {
        echo "创建RBAC表失败: " . $e->getMessage() . "\n";
        return false;
    }
}

createRBACTables($pdo);
?>
```

## 四、安全的数据插入操作

### 4.1 基本数据插入
```php
<?php
// 不安全的插入方式（容易SQL注入）
function unsafeInsertUser($pdo, $username, $email) {
    // ❌ 危险：直接拼接SQL语句
    $sql = "INSERT INTO users (username, email) VALUES ('$username', '$email')";
    return $pdo->exec($sql);
}

// 安全的插入方式 - 使用预处理语句
function safeInsertUser($pdo, $userData) {
    try {
        // 生成安全的密码哈希
        $salt = bin2hex(random_bytes(16));
        $passwordHash = hash('sha256', $userData['password'] . $salt);
        
        $sql = "INSERT INTO users (username, email, password_hash, salt, role, status) 
                VALUES (:username, :email, :password_hash, :salt, :role, :status)";
        
        $stmt = $pdo->prepare($sql);
        $result = $stmt->execute([
            ':username' => $userData['username'],
            ':email' => $userData['email'],
            ':password_hash' => $passwordHash,
            ':salt' => $salt,
            ':role' => $userData['role'] ?? 'user',
            ':status' => $userData['status'] ?? 'active'
        ]);
        
        if ($result) {
            $userId = $pdo->lastInsertId();
            echo "用户创建成功，ID: $userId\n";
            return $userId;
        }
        
    } catch (PDOException $e) {
        echo "插入用户失败: " . $e->getMessage() . "\n";
        return false;
    }
}

// 批量插入用户数据
function batchInsertUsers($pdo, $users) {
    try {
        $pdo->beginTransaction();
        
        $sql = "INSERT INTO users (username, email, password_hash, salt, role) 
                VALUES (:username, :email, :password_hash, :salt, :role)";
        
        $stmt = $pdo->prepare($sql);
        $insertCount = 0;
        
        foreach ($users as $user) {
            // 验证数据
            if (!validateUserData($user)) {
                continue;
            }
            
            $salt = bin2hex(random_bytes(16));
            $passwordHash = hash('sha256', $user['password'] . $salt);
            
            $result = $stmt->execute([
                ':username' => $user['username'],
                ':email' => $user['email'],
                ':password_hash' => $passwordHash,
                ':salt' => $salt,
                ':role' => $user['role'] ?? 'user'
            ]);
            
            if ($result) {
                $insertCount++;
            }
        }
        
        $pdo->commit();
        echo "批量插入完成，成功插入 $insertCount 条记录\n";
        return $insertCount;
        
    } catch (PDOException $e) {
        $pdo->rollback();
        echo "批量插入失败: " . $e->getMessage() . "\n";
        return false;
    }
}

// 数据验证函数
function validateUserData($data) {
    $required = ['username', 'email', 'password'];
    
    foreach ($required as $field) {
        if (!isset($data[$field]) || empty($data[$field])) {
            return false;
        }
    }
    
    // 验证邮箱格式
    if (!filter_var($data['email'], FILTER_VALIDATE_EMAIL)) {
        return false;
    }
    
    // 验证用户名格式
    if (!preg_match('/^[a-zA-Z0-9_]{3,30}$/', $data['username'])) {
        return false;
    }
    
    // 验证密码强度
    if (strlen($data['password']) < 8) {
        return false;
    }
    
    return true;
}

// 使用示例
$newUser = [
    'username' => 'security_admin',
    'email' => 'admin@security.com',
    'password' => 'SecurePass123!',
    'role' => 'admin',
    'status' => 'active'
];

$userId = safeInsertUser($pdo, $newUser);

// 批量插入测试数据
$testUsers = [
    [
        'username' => 'user1',
        'email' => 'user1@test.com',
        'password' => 'TestPass123!',
        'role' => 'user'
    ],
    [
        'username' => 'user2',
        'email' => 'user2@test.com',
        'password' => 'TestPass456!',
        'role' => 'user'
    ],
    [
        'username' => 'moderator1',
        'email' => 'mod@test.com',
        'password' => 'ModPass789!',
        'role' => 'moderator'
    ]
];

batchInsertUsers($pdo, $testUsers);
?>
```

### 4.2 插入多条数据和关联数据
```php
<?php
class UserManager {
    private $pdo;
    
    public function __construct($pdo) {
        $this->pdo = $pdo;
    }
    
    public function createUserWithRoles($userData, $roleNames = []) {
        try {
            $this->pdo->beginTransaction();
            
            // 1. 创建用户
            $userId = $this->insertUser($userData);
            
            if (!$userId) {
                throw new Exception("用户创建失败");
            }
            
            // 2. 分配角色
            if (!empty($roleNames)) {
                $this->assignRolesToUser($userId, $roleNames);
            }
            
            // 3. 记录操作日志
            $this->logUserAction($userId, 'user_created', 'users', true);
            
            $this->pdo->commit();
            echo "用户及角色创建成功，用户ID: $userId\n";
            return $userId;
            
        } catch (Exception $e) {
            $this->pdo->rollback();
            $this->logUserAction(null, 'user_create_failed', 'users', false, $e->getMessage());
            echo "操作失败: " . $e->getMessage() . "\n";
            return false;
        }
    }
    
    private function insertUser($userData) {
        $salt = bin2hex(random_bytes(16));
        $passwordHash = password_hash($userData['password'] . $salt, PASSWORD_ARGON2ID);
        
        $sql = "INSERT INTO users (username, email, password_hash, salt, role, status) 
                VALUES (:username, :email, :password_hash, :salt, :role, :status)";
        
        $stmt = $this->pdo->prepare($sql);
        $result = $stmt->execute([
            ':username' => $userData['username'],
            ':email' => $userData['email'],
            ':password_hash' => $passwordHash,
            ':salt' => $salt,
            ':role' => $userData['role'] ?? 'user',
            ':status' => $userData['status'] ?? 'active'
        ]);
        
        return $result ? $this->pdo->lastInsertId() : false;
    }
    
    private function assignRolesToUser($userId, $roleNames) {
        // 获取角色ID
        $placeholders = str_repeat('?,', count($roleNames) - 1) . '?';
        $sql = "SELECT id, name FROM roles WHERE name IN ($placeholders)";
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute($roleNames);
        $roles = $stmt->fetchAll(PDO::FETCH_KEY_PAIR);
        
        // 插入用户角色关联
        $sql = "INSERT INTO user_roles (user_id, role_id, assigned_by) VALUES (?, ?, ?)";
        $stmt = $this->pdo->prepare($sql);
        
        foreach ($roles as $roleId => $roleName) {
            $stmt->execute([$userId, $roleId, 1]); // 1表示系统管理员
            echo "角色 '$roleName' 分配成功\n";
        }
    }
    
    private function logUserAction($userId, $action, $resource, $success, $errorMessage = null) {
        $sql = "INSERT INTO security_logs (user_id, action, resource, ip_address, user_agent, success, error_message) 
                VALUES (:user_id, :action, :resource, :ip_address, :user_agent, :success, :error_message)";
        
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([
            ':user_id' => $userId,
            ':action' => $action,
            ':resource' => $resource,
            ':ip_address' => $_SERVER['REMOTE_ADDR'] ?? '127.0.0.1',
            ':user_agent' => $_SERVER['HTTP_USER_AGENT'] ?? 'CLI',
            ':success' => $success ? 1 : 0,
            ':error_message' => $errorMessage
        ]);
    }
    
    public function insertPermissions($permissions) {
        try {
            $sql = "INSERT INTO permissions (name, description, resource, action) 
                    VALUES (:name, :description, :resource, :action)";
            $stmt = $this->pdo->prepare($sql);
            
            $insertCount = 0;
            foreach ($permissions as $permission) {
                $result = $stmt->execute([
                    ':name' => $permission['name'],
                    ':description' => $permission['description'],
                    ':resource' => $permission['resource'],
                    ':action' => $permission['action']
                ]);
                
                if ($result) {
                    $insertCount++;
                }
            }
            
            echo "权限插入完成，成功插入 $insertCount 条权限\n";
            return $insertCount;
            
        } catch (PDOException $e) {
            echo "插入权限失败: " . $e->getMessage() . "\n";
            return false;
        }
    }
}

// 使用示例
$userManager = new UserManager($pdo);

// 创建角色
$roles = [
    ['name' => 'admin', 'description' => '系统管理员'],
    ['name' => 'moderator', 'description' => '内容管理员'],
    ['name' => 'user', 'description' => '普通用户'],
    ['name' => 'guest', 'description' => '访客用户']
];

foreach ($roles as $role) {
    $sql = "INSERT IGNORE INTO roles (name, description) VALUES (:name, :description)";
    $stmt = $pdo->prepare($sql);
    $stmt->execute($role);
}

// 创建权限
$permissions = [
    ['name' => 'user.create', 'description' => '创建用户', 'resource' => 'user', 'action' => 'create'],
    ['name' => 'user.read', 'description' => '查看用户', 'resource' => 'user', 'action' => 'read'],
    ['name' => 'user.update', 'description' => '更新用户', 'resource' => 'user', 'action' => 'update'],
    ['name' => 'user.delete', 'description' => '删除用户', 'resource' => 'user', 'action' => 'delete'],
    ['name' => 'system.config', 'description' => '系统配置', 'resource' => 'system', 'action' => 'config']
];

$userManager->insertPermissions($permissions);

// 创建用户并分配角色
$newUser = [
    'username' => 'system_admin',
    'email' => 'sysadmin@security.com',
    'password' => 'SuperSecure123!@#',
    'role' => 'admin',
    'status' => 'active'
];

$userManager->createUserWithRoles($newUser, ['admin', 'moderator']);
?>
```

## 五、预处理语句详解

### 5.1 预处理语句的优势
```php
<?php
// 演示SQL注入攻击和防护

// 危险的动态SQL（容易受到SQL注入攻击）
function vulnerableLogin($pdo, $username, $password) {
    // ❌ 极度危险的代码
    $sql = "SELECT * FROM users WHERE username = '$username' AND password_hash = '$password'";
    echo "执行的SQL: $sql\n";
    
    try {
        $stmt = $pdo->query($sql);
        return $stmt->fetch();
    } catch (PDOException $e) {
        echo "查询错误: " . $e->getMessage() . "\n";
        return false;
    }
}

// 安全的预处理语句
function secureLogin($pdo, $username, $password) {
    try {
        // 1. 获取用户信息和盐值
        $sql = "SELECT id, username, password_hash, salt, role, status, failed_login_attempts, locked_until 
                FROM users 
                WHERE username = :username AND status = 'active'";
        
        $stmt = $pdo->prepare($sql);
        $stmt->execute([':username' => $username]);
        $user = $stmt->fetch();
        
        if (!$user) {
            return ['success' => false, 'message' => '用户名或密码错误'];
        }
        
        // 2. 检查账户锁定状态
        if ($user['locked_until'] && new DateTime() < new DateTime($user['locked_until'])) {
            return ['success' => false, 'message' => '账户已被锁定，请稍后再试'];
        }
        
        // 3. 验证密码
        $hashedPassword = password_verify($password . $user['salt'], $user['password_hash']);
        
        if ($hashedPassword) {
            // 登录成功，重置失败次数
            $this->resetFailedAttempts($pdo, $user['id']);
            $this->updateLastLogin($pdo, $user['id']);
            
            return [
                'success' => true, 
                'user' => [
                    'id' => $user['id'],
                    'username' => $user['username'],
                    'role' => $user['role']
                ]
            ];
        } else {
            // 登录失败，记录失败次数
            $this->recordFailedAttempt($pdo, $user['id']);
            return ['success' => false, 'message' => '用户名或密码错误'];
        }
        
    } catch (PDOException $e) {
        error_log("登录查询错误: " . $e->getMessage());
        return ['success' => false, 'message' => '系统错误，请稍后再试'];
    }
}

// 预处理语句的不同绑定方式
class PreparedStatementDemo {
    private $pdo;
    
    public function __construct($pdo) {
        $this->pdo = $pdo;
    }
    
    // 命名参数绑定
    public function namedParameterBinding($userId, $newEmail) {
        $sql = "UPDATE users SET email = :new_email, updated_at = :updated_at WHERE id = :user_id";
        
        $stmt = $this->pdo->prepare($sql);
        
        // 方式1：使用execute数组
        $result = $stmt->execute([
            ':user_id' => $userId,
            ':new_email' => $newEmail,
            ':updated_at' => date('Y-m-d H:i:s')
        ]);
        
        return $result;
    }
    
    // 位置参数绑定
    public function positionalParameterBinding($userId, $newEmail) {
        $sql = "UPDATE users SET email = ?, updated_at = ? WHERE id = ?";
        
        $stmt = $this->pdo->prepare($sql);
        
        // 方式1：使用execute数组
        $result = $stmt->execute([$newEmail, date('Y-m-d H:i:s'), $userId]);
        
        return $result;
    }
    
    // bindParam和bindValue的区别
    public function bindingComparison($userId, $status) {
        $sql = "UPDATE users SET status = :status WHERE id = :user_id";
        $stmt = $this->pdo->prepare($sql);
        
        // bindParam - 绑定变量引用
        $stmt->bindParam(':user_id', $userId, PDO::PARAM_INT);
        $stmt->bindParam(':status', $status, PDO::PARAM_STR);
        
        // 可以修改变量值，执行时会使用最新值
        $userId = 123;
        $status = 'inactive';
        
        return $stmt->execute();
    }
    
    // 批量操作预处理语句
    public function batchUpdateUsers($updates) {
        try {
            $this->pdo->beginTransaction();
            
            $sql = "UPDATE users SET email = :email, updated_at = NOW() WHERE id = :id";
            $stmt = $this->pdo->prepare($sql);
            
            $updateCount = 0;
            foreach ($updates as $update) {
                $result = $stmt->execute([
                    ':id' => $update['id'],
                    ':email' => $update['email']
                ]);
                
                if ($result && $stmt->rowCount() > 0) {
                    $updateCount++;
                }
            }
            
            $this->pdo->commit();
            echo "批量更新完成，影响 $updateCount 条记录\n";
            return $updateCount;
            
        } catch (PDOException $e) {
            $this->pdo->rollback();
            echo "批量更新失败: " . $e->getMessage() . "\n";
            return false;
        }
    }
}

// 演示预处理语句防止SQL注入
echo "=== SQL注入攻击演示 ===\n";

// 模拟恶意输入
$maliciousUsername = "admin' OR '1'='1"; // SQL注入攻击
$normalUsername = "security_admin";

echo "1. 恶意输入测试:\n";
echo "输入的用户名: $maliciousUsername\n";

// 使用不安全的方法（仅作演示，不要在生产环境使用）
echo "\n危险的SQL拼接方式会产生:\n";
$dangerousSQL = "SELECT * FROM users WHERE username = '$maliciousUsername' AND password_hash = 'test'";
echo "SQL: $dangerousSQL\n";
echo "这条SQL会返回所有用户，因为 '1'='1' 总是为真\n\n";

// 使用安全的预处理语句
echo "2. 预处理语句防护:\n";
$stmt = $pdo->prepare("SELECT * FROM users WHERE username = :username");
$stmt->execute([':username' => $maliciousUsername]);
$result = $stmt->fetch();

if ($result) {
    echo "找到用户: " . $result['username'] . "\n";
} else {
    echo "预处理语句正确处理了恶意输入，没有找到匹配的用户\n";
}

$demo = new PreparedStatementDemo($pdo);
?>
```

### 5.2 复杂查询的预处理语句
```php
<?php
class AdvancedQueryBuilder {
    private $pdo;
    
    public function __construct($pdo) {
        $this->pdo = $pdo;
    }
    
    // 动态构建WHERE条件
    public function searchUsers($filters = []) {
        $whereConditions = [];
        $parameters = [];
        
        $sql = "SELECT u.id, u.username, u.email, u.role, u.status, u.created_at,
                       GROUP_CONCAT(r.name) as roles
                FROM users u 
                LEFT JOIN user_roles ur ON u.id = ur.user_id 
                LEFT JOIN roles r ON ur.role_id = r.id";
        
        // 动态构建WHERE条件
        if (!empty($filters['username'])) {
            $whereConditions[] = "u.username LIKE :username";
            $parameters[':username'] = '%' . $filters['username'] . '%';
        }
        
        if (!empty($filters['email'])) {
            $whereConditions[] = "u.email LIKE :email";
            $parameters[':email'] = '%' . $filters['email'] . '%';
        }
        
        if (!empty($filters['role'])) {
            $whereConditions[] = "u.role = :role";
            $parameters[':role'] = $filters['role'];
        }
        
        if (!empty($filters['status'])) {
            $whereConditions[] = "u.status = :status";
            $parameters[':status'] = $filters['status'];
        }
        
        if (!empty($filters['created_from'])) {
            $whereConditions[] = "u.created_at >= :created_from";
            $parameters[':created_from'] = $filters['created_from'];
        }
        
        if (!empty($filters['created_to'])) {
            $whereConditions[] = "u.created_at <= :created_to";
            $parameters[':created_to'] = $filters['created_to'];
        }
        
        // 添加WHERE子句
        if (!empty($whereConditions)) {
            $sql .= " WHERE " . implode(' AND ', $whereConditions);
        }
        
        $sql .= " GROUP BY u.id";
        
        // 排序和分页
        $orderBy = $filters['order_by'] ?? 'u.created_at';
        $orderDirection = $filters['order_direction'] ?? 'DESC';
        $sql .= " ORDER BY $orderBy $orderDirection";
        
        if (isset($filters['limit'])) {
            $sql .= " LIMIT :limit";
            $parameters[':limit'] = (int)$filters['limit'];
            
            if (isset($filters['offset'])) {
                $sql .= " OFFSET :offset";
                $parameters[':offset'] = (int)$filters['offset'];
            }
        }
        
        try {
            $stmt = $this->pdo->prepare($sql);
            
            // 绑定分页参数（需要明确指定为整数类型）
            if (isset($parameters[':limit'])) {
                $stmt->bindValue(':limit', $parameters[':limit'], PDO::PARAM_INT);
                unset($parameters[':limit']);
            }
            if (isset($parameters[':offset'])) {
                $stmt->bindValue(':offset', $parameters[':offset'], PDO::PARAM_INT);
                unset($parameters[':offset']);
            }
            
            $stmt->execute($parameters);
            return $stmt->fetchAll();
            
        } catch (PDOException $e) {
            echo "查询错误: " . $e->getMessage() . "\n";
            return [];
        }
    }
    
    // 复杂的统计查询
    public function getUserStatistics($dateRange = []) {
        $sql = "
        SELECT 
            COUNT(*) as total_users,
            COUNT(CASE WHEN status = 'active' THEN 1 END) as active_users,
            COUNT(CASE WHEN status = 'inactive' THEN 1 END) as inactive_users,
            COUNT(CASE WHEN status = 'banned' THEN 1 END) as banned_users,
            COUNT(CASE WHEN role = 'admin' THEN 1 END) as admin_users,
            COUNT(CASE WHEN role = 'user' THEN 1 END) as regular_users,
            COUNT(CASE WHEN last_login >= DATE_SUB(NOW(), INTERVAL 30 DAY) THEN 1 END) as recent_logins,
            AVG(failed_login_attempts) as avg_failed_attempts
        FROM users";
        
        $parameters = [];
        $whereConditions = [];
        
        if (!empty($dateRange['from'])) {
            $whereConditions[] = "created_at >= :date_from";
            $parameters[':date_from'] = $dateRange['from'];
        }
        
        if (!empty($dateRange['to'])) {
            $whereConditions[] = "created_at <= :date_to";
            $parameters[':date_to'] = $dateRange['to'];
        }
        
        if (!empty($whereConditions)) {
            $sql .= " WHERE " . implode(' AND ', $whereConditions);
        }
        
        try {
            $stmt = $this->pdo->prepare($sql);
            $stmt->execute($parameters);
            return $stmt->fetch();
            
        } catch (PDOException $e) {
            echo "统计查询错误: " . $e->getMessage() . "\n";
            return null;
        }
    }
    
    // 安全的IN查询
    public function getUsersByIds($userIds) {
        if (empty($userIds) || !is_array($userIds)) {
            return [];
        }
        
        // 确保所有ID都是整数
        $userIds = array_map('intval', $userIds);
        
        // 创建占位符
        $placeholders = str_repeat('?,', count($userIds) - 1) . '?';
        
        $sql = "SELECT id, username, email, role, status 
                FROM users 
                WHERE id IN ($placeholders) 
                ORDER BY username";
        
        try {
            $stmt = $this->pdo->prepare($sql);
            $stmt->execute($userIds);
            return $stmt->fetchAll();
            
        } catch (PDOException $e) {
            echo "批量查询错误: " . $e->getMessage() . "\n";
            return [];
        }
    }
}

// 使用示例
$queryBuilder = new AdvancedQueryBuilder($pdo);

echo "=== 高级查询测试 ===\n";

// 1. 搜索用户
$filters = [
    'username' => 'admin',
    'status' => 'active',
    'limit' => 10,
    'offset' => 0,
    'order_by' => 'u.created_at',
    'order_direction' => 'DESC'
];

$users = $queryBuilder->searchUsers($filters);
echo "搜索结果：找到 " . count($users) . " 个用户\n";
foreach ($users as $user) {
    echo "- {$user['username']} ({$user['email']}) - {$user['role']}\n";
}

// 2. 用户统计
$stats = $queryBuilder->getUserStatistics();
if ($stats) {
    echo "\n用户统计信息：\n";
    echo "总用户数: {$stats['total_users']}\n";
    echo "活跃用户: {$stats['active_users']}\n";
    echo "管理员: {$stats['admin_users']}\n";
    echo "最近30天登录: {$stats['recent_logins']}\n";
}

// 3. 批量查询
$userIds = [1, 2, 3];
$batchUsers = $queryBuilder->getUsersByIds($userIds);
echo "\n批量查询结果：\n";
foreach ($batchUsers as $user) {
    echo "ID {$user['id']}: {$user['username']}\n";
}
?>
```

## 六、读取数据的最佳实践

### 6.1 基本数据读取
```php
<?php
class DataReader {
    private $pdo;
    
    public function __construct($pdo) {
        $this->pdo = $pdo;
    }
    
    // 获取单个用户
    public function getUserById($userId) {
        try {
            $sql = "SELECT id, username, email, role, status, created_at, last_login 
                    FROM users 
                    WHERE id = :id";
            
            $stmt = $this->pdo->prepare($sql);
            $stmt->execute([':id' => $userId]);
            
            return $stmt->fetch(PDO::FETCH_ASSOC);
            
        } catch (PDOException $e) {
            error_log("获取用户信息错误: " . $e->getMessage());
            return null;
        }
    }
    
    // 获取用户列表（带分页）
    public function getUserList($page = 1, $pageSize = 20, $filters = []) {
        try {
            $offset = ($page - 1) * $pageSize;
            
            $whereClause = $this->buildWhereClause($filters);
            $countSql = "SELECT COUNT(*) FROM users" . $whereClause['sql'];
            $dataSql = "SELECT id, username, email, role, status, created_at, last_login 
                        FROM users" . $whereClause['sql'] . " 
                        ORDER BY created_at DESC 
                        LIMIT :limit OFFSET :offset";
            
            // 获取总数
            $countStmt = $this->pdo->prepare($countSql);
            $countStmt->execute($whereClause['parameters']);
            $totalCount = $countStmt->fetchColumn();
            
            // 获取数据
            $dataStmt = $this->pdo->prepare($dataSql);
            $dataStmt->bindValue(':limit', $pageSize, PDO::PARAM_INT);
            $dataStmt->bindValue(':offset', $offset, PDO::PARAM_INT);
            $dataStmt->execute($whereClause['parameters']);
            
            return [
                'data' => $dataStmt->fetchAll(PDO::FETCH_ASSOC),
                'pagination' => [
                    'current_page' => $page,
                    'page_size' => $pageSize,
                    'total_count' => $totalCount,
                    'total_pages' => ceil($totalCount / $pageSize)
                ]
            ];
            
        } catch (PDOException $e) {
            error_log("获取用户列表错误: " . $e->getMessage());
            return ['data' => [], 'pagination' => []];
        }
    }
    
    // 获取用户详细信息（包括角色和权限）
    public function getUserDetails($userId) {
        try {
            $this->pdo->beginTransaction();
            
            // 基本用户信息
            $userSql = "SELECT id, username, email, role, status, created_at, last_login, 
                               failed_login_attempts, locked_until 
                        FROM users WHERE id = :id";
            $userStmt = $this->pdo->prepare($userSql);
            $userStmt->execute([':id' => $userId]);
            $user = $userStmt->fetch(PDO::FETCH_ASSOC);
            
            if (!$user) {
                return null;
            }
            
            // 用户角色
            $rolesSql = "SELECT r.id, r.name, r.description, ur.assigned_at
                        FROM roles r
                        INNER JOIN user_roles ur ON r.id = ur.role_id
                        WHERE ur.user_id = :user_id";
            $rolesStmt = $this->pdo->prepare($rolesSql);
            $rolesStmt->execute([':user_id' => $userId]);
            $user['roles'] = $rolesStmt->fetchAll(PDO::FETCH_ASSOC);
            
            // 用户权限（通过角色获取）
            $permissionsSql = "SELECT DISTINCT p.id, p.name, p.description, p.resource, p.action
                              FROM permissions p
                              INNER JOIN role_permissions rp ON p.id = rp.permission_id
                              INNER JOIN user_roles ur ON rp.role_id = ur.role_id
                              WHERE ur.user_id = :user_id";
            $permissionsStmt = $this->pdo->prepare($permissionsSql);
            $permissionsStmt->execute([':user_id' => $userId]);
            $user['permissions'] = $permissionsStmt->fetchAll(PDO::FETCH_ASSOC);
            
            // 最近登录记录
            $sessionsSql = "SELECT ip_address, user_agent, created_at, last_activity, expires_at
                           FROM user_sessions
                           WHERE user_id = :user_id
                           ORDER BY created_at DESC
                           LIMIT 5";
            $sessionsStmt = $this->pdo->prepare($sessionsSql);
            $sessionsStmt->execute([':user_id' => $userId]);
            $user['recent_sessions'] = $sessionsStmt->fetchAll(PDO::FETCH_ASSOC);
            
            $this->pdo->commit();
            return $user;
            
        } catch (PDOException $e) {
            $this->pdo->rollback();
            error_log("获取用户详细信息错误: " . $e->getMessage());
            return null;
        }
    }
    
    // 获取安全日志
    public function getSecurityLogs($userId = null, $limit = 100, $offset = 0) {
        try {
            $whereClause = $userId ? "WHERE user_id = :user_id" : "";
            
            $sql = "SELECT sl.*, u.username 
                    FROM security_logs sl
                    LEFT JOIN users u ON sl.user_id = u.id
                    $whereClause
                    ORDER BY sl.created_at DESC
                    LIMIT :limit OFFSET :offset";
            
            $stmt = $this->pdo->prepare($sql);
            
            if ($userId) {
                $stmt->bindValue(':user_id', $userId, PDO::PARAM_INT);
            }
            $stmt->bindValue(':limit', $limit, PDO::PARAM_INT);
            $stmt->bindValue(':offset', $offset, PDO::PARAM_INT);
            
            $stmt->execute();
            return $stmt->fetchAll(PDO::FETCH_ASSOC);
            
        } catch (PDOException $e) {
            error_log("获取安全日志错误: " . $e->getMessage());
            return [];
        }
    }
    
    // 构建WHERE子句
    private function buildWhereClause($filters) {
        $conditions = [];
        $parameters = [];
        
        if (!empty($filters['username'])) {
            $conditions[] = "username LIKE :username";
            $parameters[':username'] = '%' . $filters['username'] . '%';
        }
        
        if (!empty($filters['email'])) {
            $conditions[] = "email LIKE :email";
            $parameters[':email'] = '%' . $filters['email'] . '%';
        }
        
        if (!empty($filters['role'])) {
            $conditions[] = "role = :role";
            $parameters[':role'] = $filters['role'];
        }
        
        if (!empty($filters['status'])) {
            $conditions[] = "status = :status";
            $parameters[':status'] = $filters['status'];
        }
        
        $sql = empty($conditions) ? "" : " WHERE " . implode(' AND ', $conditions);
        
        return ['sql' => $sql, 'parameters' => $parameters];
    }
}

// 数据缓存层
class CachedDataReader {
    private $dataReader;
    private $cache;
    private $cacheExpiry;
    
    public function __construct(DataReader $dataReader, $cacheExpiry = 300) {
        $this->dataReader = $dataReader;
        $this->cache = [];
        $this->cacheExpiry = $cacheExpiry;
    }
    
    public function getUserById($userId) {
        $cacheKey = "user_$userId";
        
        if ($this->isCacheValid($cacheKey)) {
            return $this->cache[$cacheKey]['data'];
        }
        
        $user = $this->dataReader->getUserById($userId);
        
        if ($user) {
            $this->cache[$cacheKey] = [
                'data' => $user,
                'timestamp' => time()
            ];
        }
        
        return $user;
    }
    
    public function getUserDetails($userId) {
        $cacheKey = "user_details_$userId";
        
        if ($this->isCacheValid($cacheKey)) {
            return $this->cache[$cacheKey]['data'];
        }
        
        $userDetails = $this->dataReader->getUserDetails($userId);
        
        if ($userDetails) {
            $this->cache[$cacheKey] = [
                'data' => $userDetails,
                'timestamp' => time()
            ];
        }
        
        return $userDetails;
    }
    
    public function clearCache($pattern = null) {
        if ($pattern) {
            foreach (array_keys($this->cache) as $key) {
                if (strpos($key, $pattern) !== false) {
                    unset($this->cache[$key]);
                }
            }
        } else {
            $this->cache = [];
        }
    }
    
    private function isCacheValid($key) {
        return isset($this->cache[$key]) && 
               (time() - $this->cache[$key]['timestamp']) < $this->cacheExpiry;
    }
}

// 使用示例
$dataReader = new DataReader($pdo);
$cachedReader = new CachedDataReader($dataReader);

echo "=== 数据读取测试 ===\n";

// 1. 获取用户列表
$userList = $dataReader->getUserList(1, 5);
echo "用户列表 (第1页):\n";
foreach ($userList['data'] as $user) {
    echo "- ID:{$user['id']} {$user['username']} ({$user['email']}) [{$user['status']}]\n";
}
echo "分页信息: 第{$userList['pagination']['current_page']}页，共{$userList['pagination']['total_pages']}页\n\n";

// 2. 获取用户详细信息
$userDetails = $cachedReader->getUserDetails(1);
if ($userDetails) {
    echo "用户详细信息:\n";
    echo "用户名: {$userDetails['username']}\n";
    echo "邮箱: {$userDetails['email']}\n";
    echo "角色数量: " . count($userDetails['roles']) . "\n";
    echo "权限数量: " . count($userDetails['permissions']) . "\n";
    echo "最近会话: " . count($userDetails['recent_sessions']) . "\n\n";
}

// 3. 获取安全日志
$logs = $dataReader->getSecurityLogs(null, 5);
echo "最近5条安全日志:\n";
foreach ($logs as $log) {
    $username = $log['username'] ?: '系统';
    $status = $log['success'] ? '成功' : '失败';
    echo "- {$log['created_at']} | $username | {$log['action']} | $status\n";
}
?>
```

### 6.2 高性能数据读取
```php
<?php
class HighPerformanceReader {
    private $pdo;
    private $queryCache = [];
    
    public function __construct($pdo) {
        $this->pdo = $pdo;
        // 优化PDO性能
        $this->pdo->setAttribute(PDO::ATTR_DEFAULT_FETCH_MODE, PDO::FETCH_ASSOC);
        $this->pdo->setAttribute(PDO::MYSQL_ATTR_USE_BUFFERED_QUERY, false);
    }
    
    // 使用游标进行大数据集处理
    public function processBulkUsers($callback, $batchSize = 1000) {
        try {
            $sql = "SELECT id, username, email, status FROM users ORDER BY id";
            $stmt = $this->pdo->prepare($sql);
            $stmt->execute();
            
            $count = 0;
            while ($user = $stmt->fetch()) {
                $callback($user);
                $count++;
                
                if ($count % $batchSize === 0) {
                    echo "已处理 $count 条记录\n";
                    // 可以在这里释放内存或进行其他批处理操作
                    gc_collect_cycles();
                }
            }
            
            echo "总计处理 $count 条记录\n";
            return $count;
            
        } catch (PDOException $e) {
            echo "批量处理错误: " . $e->getMessage() . "\n";
            return 0;
        }
    }
    
    // 预编译查询缓存
    public function getCachedStatement($key, $sql) {
        if (!isset($this->queryCache[$key])) {
            $this->queryCache[$key] = $this->pdo->prepare($sql);
        }
        return $this->queryCache[$key];
    }
    
    // 快速用户验证
    public function quickUserValidation($username) {
        $stmt = $this->getCachedStatement(
            'user_validation',
            "SELECT id, status FROM users WHERE username = ? LIMIT 1"
        );
        
        $stmt->execute([$username]);
        return $stmt->fetch();
    }
    
    // 批量获取用户状态
    public function batchGetUserStatus($usernames) {
        if (empty($usernames)) return [];
        
        $placeholders = str_repeat('?,', count($usernames) - 1) . '?';
        $sql = "SELECT username, status FROM users WHERE username IN ($placeholders)";
        
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute($usernames);
        
        return $stmt->fetchAll(PDO::FETCH_KEY_PAIR);
    }
    
    // 内存友好的大结果集迭代器
    public function getUserIterator($filters = []) {
        $whereClause = $this->buildWhereClause($filters);
        $sql = "SELECT id, username, email, role, status FROM users" . 
               $whereClause['sql'] . " ORDER BY id";
        
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute($whereClause['parameters']);
        
        return new UserResultIterator($stmt);
    }
}

// 结果集迭代器
class UserResultIterator implements Iterator {
    private $stmt;
    private $current;
    private $key;
    
    public function __construct($stmt) {
        $this->stmt = $stmt;
        $this->key = 0;
    }
    
    public function rewind(): void {
        $this->key = 0;
        $this->current = $this->stmt->fetch();
    }
    
    public function current(): mixed {
        return $this->current;
    }
    
    public function key(): mixed {
        return $this->key;
    }
    
    public function next(): void {
        $this->key++;
        $this->current = $this->stmt->fetch();
    }
    
    public function valid(): bool {
        return $this->current !== false;
    }
}

// 连接池管理
class ConnectionPool {
    private $connections = [];
    private $config;
    private $maxConnections;
    private $activeConnections = 0;
    
    public function __construct($config, $maxConnections = 10) {
        $this->config = $config;
        $this->maxConnections = $maxConnections;
    }
    
    public function getConnection() {
        // 尝试从池中获取现有连接
        if (!empty($this->connections)) {
            $connection = array_pop($this->connections);
            if ($this->isConnectionAlive($connection)) {
                return $connection;
            }
        }
        
        // 创建新连接
        if ($this->activeConnections < $this->maxConnections) {
            $connection = $this->createConnection();
            $this->activeConnections++;
            return $connection;
        }
        
        throw new Exception("连接池已满，无法创建新连接");
    }
    
    public function releaseConnection($connection) {
        if ($connection && $this->isConnectionAlive($connection)) {
            $this->connections[] = $connection;
        } else {
            $this->activeConnections--;
        }
    }
    
    private function createConnection() {
        $dsn = "mysql:host={$this->config['host']};dbname={$this->config['database']};charset=utf8mb4";
        $options = [
            PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,
            PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC,
            PDO::ATTR_EMULATE_PREPARES => false,
            PDO::ATTR_PERSISTENT => false
        ];
        
        return new PDO($dsn, $this->config['username'], $this->config['password'], $options);
    }
    
    private function isConnectionAlive($connection) {
        try {
            $connection->query("SELECT 1");
            return true;
        } catch (PDOException $e) {
            return false;
        }
    }
    
    public function closeAll() {
        $this->connections = [];
        $this->activeConnections = 0;
    }
}

// 使用示例
echo "=== 高性能数据读取测试 ===\n";

$performanceReader = new HighPerformanceReader($pdo);

// 1. 批量处理用户数据
echo "1. 批量处理测试:\n";
$processCount = $performanceReader->processBulkUsers(function($user) {
    // 模拟数据处理
    if ($user['status'] === 'inactive') {
        // 处理非活跃用户
    }
}, 2);

// 2. 快速用户验证
echo "\n2. 快速验证测试:\n";
$validationResult = $performanceReader->quickUserValidation('security_admin');
if ($validationResult) {
    echo "用户验证成功: ID {$validationResult['id']}, 状态: {$validationResult['status']}\n";
}

// 3. 批量状态查询
echo "\n3. 批量状态查询:\n";
$statuses = $performanceReader->batchGetUserStatus(['security_admin', 'user1', 'nonexistent']);
foreach ($statuses as $username => $status) {
    echo "$username: $status\n";
}

// 4. 迭代器使用
echo "\n4. 大结果集迭代:\n";
$iterator = $performanceReader->getUserIterator(['status' => 'active']);
$count = 0;
foreach ($iterator as $user) {
    echo "处理用户: {$user['username']}\n";
    $count++;
    if ($count >= 3) break; // 限制输出
}

// 5. 连接池测试
echo "\n5. 连接池测试:\n";
$pool = new ConnectionPool($config, 5);

try {
    $conn1 = $pool->getConnection();
    $conn2 = $pool->getConnection();
    echo "成功从连接池获取2个连接\n";
    
    // 使用连接
    $stmt = $conn1->query("SELECT COUNT(*) as count FROM users");
    $result = $stmt->fetch();
    echo "查询结果: {$result['count']} 个用户\n";
    
    // 释放连接
    $pool->releaseConnection($conn1);
    $pool->releaseConnection($conn2);
    echo "连接已释放回池中\n";
    
} catch (Exception $e) {
    echo "连接池错误: " . $e->getMessage() . "\n";
}
?>
```

## 七、数据更新和删除操作

### 7.1 安全的更新操作
```php
<?php
class SecureDataUpdater {
    private $pdo;
    
    public function __construct($pdo) {
        $this->pdo = $pdo;
    }
    
    // 更新用户信息
    public function updateUser($userId, $updateData, $operatorId = null) {
        try {
            $this->pdo->beginTransaction();
            
            // 验证用户存在性
            if (!$this->userExists($userId)) {
                throw new Exception("用户不存在");
            }
            
            // 构建更新字段
            $updateFields = [];
            $parameters = [':user_id' => $userId];
            
            $allowedFields = ['username', 'email', 'role', 'status'];
            foreach ($allowedFields as $field) {
                if (isset($updateData[$field])) {
                    $updateFields[] = "$field = :$field";
                    $parameters[":$field"] = $updateData[$field];
                }
            }
            
            if (empty($updateFields)) {
                throw new Exception("没有可更新的字段");
            }
            
            // 添加更新时间
            $updateFields[] = "updated_at = NOW()";
            
            $sql = "UPDATE users SET " . implode(', ', $updateFields) . " WHERE id = :user_id";
            
            $stmt = $this->pdo->prepare($sql);
            $result = $stmt->execute($parameters);
            
            if (!$result || $stmt->rowCount() === 0) {
                throw new Exception("更新失败或没有数据被修改");
            }
            
            // 记录操作日志
            $this->logOperation($operatorId, 'user_update', "用户ID: $userId", $updateData);
            
            $this->pdo->commit();
            return true;
            
        } catch (Exception $e) {
            $this->pdo->rollback();
            $this->logOperation($operatorId, 'user_update_failed', "用户ID: $userId", 
                              ['error' => $e->getMessage()]);
            throw $e;
        }
    }
    
    // 批量更新用户状态
    public function batchUpdateUserStatus($userIds, $newStatus, $operatorId = null) {
        if (empty($userIds) || !is_array($userIds)) {
            throw new InvalidArgumentException("用户ID数组不能为空");
        }
        
        try {
            $this->pdo->beginTransaction();
            
            // 验证状态值
            $validStatuses = ['active', 'inactive', 'banned'];
            if (!in_array($newStatus, $validStatuses)) {
                throw new InvalidArgumentException("无效的用户状态");
            }
            
            // 构建IN查询的占位符
            $userIds = array_map('intval', $userIds); // 确保是整数
            $placeholders = str_repeat('?,', count($userIds) - 1) . '?';
            
            $sql = "UPDATE users SET status = ?, updated_at = NOW() 
                    WHERE id IN ($placeholders) AND status != ?";
            
            $stmt = $this->pdo->prepare($sql);
            $params = array_merge([$newStatus], $userIds, [$newStatus]);
            $result = $stmt->execute($params);
            
            $affectedRows = $stmt->rowCount();
            
            if ($affectedRows > 0) {
                $this->logOperation($operatorId, 'batch_user_status_update', 
                                  "批量更新用户状态为 $newStatus", [
                                      'user_ids' => $userIds,
                                      'new_status' => $newStatus,
                                      'affected_rows' => $affectedRows
                                  ]);
            }
            
            $this->pdo->commit();
            return $affectedRows;
            
        } catch (Exception $e) {
            $this->pdo->rollback();
            throw $e;
        }
    }
    
    // 更新用户密码
    public function updateUserPassword($userId, $newPassword, $operatorId = null) {
        try {
            $this->pdo->beginTransaction();
            
            if (!$this->userExists($userId)) {
                throw new Exception("用户不存在");
            }
            
            // 验证密码强度
            if (!$this->validatePasswordStrength($newPassword)) {
                throw new Exception("密码强度不符合要求");
            }
            
            // 生成新的盐值和哈希
            $salt = bin2hex(random_bytes(16));
            $passwordHash = password_hash($newPassword . $salt, PASSWORD_ARGON2ID);
            
            $sql = "UPDATE users SET 
                        password_hash = :password_hash, 
                        salt = :salt, 
                        updated_at = NOW(),
                        failed_login_attempts = 0,
                        locked_until = NULL
                    WHERE id = :user_id";
            
            $stmt = $this->pdo->prepare($sql);
            $result = $stmt->execute([
                ':password_hash' => $passwordHash,
                ':salt' => $salt,
                ':user_id' => $userId
            ]);
            
            if (!$result || $stmt->rowCount() === 0) {
                throw new Exception("密码更新失败");
            }
            
            // 使所有现有会话失效
            $this->invalidateUserSessions($userId);
            
            $this->logOperation($operatorId, 'password_update', "用户ID: $userId", 
                              ['password_changed' => true]);
            
            $this->pdo->commit();
            return true;
            
        } catch (Exception $e) {
            $this->pdo->rollback();
            throw $e;
        }
    }
    
    // 软删除用户
    public function softDeleteUser($userId, $operatorId = null) {
        try {
            $this->pdo->beginTransaction();
            
            // 检查用户是否存在且未被删除
            $user = $this->getUserForUpdate($userId);
            if (!$user) {
                throw new Exception("用户不存在");
            }
            
            if ($user['status'] === 'deleted') {
                throw new Exception("用户已被删除");
            }
            
            // 更新为已删除状态
            $sql = "UPDATE users SET 
                        status = 'deleted',
                        deleted_at = NOW(),
                        updated_at = NOW()
                    WHERE id = :user_id";
            
            $stmt = $this->pdo->prepare($sql);
            $result = $stmt->execute([':user_id' => $userId]);
            
            if (!$result || $stmt->rowCount() === 0) {
                throw new Exception("删除用户失败");
            }
            
            // 删除用户会话
            $this->invalidateUserSessions($userId);
            
            // 删除用户角色关联
            $this->removeUserRoles($userId);
            
            $this->logOperation($operatorId, 'user_soft_delete', "用户ID: $userId", 
                              ['username' => $user['username']]);
            
            $this->pdo->commit();
            return true;
            
        } catch (Exception $e) {
            $this->pdo->rollback();
            throw $e;
        }
    }
    
    // 硬删除用户（慎用）
    public function hardDeleteUser($userId, $operatorId = null, $confirmation = false) {
        if (!$confirmation) {
            throw new Exception("硬删除操作需要明确确认");
        }
        
        try {
            $this->pdo->beginTransaction();
            
            // 获取用户信息用于日志
            $user = $this->getUserForUpdate($userId);
            if (!$user) {
                throw new Exception("用户不存在");
            }
            
            // 删除关联数据
            $this->cleanupUserData($userId);
            
            // 删除用户记录
            $sql = "DELETE FROM users WHERE id = :user_id";
            $stmt = $this->pdo->prepare($sql);
            $result = $stmt->execute([':user_id' => $userId]);
            
            if (!$result || $stmt->rowCount() === 0) {
                throw new Exception("删除用户失败");
            }
            
            $this->logOperation($operatorId, 'user_hard_delete', "用户ID: $userId", [
                'username' => $user['username'],
                'email' => $user['email']
            ]);
            
            $this->pdo->commit();
            return true;
            
        } catch (Exception $e) {
            $this->pdo->rollback();
            throw $e;
        }
    }
    
    // 辅助方法
    private function userExists($userId) {
        $sql = "SELECT 1 FROM users WHERE id = :user_id LIMIT 1";
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([':user_id' => $userId]);
        return $stmt->fetchColumn() !== false;
    }
    
    private function getUserForUpdate($userId) {
        $sql = "SELECT id, username, email, status FROM users WHERE id = :user_id FOR UPDATE";
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([':user_id' => $userId]);
        return $stmt->fetch();
    }
    
    private function validatePasswordStrength($password) {
        // 至少8位，包含大小写字母、数字和特殊字符
        return preg_match('/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/', $password);
    }
    
    private function invalidateUserSessions($userId) {
        $sql = "UPDATE user_sessions SET is_active = FALSE WHERE user_id = :user_id";
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([':user_id' => $userId]);
    }
    
    private function removeUserRoles($userId) {
        $sql = "DELETE FROM user_roles WHERE user_id = :user_id";
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([':user_id' => $userId]);
    }
    
    private function cleanupUserData($userId) {
        // 删除用户会话
        $sql = "DELETE FROM user_sessions WHERE user_id = :user_id";
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([':user_id' => $userId]);
        
        // 删除用户角色关联
        $this->removeUserRoles($userId);
        
        // 将安全日志中的用户ID设为NULL（保留日志但不关联用户）
        $sql = "UPDATE security_logs SET user_id = NULL WHERE user_id = :user_id";
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([':user_id' => $userId]);
    }
    
    private function logOperation($operatorId, $action, $description, $data = []) {
        $sql = "INSERT INTO security_logs (user_id, action, resource, ip_address, success, additional_data) 
                VALUES (:user_id, :action, :resource, :ip_address, :success, :additional_data)";
        
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([
            ':user_id' => $operatorId,
            ':action' => $action,
            ':resource' => $description,
            ':ip_address' => $_SERVER['REMOTE_ADDR'] ?? '127.0.0.1',
            ':success' => 1,
            ':additional_data' => json_encode($data)
        ]);
    }
}

// 使用示例
echo "=== 数据更新和删除测试 ===\n";

$updater = new SecureDataUpdater($pdo);

try {
    // 1. 更新用户信息
    echo "1. 更新用户信息测试:\n";
    $updateData = [
        'email' => 'new_admin@security.com',
        'status' => 'active'
    ];
    
    $result = $updater->updateUser(1, $updateData, 1);
    if ($result) {
        echo "用户信息更新成功\n";
    }
    
    // 2. 批量更新用户状态
    echo "\n2. 批量更新用户状态:\n";
    $userIds = [2, 3]; // 假设这些用户存在
    $affectedRows = $updater->batchUpdateUserStatus($userIds, 'inactive', 1);
    echo "批量更新完成，影响 $affectedRows 行记录\n";
    
    // 3. 更新密码
    echo "\n3. 更新用户密码:\n";
    $passwordResult = $updater->updateUserPassword(1, 'NewSecurePass123!@#', 1);
    if ($passwordResult) {
        echo "密码更新成功\n";
    }
    
    // 4. 软删除用户
    echo "\n4. 软删除用户测试:\n";
    if (false) { // 设为false以避免实际删除
        $deleteResult = $updater->softDeleteUser(3, 1);
        if ($deleteResult) {
            echo "用户软删除成功\n";
        }
    } else {
        echo "软删除测试已跳过\n";
    }
    
} catch (Exception $e) {
    echo "操作失败: " . $e->getMessage() . "\n";
}
?>
```

## 八、事务处理和并发控制

### 8.1 事务基础和ACID特性
```php
<?php
class TransactionManager {
    private $pdo;
    private $transactionLevel = 0;
    private $rollbackOnly = false;
    
    public function __construct($pdo) {
        $this->pdo = $pdo;
    }
    
    // 嵌套事务支持
    public function beginTransaction() {
        if ($this->transactionLevel === 0) {
            $this->pdo->beginTransaction();
            $this->rollbackOnly = false;
        } else {
            // 创建保存点
            $savepoint = "sp_" . $this->transactionLevel;
            $this->pdo->exec("SAVEPOINT $savepoint");
        }
        
        $this->transactionLevel++;
        return $this->transactionLevel;
    }
    
    public function commit() {
        if ($this->transactionLevel === 0) {
            throw new Exception("没有活动的事务");
        }
        
        $this->transactionLevel--;
        
        if ($this->transactionLevel === 0) {
            if ($this->rollbackOnly) {
                $this->pdo->rollback();
                throw new Exception("事务被标记为只能回滚");
            } else {
                $this->pdo->commit();
            }
        }
        // 内嵌事务不需要特殊处理
    }
    
    public function rollback() {
        if ($this->transactionLevel === 0) {
            throw new Exception("没有活动的事务");
        }
        
        if ($this->transactionLevel === 1) {
            $this->pdo->rollback();
            $this->transactionLevel = 0;
            $this->rollbackOnly = false;
        } else {
            // 回滚到保存点
            $savepoint = "sp_" . ($this->transactionLevel - 1);
            $this->pdo->exec("ROLLBACK TO SAVEPOINT $savepoint");
            $this->transactionLevel--;
        }
    }
    
    public function setRollbackOnly() {
        $this->rollbackOnly = true;
    }
    
    public function isRollbackOnly() {
        return $this->rollbackOnly;
    }
    
    // 事务模板方法
    public function executeInTransaction(callable $callback) {
        $this->beginTransaction();
        
        try {
            $result = $callback();
            $this->commit();
            return $result;
        } catch (Exception $e) {
            $this->rollback();
            throw $e;
        }
    }
}

// 银行转账示例（经典的事务场景）
class BankTransferService {
    private $pdo;
    private $transactionManager;
    
    public function __construct($pdo) {
        $this->pdo = $pdo;
        $this->transactionManager = new TransactionManager($pdo);
        
        // 创建账户表（如果不存在）
        $this->createAccountTable();
    }
    
    private function createAccountTable() {
        $sql = "
        CREATE TABLE IF NOT EXISTS accounts (
            id INT AUTO_INCREMENT PRIMARY KEY,
            account_number VARCHAR(20) UNIQUE NOT NULL,
            owner_name VARCHAR(100) NOT NULL,
            balance DECIMAL(15,2) NOT NULL DEFAULT 0.00,
            status ENUM('active', 'frozen', 'closed') DEFAULT 'active',
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
            version INT NOT NULL DEFAULT 1,
            INDEX idx_account_number (account_number)
        ) ENGINE=InnoDB
        ";
        
        $this->pdo->exec($sql);
        
        // 插入测试账户
        $accounts = [
            ['account_number' => 'ACC001', 'owner_name' => '张三', 'balance' => 1000.00],
            ['account_number' => 'ACC002', 'owner_name' => '李四', 'balance' => 500.00],
            ['account_number' => 'ACC003', 'owner_name' => '王五', 'balance' => 2000.00]
        ];
        
        foreach ($accounts as $account) {
            $sql = "INSERT IGNORE INTO accounts (account_number, owner_name, balance) VALUES (?, ?, ?)";
            $stmt = $this->pdo->prepare($sql);
            $stmt->execute([$account['account_number'], $account['owner_name'], $account['balance']]);
        }
    }
    
    // 安全的转账操作
    public function transfer($fromAccount, $toAccount, $amount, $description = '') {
        return $this->transactionManager->executeInTransaction(function() use ($fromAccount, $toAccount, $amount, $description) {
            
            // 参数验证
            if ($amount <= 0) {
                throw new InvalidArgumentException("转账金额必须大于0");
            }
            
            if ($fromAccount === $toAccount) {
                throw new InvalidArgumentException("不能向同一账户转账");
            }
            
            // 获取账户信息（使用悲观锁）
            $fromAccountData = $this->getAccountForUpdate($fromAccount);
            $toAccountData = $this->getAccountForUpdate($toAccount);
            
            if (!$fromAccountData || !$toAccountData) {
                throw new Exception("账户不存在");
            }
            
            if ($fromAccountData['status'] !== 'active' || $toAccountData['status'] !== 'active') {
                throw new Exception("账户状态不允许转账");
            }
            
            // 检查余额
            if ($fromAccountData['balance'] < $amount) {
                throw new Exception("余额不足");
            }
            
            // 更新账户余额（使用乐观锁）
            $this->updateAccountBalance($fromAccount, -$amount, $fromAccountData['version']);
            $this->updateAccountBalance($toAccount, $amount, $toAccountData['version']);
            
            // 记录转账日志
            $transferId = $this->logTransfer($fromAccount, $toAccount, $amount, $description);
            
            return [
                'transfer_id' => $transferId,
                'from_account' => $fromAccount,
                'to_account' => $toAccount,
                'amount' => $amount,
                'status' => 'completed'
            ];
        });
    }
    
    private function getAccountForUpdate($accountNumber) {
        $sql = "SELECT id, account_number, owner_name, balance, status, version 
                FROM accounts 
                WHERE account_number = :account_number 
                FOR UPDATE";
        
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([':account_number' => $accountNumber]);
        return $stmt->fetch();
    }
    
    private function updateAccountBalance($accountNumber, $amount, $expectedVersion) {
        $sql = "UPDATE accounts 
                SET balance = balance + :amount, 
                    version = version + 1,
                    updated_at = NOW()
                WHERE account_number = :account_number 
                AND version = :expected_version";
        
        $stmt = $this->pdo->prepare($sql);
        $result = $stmt->execute([
            ':amount' => $amount,
            ':account_number' => $accountNumber,
            ':expected_version' => $expectedVersion
        ]);
        
        if ($stmt->rowCount() === 0) {
            throw new Exception("账户更新失败，可能存在并发冲突");
        }
        
        return true;
    }
    
    private function logTransfer($fromAccount, $toAccount, $amount, $description) {
        // 创建转账日志表
        $createLogTable = "
        CREATE TABLE IF NOT EXISTS transfer_logs (
            id INT AUTO_INCREMENT PRIMARY KEY,
            from_account VARCHAR(20) NOT NULL,
            to_account VARCHAR(20) NOT NULL,
            amount DECIMAL(15,2) NOT NULL,
            description TEXT,
            status ENUM('pending', 'completed', 'failed') DEFAULT 'completed',
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            INDEX idx_from_account (from_account),
            INDEX idx_to_account (to_account),
            INDEX idx_created_at (created_at)
        ) ENGINE=InnoDB
        ";
        
        $this->pdo->exec($createLogTable);
        
        $sql = "INSERT INTO transfer_logs (from_account, to_account, amount, description) 
                VALUES (:from_account, :to_account, :amount, :description)";
        
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([
            ':from_account' => $fromAccount,
            ':to_account' => $toAccount,
            ':amount' => $amount,
            ':description' => $description
        ]);
        
        return $this->pdo->lastInsertId();
    }
    
    // 获取账户余额
    public function getBalance($accountNumber) {
        $sql = "SELECT balance FROM accounts WHERE account_number = :account_number";
        $stmt = $this->pdo->prepare($sql);
        $stmt->execute([':account_number' => $accountNumber]);
        
        $result = $stmt->fetch();
        return $result ? $result['balance'] : null;
    }
    
    // 获取转账历史
    public function getTransferHistory($accountNumber, $limit = 50) {
        $sql = "SELECT * FROM transfer_logs 
                WHERE from_account = :account_number OR to_account = :account_number 
                ORDER BY created_at DESC 
                LIMIT :limit";
        
        $stmt = $this->pdo->prepare($sql);
        $stmt->bindValue(':account_number', $accountNumber);
        $stmt->bindValue(':limit', $limit, PDO::PARAM_INT);
        $stmt->execute();
        
        return $stmt->fetchAll();
    }
}

// 并发测试工具
class ConcurrencyTester {
    private $bankService;
    
    public function __construct(BankTransferService $bankService) {
        $this->bankService = $bankService;
    }
    
    // 模拟并发转账（测试锁机制）
    public function simulateConcurrentTransfers() {
        echo "=== 并发转账测试 ===\n";
        
        // 显示初始余额
        echo "初始余额:\n";
        echo "ACC001: " . $this->bankService->getBalance('ACC001') . "\n";
        echo "ACC002: " . $this->bankService->getBalance('ACC002') . "\n";
        echo "ACC003: " . $this->bankService->getBalance('ACC003') . "\n\n";
        
        // 模拟多个并发转账
        $transfers = [
            ['from' => 'ACC001', 'to' => 'ACC002', 'amount' => 100, 'desc' => '转账1'],
            ['from' => 'ACC001', 'to' => 'ACC003', 'amount' => 200, 'desc' => '转账2'],
            ['from' => 'ACC002', 'to' => 'ACC003', 'amount' => 150, 'desc' => '转账3'],
            ['from' => 'ACC003', 'to' => 'ACC001', 'amount' => 300, 'desc' => '转账4']
        ];
        
        $results = [];
        foreach ($transfers as $index => $transfer) {
            try {
                $result = $this->bankService->transfer(
                    $transfer['from'], 
                    $transfer['to'], 
                    $transfer['amount'], 
                    $transfer['desc']
                );
                $results[] = ['index' => $index, 'status' => 'success', 'result' => $result];
                echo "转账 " . ($index + 1) . " 成功\n";
                
            } catch (Exception $e) {
                $results[] = ['index' => $index, 'status' => 'failed', 'error' => $e->getMessage()];
                echo "转账 " . ($index + 1) . " 失败: " . $e->getMessage() . "\n";
            }
        }
        
        // 显示最终余额
        echo "\n最终余额:\n";
        echo "ACC001: " . $this->bankService->getBalance('ACC001') . "\n";
        echo "ACC002: " . $this->bankService->getBalance('ACC002') . "\n";
        echo "ACC003: " . $this->bankService->getBalance('ACC003') . "\n";
        
        return $results;
    }
}

// 使用示例和测试
echo "=== 事务处理和并发控制测试 ===\n";

$bankService = new BankTransferService($pdo);
$concurrencyTester = new ConcurrencyTester($bankService);

try {
    // 1. 正常转账测试
    echo "1. 正常转账测试:\n";
    $result = $bankService->transfer('ACC001', 'ACC002', 50.00, '测试转账');
    echo "转账成功，转账ID: {$result['transfer_id']}\n\n";
    
    // 2. 异常情况测试
    echo "2. 异常情况测试:\n";
    try {
        $bankService->transfer('ACC002', 'ACC001', 10000.00, '余额不足测试');
    } catch (Exception $e) {
        echo "预期的异常: " . $e->getMessage() . "\n";
    }
    
    try {
        $bankService->transfer('ACC001', 'NONEXISTENT', 10.00, '账户不存在测试');
    } catch (Exception $e) {
        echo "预期的异常: " . $e->getMessage() . "\n\n";
    }
    
    // 3. 并发测试
    $concurrencyResults = $concurrencyTester->simulateConcurrentTransfers();
    
    // 4. 查看转账历史
    echo "\nACC001的转账历史:\n";
    $history = $bankService->getTransferHistory('ACC001', 5);
    foreach ($history as $transfer) {
        $direction = $transfer['from_account'] === 'ACC001' ? '转出到' : '从' . $transfer['from_account'] . '转入';
        $otherAccount = $transfer['from_account'] === 'ACC001' ? $transfer['to_account'] : $transfer['from_account'];
        echo "- {$transfer['created_at']}: $direction $otherAccount, 金额: {$transfer['amount']}\n";
    }
    
} catch (Exception $e) {
    echo "测试过程中发生错误: " . $e->getMessage() . "\n";
}
?>
```

## 九、课程总结

### 9.1 核心知识点回顾

**连接管理：**
- MySQLi vs PDO：两种主要连接方式的对比和选择
- 连接池技术：提高数据库连接效率
- 安全连接配置：字符集、错误处理、持久连接等

**数据库操作：**
- 数据库和表的创建：DDL操作的安全实践
- 数据插入：预处理语句、批量插入、事务保护
- 数据查询：分页、过滤、关联查询、性能优化
- 数据更新：字段更新、批量更新、版本控制
- 数据删除：软删除vs硬删除、级联删除

**安全防护：**
- SQL注入防护：预处理语句的正确使用
- 输入验证：数据类型、格式、长度验证
- 权限控制：最小权限原则、操作审计
- 错误处理：安全的错误信息展示

**性能优化：**
- 查询优化：索引使用、查询计划分析
- 连接优化：连接池、持久连接管理
- 内存优化：大结果集处理、游标使用
- 缓存策略：查询结果缓存、预编译语句缓存

**事务处理：**
- ACID特性：原子性、一致性、隔离性、持久性
- 并发控制：乐观锁、悲观锁、死锁处理
- 嵌套事务：保存点的使用和管理

### 9.2 实际应用场景

1. **用户管理系统**
   - 用户注册、登录、权限管理
   - 密码安全存储和验证
   - 会话管理和安全审计

2. **电商系统**
   - 订单处理、库存管理
   - 支付流程、退款处理
   - 数据一致性保证

3. **内容管理系统**
   - 文章发布、分类管理
   - 评论系统、权限控制
   - 数据版本管理

4. **日志和监控系统**
   - 操作日志记录
   - 性能监控数据收集
   - 报表生成和分析

### 9.3 最佳实践总结

**开发规范：**
- 始终使用预处理语句
- 实施输入验证和输出过滤
- 采用最小权限原则
- 建立完整的错误处理机制

**安全规范：**
- 密码安全存储（盐值+强哈希算法）
- 敏感操作的审计日志
- 数据库连接加密
- 定期安全审查和渗透测试

**性能规范：**
- 合理使用索引和查询优化
- 实施连接池和缓存策略
- 监控数据库性能指标
- 定期进行容量规划

**运维规范：**
- 定期备份和恢复测试
- 数据库版本控制和迁移
- 监控和告警机制
- 灾难恢复计划

### 9.4 进阶学习方向

1. **数据库设计**
   - 关系型数据库设计原则
   - 数据库范式和反范式化
   - 分库分表策略

2. **高级特性**
   - 存储过程和函数
   - 触发器和事件调度
   - 视图和物化视图

3. **性能调优**
   - 查询执行计划分析
   - 索引优化策略
   - 硬件和配置优化

4. **高可用架构**
   - 主从复制和读写分离
   - 集群和分布式部署
   - 负载均衡和故障转移

通过本课程的学习，学生已经掌握了PHP与MySQL集成开发的核心技能，能够在实际项目中安全、高效地进行数据库操作，为后续的Web安全开发和大型项目实践打下了坚实的基础。