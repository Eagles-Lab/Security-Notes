# PHP类与对象

## 一、面向对象名词解释

### 1.1 什么是面向对象编程（OOP）？

面向对象编程（Object-Oriented Programming，OOP）是一种编程范式，它将现实世界的概念抽象为代码中的"对象"。在PHP中，面向对象编程提供了更好的代码组织方式、复用性和安全性。

在网络安全领域，面向对象编程有以下优势：
- **封装性**：隐藏内部实现，减少安全漏洞暴露面
- **继承性**：复用安全验证逻辑
- **多态性**：统一的安全接口，不同的实现方式
- **模块化**：便于安全审计和代码维护

### 1.2 核心概念解释

| 概念 | 定义 | 安全意义 | 示例 |
|------|------|----------|------|
| **类（Class）** | 对象的模板或蓝图 | 定义安全规则和验证逻辑的统一标准 | `class UserValidator` |
| **对象（Object）** | 类的实例，具体的实体 | 具体的安全验证器实例 | `$validator = new UserValidator()` |
| **属性（Property）** | 对象的特征或数据 | 存储敏感配置和状态信息 | `private $secretKey` |
| **方法（Method）** | 对象的行为或功能 | 执行安全检查和数据处理 | `public function validate()` |
| **封装（Encapsulation）** | 隐藏内部实现细节 | 保护敏感信息不被外部访问 | `private`、`protected` 修饰符 |
| **继承（Inheritance）** | 子类获得父类的特性 | 复用安全基类的验证逻辑 | `class AdminUser extends User` |
| **多态（Polymorphism）** | 同一接口的不同实现 | 统一的安全接口，不同级别的验证 | 接口实现 |
| **抽象（Abstraction）** | 隐藏复杂性，暴露简单接口 | 简化安全API的使用复杂度 | 抽象类和接口 |

## 二、类的定义

### 2.1 基本类语法

PHP中使用 `class` 关键字定义类，类名通常使用 PascalCase（首字母大写）命名：

```php
<?php
    // 基本类定义
    class User {
        // 属性（成员变量）
        public $username;
        public $email;
        private $password;
        
        // 方法（成员函数）
        public function setUsername($username) {
            $this->username = $username;
        }
        
        public function getUsername() {
            return $this->username;
        }
        
        // 私有方法，外部无法访问
        private function hashPassword($password) {
            return password_hash($password, PASSWORD_DEFAULT);
        }
    }
    
    // 创建对象
    $user = new User();
    $user->setUsername("alice");
    echo $user->getUsername(); // 输出: alice
?>
```

### 2.2 安全的类设计示例

```php
<?php
    // 安全的用户认证类
    class SecureAuthenticator {
        private $users = [];
        private $maxAttempts = 3;
        private $lockoutTime = 300; // 5分钟
        private $attempts = [];
        
        // 添加用户
        public function addUser($username, $password, $role = 'user') {
            // 输入验证
            if (empty($username) || empty($password)) {
                throw new InvalidArgumentException('用户名和密码不能为空');
            }
            
            if (strlen($password) < 8) {
                throw new InvalidArgumentException('密码长度至少8位');
            }
            
            $this->users[$username] = [
                'password_hash' => password_hash($password, PASSWORD_DEFAULT),
                'role' => $role,
                'created_at' => time()
            ];
        }
        
        // 验证用户
        public function authenticate($username, $password) {
            // 检查账户是否被锁定
            if ($this->isAccountLocked($username)) {
                throw new Exception('账户已被锁定，请稍后再试');
            }
            
            // 检查用户是否存在
            if (!isset($this->users[$username])) {
                $this->recordFailedAttempt($username);
                return false;
            }
            
            // 验证密码
            $user = $this->users[$username];
            if (password_verify($password, $user['password_hash'])) {
                $this->clearFailedAttempts($username);
                return [
                    'username' => $username,
                    'role' => $user['role'],
                    'login_time' => time()
                ];
            } else {
                $this->recordFailedAttempt($username);
                return false;
            }
        }
        
        // 检查账户是否被锁定
        private function isAccountLocked($username) {
            if (!isset($this->attempts[$username])) {
                return false;
            }
            
            $attempts = $this->attempts[$username];
            if ($attempts['count'] >= $this->maxAttempts) {
                if (time() - $attempts['last_attempt'] < $this->lockoutTime) {
                    return true;
                }
                // 锁定时间已过，重置尝试次数
                unset($this->attempts[$username]);
            }
            
            return false;
        }
        
        // 记录失败尝试
        private function recordFailedAttempt($username) {
            if (!isset($this->attempts[$username])) {
                $this->attempts[$username] = ['count' => 0, 'last_attempt' => 0];
            }
            
            $this->attempts[$username]['count']++;
            $this->attempts[$username]['last_attempt'] = time();
        }
        
        // 清除失败尝试记录
        private function clearFailedAttempts($username) {
            unset($this->attempts[$username]);
        }
    }
?>
```

### 2.3 $this 关键字的使用

`$this` 是一个特殊变量，指向当前对象实例：

```php
<?php
    class SecurityConfig {
        private $settings = [];
        
        public function set($key, $value) {
            // 使用 $this 访问当前对象的属性
            $this->settings[$key] = $value;
            return $this; // 返回当前对象，支持链式调用
        }
        
        public function get($key, $default = null) {
            return $this->settings[$key] ?? $default;
        }
        
        public function validate() {
            // 使用 $this 调用当前对象的方法
            if (!$this->hasRequiredSettings()) {
                throw new Exception('缺少必要的安全配置');
            }
            return $this;
        }
        
        private function hasRequiredSettings() {
            $required = ['secret_key', 'encryption_algorithm', 'token_expiry'];
            foreach ($required as $setting) {
                if (!isset($this->settings[$setting])) {
                    return false;
                }
            }
            return true;
        }
    }
    
    // 链式调用示例
    $config = new SecurityConfig();
    $config->set('secret_key', 'your-secret-key')
           ->set('encryption_algorithm', 'AES-256-CBC')
           ->set('token_expiry', 3600)
           ->validate();
?>
```

## 三、构造函数

### 3.1 构造函数基础

构造函数是在创建对象时自动调用的特殊方法，用于初始化对象的状态：

```php
<?php
    class DatabaseConnection {
        private $host;
        private $database;
        private $username;
        private $password;
        private $connection;
        
        // 构造函数
        public function __construct($host, $database, $username, $password) {
            $this->host = $host;
            $this->database = $database;
            $this->username = $username;
            $this->password = $password;
            
            // 在构造时建立连接
            $this->connect();
        }
        
        private function connect() {
            try {
                $dsn = "mysql:host={$this->host};dbname={$this->database};charset=utf8mb4";
                $this->connection = new PDO($dsn, $this->username, $this->password, [
                    PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,
                    PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC,
                    PDO::ATTR_EMULATE_PREPARES => false,
                ]);
            } catch (PDOException $e) {
                throw new Exception('数据库连接失败: ' . $e->getMessage());
            }
        }
        
        public function getConnection() {
            return $this->connection;
        }
    }
    
    // 使用构造函数
    try {
        $db = new DatabaseConnection('localhost', 'security_db', 'user', 'password');
        $conn = $db->getConnection();
        echo "数据库连接成功";
    } catch (Exception $e) {
        echo "错误: " . $e->getMessage();
    }
?>
```

### 3.2 安全的构造函数设计

```php
<?php
    class SecureFileManager {
        private $basePath;
        private $allowedExtensions;
        private $maxFileSize;
        
        public function __construct($basePath, $allowedExtensions = ['txt', 'jpg', 'png'], $maxFileSize = 1048576) {
            // 验证基础路径
            if (!is_dir($basePath) || !is_readable($basePath)) {
                throw new InvalidArgumentException('基础路径不存在或不可读');
            }
            
            // 获取真实路径，防止路径遍历
            $realPath = realpath($basePath);
            if ($realPath === false) {
                throw new InvalidArgumentException('无效的基础路径');
            }
            
            $this->basePath = $realPath;
            $this->allowedExtensions = array_map('strtolower', $allowedExtensions);
            $this->maxFileSize = $maxFileSize;
            
            // 创建必要的目录结构
            $this->initializeDirectories();
        }
        
        private function initializeDirectories() {
            $dirs = ['uploads', 'temp', 'logs'];
            foreach ($dirs as $dir) {
                $fullPath = $this->basePath . DIRECTORY_SEPARATOR . $dir;
                if (!is_dir($fullPath)) {
                    if (!mkdir($fullPath, 0755, true)) {
                        throw new Exception("无法创建目录: $fullPath");
                    }
                }
            }
        }
        
        public function uploadFile($file, $directory = 'uploads') {
            // 验证文件
            if ($file['error'] !== UPLOAD_ERR_OK) {
                throw new Exception('文件上传失败');
            }
            
            if ($file['size'] > $this->maxFileSize) {
                throw new Exception('文件大小超过限制');
            }
            
            $extension = strtolower(pathinfo($file['name'], PATHINFO_EXTENSION));
            if (!in_array($extension, $this->allowedExtensions)) {
                throw new Exception('不允许的文件类型');
            }
            
            // 生成安全的文件名
            $filename = uniqid() . '.' . $extension;
            $destination = $this->basePath . DIRECTORY_SEPARATOR . $directory . DIRECTORY_SEPARATOR . $filename;
            
            if (move_uploaded_file($file['tmp_name'], $destination)) {
                return $filename;
            } else {
                throw new Exception('文件保存失败');
            }
        }
    }
?>
```

## 四、析构函数

### 4.1 析构函数基础

析构函数在对象被销毁时自动调用，用于清理资源：

```php
<?php
    class LogManager {
        private $logFile;
        private $fileHandle;
        
        public function __construct($logFile) {
            $this->logFile = $logFile;
            $this->fileHandle = fopen($logFile, 'a');
            
            if (!$this->fileHandle) {
                throw new Exception('无法打开日志文件');
            }
            
            $this->log('INFO', '日志管理器初始化');
        }
        
        public function log($level, $message) {
            $timestamp = date('Y-m-d H:i:s');
            $logEntry = "[$timestamp] [$level] $message" . PHP_EOL;
            fwrite($this->fileHandle, $logEntry);
        }
        
        // 析构函数
        public function __destruct() {
            if ($this->fileHandle) {
                $this->log('INFO', '日志管理器关闭');
                fclose($this->fileHandle);
            }
        }
    }
    
    // 使用示例
    function testLogging() {
        $logger = new LogManager('./security.log');
        $logger->log('WARNING', '检测到异常访问');
        $logger->log('ERROR', '权限验证失败');
        // 函数结束时，$logger 对象会被自动销毁，析构函数被调用
    }
    
    testLogging();
?>
```

### 4.2 安全资源清理

```php
<?php
    class SecureConnection {
        private $connection;
        private $encrypted = false;
        private $sessionKey;
        
        public function __construct($host, $port) {
            $this->connection = fsockopen($host, $port, $errno, $errstr, 30);
            
            if (!$this->connection) {
                throw new Exception("连接失败: $errstr ($errno)");
            }
            
            // 生成会话密钥
            $this->sessionKey = random_bytes(32);
        }
        
        public function enableEncryption() {
            // 启用加密
            $this->encrypted = true;
        }
        
        public function sendData($data) {
            if ($this->encrypted) {
                $data = $this->encrypt($data);
            }
            
            fwrite($this->connection, $data);
        }
        
        private function encrypt($data) {
            // 简化的加密示例
            return base64_encode($data);
        }
        
        // 析构函数 - 安全清理
        public function __destruct() {
            // 清除敏感数据
            if ($this->sessionKey) {
                // 用随机数据覆盖密钥
                $this->sessionKey = random_bytes(32);
                $this->sessionKey = null;
            }
            
            // 关闭连接
            if ($this->connection) {
                fclose($this->connection);
            }
            
            // 记录清理日志
            error_log('SecureConnection: 资源已安全清理');
        }
    }
?>
```

## 五、继承

### 5.1 继承基础

继承允许一个类（子类）获得另一个类（父类）的所有属性和方法：

```php
<?php
    // 父类 - 基础用户类
    class User {
        protected $username;
        protected $email;
        protected $createdAt;
        
        public function __construct($username, $email) {
            $this->username = $username;
            $this->email = $email;
            $this->createdAt = time();
        }
        
        public function getUsername() {
            return $this->username;
        }
        
        public function getEmail() {
            return $this->email;
        }
        
        // 基础权限检查
        public function hasPermission($action) {
            // 普通用户默认权限很少
            return in_array($action, ['read', 'comment']);
        }
        
        protected function log($message) {
            error_log("[User: {$this->username}] $message");
        }
    }
    
    // 子类 - 管理员用户类
    class AdminUser extends User {
        private $adminLevel;
        
        public function __construct($username, $email, $adminLevel = 1) {
            // 调用父类构造函数
            parent::__construct($username, $email);
            $this->adminLevel = $adminLevel;
            $this->log('管理员用户创建');
        }
        
        // 重写父类方法
        public function hasPermission($action) {
            // 管理员有更多权限
            $adminPermissions = ['read', 'write', 'delete', 'manage_users'];
            return in_array($action, $adminPermissions);
        }
        
        // 新增管理员特有方法
        public function deleteUser($userId) {
            if (!$this->hasPermission('delete')) {
                throw new Exception('权限不足');
            }
            
            $this->log("删除用户: $userId");
            // 实际删除逻辑
        }
        
        public function getAdminLevel() {
            return $this->adminLevel;
        }
    }
    
    // 子类 - 编辑用户类
    class EditorUser extends User {
        private $departments = [];
        
        public function __construct($username, $email, $departments = []) {
            parent::__construct($username, $email);
            $this->departments = $departments;
            $this->log('编辑用户创建');
        }
        
        public function hasPermission($action) {
            // 编辑用户的权限介于普通用户和管理员之间
            $editorPermissions = ['read', 'write', 'comment', 'edit'];
            return in_array($action, $editorPermissions);
        }
        
        public function canEditDepartment($department) {
            return in_array($department, $this->departments);
        }
    }
    
    // 使用示例
    $regularUser = new User('alice', 'alice@example.com');
    $admin = new AdminUser('admin', 'admin@example.com', 2);
    $editor = new EditorUser('editor', 'editor@example.com', ['news', 'blog']);
    
    // 测试权限
    echo $regularUser->hasPermission('delete') ? '有删除权限' : '无删除权限'; // 无删除权限
    echo $admin->hasPermission('delete') ? '有删除权限' : '无删除权限';      // 有删除权限
    echo $editor->hasPermission('write') ? '有写入权限' : '无写入权限';      // 有写入权限
?>
```

### 5.2 安全继承设计模式

```php
<?php
    // 抽象安全验证基类
    abstract class SecurityValidator {
        protected $errors = [];
        protected $warnings = [];
        
        // 抽象方法 - 子类必须实现
        abstract public function validate($input);
        
        // 通用验证方法
        protected function addError($message) {
            $this->errors[] = $message;
            error_log("验证错误: $message");
        }
        
        protected function addWarning($message) {
            $this->warnings[] = $message;
            error_log("验证警告: $message");
        }
        
        public function getErrors() {
            return $this->errors;
        }
        
        public function getWarnings() {
            return $this->warnings;
        }
        
        public function isValid() {
            return empty($this->errors);
        }
        
        public function reset() {
            $this->errors = [];
            $this->warnings = [];
        }
    }
    
    // 邮箱验证器
    class EmailValidator extends SecurityValidator {
        private $allowedDomains = [];
        private $blockedDomains = ['tempmail.com', 'guerrillamail.com'];
        
        public function __construct($allowedDomains = []) {
            $this->allowedDomains = $allowedDomains;
        }
        
        public function validate($email) {
            $this->reset();
            
            // 基础格式验证
            if (!filter_var($email, FILTER_VALIDATE_EMAIL)) {
                $this->addError('邮箱格式无效');
                return false;
            }
            
            // 长度检查
            if (strlen($email) > 254) {
                $this->addError('邮箱地址过长');
                return false;
            }
            
            // 域名检查
            $domain = substr(strrchr($email, "@"), 1);
            
            // 检查黑名单域名
            if (in_array($domain, $this->blockedDomains)) {
                $this->addError('不允许使用临时邮箱服务');
                return false;
            }
            
            // 检查白名单域名
            if (!empty($this->allowedDomains) && !in_array($domain, $this->allowedDomains)) {
                $this->addWarning('邮箱域名不在推荐列表中');
            }
            
            return $this->isValid();
        }
    }
    
    // 密码验证器
    class PasswordValidator extends SecurityValidator {
        private $minLength = 8;
        private $requireUppercase = true;
        private $requireLowercase = true;
        private $requireNumbers = true;
        private $requireSpecialChars = true;
        private $commonPasswords = ['123456', 'password', 'admin', 'qwerty'];
        
        public function validate($password) {
            $this->reset();
            
            // 长度检查
            if (strlen($password) < $this->minLength) {
                $this->addError("密码长度至少{$this->minLength}位");
            }
            
            // 复杂度检查
            if ($this->requireUppercase && !preg_match('/[A-Z]/', $password)) {
                $this->addError('密码必须包含大写字母');
            }
            
            if ($this->requireLowercase && !preg_match('/[a-z]/', $password)) {
                $this->addError('密码必须包含小写字母');
            }
            
            if ($this->requireNumbers && !preg_match('/[0-9]/', $password)) {
                $this->addError('密码必须包含数字');
            }
            
            if ($this->requireSpecialChars && !preg_match('/[^a-zA-Z0-9]/', $password)) {
                $this->addError('密码必须包含特殊字符');
            }
            
            // 常见密码检查
            if (in_array(strtolower($password), $this->commonPasswords)) {
                $this->addError('不能使用常见密码');
            }
            
            // 重复字符检查
            if (preg_match('/(.)\1{2,}/', $password)) {
                $this->addWarning('密码包含过多重复字符');
            }
            
            return $this->isValid();
        }
    }
?>
```

## 六、方法重写

方法重写（Override）允许子类重新定义父类的方法：

```php
<?php
    class Logger {
        protected $logLevel = 'INFO';
        
        public function log($message, $level = null) {
            $level = $level ?: $this->logLevel;
            $timestamp = date('Y-m-d H:i:s');
            echo "[$timestamp] [$level] $message\n";
        }
        
        protected function formatMessage($message) {
            return $message;
        }
    }
    
    class SecurityLogger extends Logger {
        protected $logLevel = 'WARNING';
        private $sensitivePatterns = ['/password\s*[:=]\s*\S+/i', '/token\s*[:=]\s*\S+/i'];
        
        // 重写父类的log方法
        public function log($message, $level = null) {
            // 清理敏感信息
            $cleanMessage = $this->formatMessage($message);
            
            // 调用父类方法
            parent::log($cleanMessage, $level);
            
            // 额外的安全日志记录
            if (in_array($level, ['ERROR', 'CRITICAL'])) {
                $this->notifySecurityTeam($cleanMessage);
            }
        }
        
        // 重写父类的formatMessage方法
        protected function formatMessage($message) {
            // 移除敏感信息
            foreach ($this->sensitivePatterns as $pattern) {
                $message = preg_replace($pattern, '[FILTERED]', $message);
            }
            
            // 添加安全标识
            return "[SECURITY] " . $message;
        }
        
        private function notifySecurityTeam($message) {
            // 发送安全警报
            error_log("SECURITY ALERT: $message");
        }
    }
    
    // 使用示例
    $regularLogger = new Logger();
    $securityLogger = new SecurityLogger();
    
    $regularLogger->log('用户登录成功');
    $securityLogger->log('登录失败，密码错误: password=secret123', 'ERROR');
?>
```

## 七、访问控制

### 7.1 访问修饰符

PHP提供三种访问修饰符来控制属性和方法的访问权限：

| 修饰符 | 访问权限 | 安全用途 | 示例 |
|--------|----------|----------|------|
| `public` | 任何地方都可访问 | 公共接口方法 | `public function login()` |
| `protected` | 本类和子类可访问 | 继承链内的安全方法 | `protected function validateToken()` |
| `private` | 仅本类内可访问 | 敏感数据和内部方法 | `private $secretKey` |

```php
<?php
    class SecureAPI {
        public $version = '1.0';           // 公共属性
        protected $apiKey;                 // 受保护属性
        private $secretKey;                // 私有属性
        
        public function __construct($apiKey, $secretKey) {
            $this->apiKey = $apiKey;
            $this->secretKey = $secretKey;
        }
        
        // 公共方法 - 外部接口
        public function authenticate($userKey) {
            if ($this->isValidKey($userKey)) {
                return $this->generateToken();
            }
            return false;
        }
        
        // 受保护方法 - 子类可使用
        protected function isValidKey($key) {
            return hash_equals($this->apiKey, $key);
        }
        
        // 私有方法 - 仅本类可使用
        private function generateToken() {
            $payload = [
                'timestamp' => time(),
                'random' => bin2hex(random_bytes(16))
            ];
            
            return $this->sign(base64_encode(json_encode($payload)));
        }
        
        private function sign($data) {
            return hash_hmac('sha256', $data, $this->secretKey);
        }
    }
    
    class ExtendedAPI extends SecureAPI {
        // 可以访问protected成员
        public function verifyKey($key) {
            return $this->isValidKey($key); // OK - protected方法可访问
        }
        
        public function getSecretKey() {
            // return $this->secretKey; // 错误 - private属性不可访问
        }
    }
?>
```

### 7.2 Getter和Setter方法

通过Getter和Setter方法控制属性访问，实现数据验证和安全控制：

```php
<?php
    class UserAccount {
        private $username;
        private $email;
        private $balance = 0.0;
        private $isActive = true;
        
        // Setter方法 - 设置用户名
        public function setUsername($username) {
            // 输入验证
            if (empty($username)) {
                throw new InvalidArgumentException('用户名不能为空');
            }
            
            if (strlen($username) < 3 || strlen($username) > 50) {
                throw new InvalidArgumentException('用户名长度必须在3-50个字符之间');
            }
            
            if (!preg_match('/^[a-zA-Z0-9_]+$/', $username)) {
                throw new InvalidArgumentException('用户名只能包含字母、数字和下划线');
            }
            
            $this->username = $username;
        }
        
        // Getter方法 - 获取用户名
        public function getUsername() {
            return $this->username;
        }
        
        // Setter方法 - 设置邮箱
        public function setEmail($email) {
            if (!filter_var($email, FILTER_VALIDATE_EMAIL)) {
                throw new InvalidArgumentException('邮箱格式不正确');
            }
            
            $this->email = $email;
        }
        
        // Getter方法 - 获取邮箱
        public function getEmail() {
            return $this->email;
        }
        
        // 安全的余额操作
        public function deposit($amount) {
            if ($amount <= 0) {
                throw new InvalidArgumentException('存款金额必须大于0');
            }
            
            if (!$this->isActive) {
                throw new Exception('账户已被禁用');
            }
            
            $this->balance += $amount;
            $this->logTransaction('存款', $amount);
        }
        
        public function withdraw($amount) {
            if ($amount <= 0) {
                throw new InvalidArgumentException('取款金额必须大于0');
            }
            
            if (!$this->isActive) {
                throw new Exception('账户已被禁用');
            }
            
            if ($this->balance < $amount) {
                throw new Exception('余额不足');
            }
            
            $this->balance -= $amount;
            $this->logTransaction('取款', $amount);
        }
        
        // 只读属性 - 只提供Getter
        public function getBalance() {
            return $this->balance;
        }
        
        public function isActive() {
            return $this->isActive;
        }
        
        // 管理员方法 - 激活/禁用账户
        public function setActive($active, $adminKey = null) {
            // 需要管理员权限
            if (!$this->verifyAdminKey($adminKey)) {
                throw new Exception('需要管理员权限');
            }
            
            $this->isActive = $active;
            $this->logTransaction($active ? '激活账户' : '禁用账户', 0);
        }
        
        private function verifyAdminKey($key) {
            // 简化的管理员验证
            return $key === 'admin_secret_key';
        }
        
        private function logTransaction($type, $amount) {
            $log = date('Y-m-d H:i:s') . " - 用户: {$this->username}, 操作: $type, 金额: $amount, 余额: {$this->balance}";
            error_log($log);
        }
    }
    
    // 使用示例
    try {
        $account = new UserAccount();
        $account->setUsername('alice_123');
        $account->setEmail('alice@example.com');
        
        $account->deposit(100.0);
        $account->withdraw(30.0);
        
        echo "用户: " . $account->getUsername() . "\n";
        echo "余额: " . $account->getBalance() . "\n";
        echo "状态: " . ($account->isActive() ? '活跃' : '禁用') . "\n";
        
    } catch (Exception $e) {
        echo "错误: " . $e->getMessage();
    }
?>
```

## 八、接口类

### 8.1 接口基础

接口定义了类必须实现的方法契约，使用 `interface` 关键字定义：

```php
<?php
    // 定义安全验证接口
    interface SecurityValidatorInterface {
        public function validate($input);
        public function getErrors();
        public function isValid();
    }
    
    // 定义加密接口
    interface EncryptionInterface {
        public function encrypt($data, $key);
        public function decrypt($data, $key);
        public function generateKey();
    }
    
    // 实现安全验证接口
    class InputValidator implements SecurityValidatorInterface {
        private $errors = [];
        
        public function validate($input) {
            $this->errors = [];
            
            // XSS检查
            if ($input !== htmlspecialchars($input, ENT_QUOTES, 'UTF-8')) {
                $this->errors[] = '输入包含潜在的XSS代码';
            }
            
            // SQL注入检查
            $suspiciousPatterns = ['/union\s+select/i', '/drop\s+table/i', '/exec\(/i'];
            foreach ($suspiciousPatterns as $pattern) {
                if (preg_match($pattern, $input)) {
                    $this->errors[] = '输入包含可疑的SQL代码';
                    break;
                }
            }
            
            return $this->isValid();
        }
        
        public function getErrors() {
            return $this->errors;
        }
        
        public function isValid() {
            return empty($this->errors);
        }
    }
    
    // 实现加密接口
    class AESEncryption implements EncryptionInterface {
        private $method = 'AES-256-CBC';
        
        public function encrypt($data, $key) {
            $iv = random_bytes(16);
            $encrypted = openssl_encrypt($data, $this->method, $key, 0, $iv);
            return base64_encode($iv . $encrypted);
        }
        
        public function decrypt($data, $key) {
            $data = base64_decode($data);
            $iv = substr($data, 0, 16);
            $encrypted = substr($data, 16);
            return openssl_decrypt($encrypted, $this->method, $key, 0, $iv);
        }
        
        public function generateKey() {
            return random_bytes(32); // 256位密钥
        }
    }
?>
```

### 8.2 多接口实现

一个类可以实现多个接口：

```php
<?php
    interface LoggerInterface {
        public function log($message, $level);
    }
    
    interface NotifierInterface {
        public function notify($recipient, $message);
    }
    
    // 安全事件处理器，同时实现日志和通知功能
    class SecurityEventHandler implements LoggerInterface, NotifierInterface {
        private $logFile;
        private $adminEmail;
        
        public function __construct($logFile, $adminEmail) {
            $this->logFile = $logFile;
            $this->adminEmail = $adminEmail;
        }
        
        // 实现LoggerInterface
        public function log($message, $level = 'INFO') {
            $timestamp = date('Y-m-d H:i:s');
            $logEntry = "[$timestamp] [$level] $message" . PHP_EOL;
            file_put_contents($this->logFile, $logEntry, FILE_APPEND | LOCK_EX);
        }
        
        // 实现NotifierInterface
        public function notify($recipient, $message) {
            // 简化的邮件发送
            mail($recipient, 'Security Alert', $message);
        }
        
        // 综合处理安全事件
        public function handleSecurityEvent($event, $severity = 'WARNING') {
            $message = "安全事件: $event";
            
            // 记录日志
            $this->log($message, $severity);
            
            // 高危事件通知管理员
            if (in_array($severity, ['ERROR', 'CRITICAL'])) {
                $this->notify($this->adminEmail, $message);
            }
        }
    }
    
    // 使用示例
    $securityHandler = new SecurityEventHandler('/var/log/security.log', 'admin@example.com');
    $securityHandler->handleSecurityEvent('检测到SQL注入尝试', 'CRITICAL');
?>
```

## 九、常量

### 9.1 类常量

使用 `const` 关键字在类中定义常量：

```php
<?php
    class SecurityConfig {
        // 公共常量
        public const VERSION = '2.1.0';
        public const MIN_PASSWORD_LENGTH = 8;
        
        // 私有常量（PHP 7.1+）
        private const SECRET_SALT = 'your-secret-salt';
        private const ENCRYPTION_KEY_LENGTH = 32;
        
        // 受保护常量（PHP 7.1+）
        protected const DEFAULT_HASH_ALGORITHM = 'sha256';
        
        public static function getPasswordRequirements() {
            return [
                'min_length' => self::MIN_PASSWORD_LENGTH,
                'require_uppercase' => true,
                'require_lowercase' => true,
                'require_numbers' => true,
                'require_special_chars' => true
            ];
        }
        
        public static function hashPassword($password) {
            // 使用私有常量
            return hash(self::DEFAULT_HASH_ALGORITHM, $password . self::SECRET_SALT);
        }
        
        public static function generateEncryptionKey() {
            return random_bytes(self::ENCRYPTION_KEY_LENGTH);
        }
    }
    
    // 安全角色常量
    class UserRole {
        public const GUEST = 'guest';
        public const USER = 'user';
        public const MODERATOR = 'moderator';
        public const ADMIN = 'admin';
        public const SUPER_ADMIN = 'super_admin';
        
        // 权限级别映射
        private const PERMISSION_LEVELS = [
            self::GUEST => 1,
            self::USER => 10,
            self::MODERATOR => 50,
            self::ADMIN => 90,
            self::SUPER_ADMIN => 100
        ];
        
        public static function getPermissionLevel($role) {
            return self::PERMISSION_LEVELS[$role] ?? 0;
        }
        
        public static function hasPermission($userRole, $requiredRole) {
            return self::getPermissionLevel($userRole) >= self::getPermissionLevel($requiredRole);
        }
        
        public static function getAllRoles() {
            return [self::GUEST, self::USER, self::MODERATOR, self::ADMIN, self::SUPER_ADMIN];
        }
    }
    
    // 使用示例
    echo "系统版本: " . SecurityConfig::VERSION . "\n";
    echo "最小密码长度: " . SecurityConfig::MIN_PASSWORD_LENGTH . "\n";
    
    // 权限检查
    $currentUserRole = UserRole::USER;
    $requiredRole = UserRole::ADMIN;
    
    if (UserRole::hasPermission($currentUserRole, $requiredRole)) {
        echo "用户有足够权限\n";
    } else {
        echo "用户权限不足\n";
    }
?>
```

### 9.2 安全配置常量类

```php
<?php
    class SecurityConstants {
        // HTTP状态码
        public const HTTP_OK = 200;
        public const HTTP_UNAUTHORIZED = 401;
        public const HTTP_FORBIDDEN = 403;
        public const HTTP_TOO_MANY_REQUESTS = 429;
        
        // 安全事件类型
        public const EVENT_LOGIN_SUCCESS = 'login_success';
        public const EVENT_LOGIN_FAILED = 'login_failed';
        public const EVENT_PASSWORD_CHANGED = 'password_changed';
        public const EVENT_ACCOUNT_LOCKED = 'account_locked';
        public const EVENT_SUSPICIOUS_ACTIVITY = 'suspicious_activity';
        
        // 加密算法
        public const ENCRYPT_AES256 = 'AES-256-CBC';
        public const ENCRYPT_AES128 = 'AES-128-CBC';
        public const HASH_SHA256 = 'sha256';
        public const HASH_SHA512 = 'sha512';
        
        // 安全限制
        public const MAX_LOGIN_ATTEMPTS = 5;
        public const LOCKOUT_DURATION = 900; // 15分钟
        public const SESSION_TIMEOUT = 3600; // 1小时
        public const TOKEN_EXPIRY = 1800; // 30分钟
        
        // 验证正则表达式
        public const REGEX_USERNAME = '/^[a-zA-Z0-9_]{3,20}$/';
        public const REGEX_PASSWORD_STRONG = '/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/';
        public const REGEX_EMAIL = '/^[^\s@]+@[^\s@]+\.[^\s@]+$/';
        
        // 不允许修改常量的方法
        private function __construct() {}
        private function __clone() {}
        public function __wakeup() {
            throw new Exception('不允许反序列化安全常量类');
        }
    }
    
    // 使用安全常量
    class AuthenticationService {
        private $attempts = [];
        
        public function authenticate($username, $password) {
            // 检查账户锁定
            if ($this->isAccountLocked($username)) {
                http_response_code(SecurityConstants::HTTP_TOO_MANY_REQUESTS);
                throw new Exception('账户已被锁定');
            }
            
            // 验证凭据
            if ($this->validateCredentials($username, $password)) {
                $this->logSecurityEvent(SecurityConstants::EVENT_LOGIN_SUCCESS, $username);
                $this->clearFailedAttempts($username);
                return true;
            } else {
                $this->recordFailedAttempt($username);
                $this->logSecurityEvent(SecurityConstants::EVENT_LOGIN_FAILED, $username);
                http_response_code(SecurityConstants::HTTP_UNAUTHORIZED);
                return false;
            }
        }
        
        private function isAccountLocked($username) {
            if (!isset($this->attempts[$username])) {
                return false;
            }
            
            $attempts = $this->attempts[$username];
            if ($attempts['count'] >= SecurityConstants::MAX_LOGIN_ATTEMPTS) {
                return (time() - $attempts['last_attempt']) < SecurityConstants::LOCKOUT_DURATION;
            }
            
            return false;
        }
        
        private function recordFailedAttempt($username) {
            if (!isset($this->attempts[$username])) {
                $this->attempts[$username] = ['count' => 0, 'last_attempt' => 0];
            }
            
            $this->attempts[$username]['count']++;
            $this->attempts[$username]['last_attempt'] = time();
            
            if ($this->attempts[$username]['count'] >= SecurityConstants::MAX_LOGIN_ATTEMPTS) {
                $this->logSecurityEvent(SecurityConstants::EVENT_ACCOUNT_LOCKED, $username);
            }
        }
        
        private function validateCredentials($username, $password) {
            // 简化的验证逻辑
            return $username === 'admin' && $password === 'admin123';
        }
        
        private function clearFailedAttempts($username) {
            unset($this->attempts[$username]);
        }
        
        private function logSecurityEvent($eventType, $username) {
            error_log("[$eventType] User: $username, Time: " . date('Y-m-d H:i:s'));
        }
    }
?>
```

## 十、抽象类

### 10.1 抽象类基础

抽象类不能被实例化，用于定义子类必须实现的方法结构：

```php
<?php
    // 抽象安全处理器基类
    abstract class SecurityHandler {
        protected $config;
        protected $logger;
        
        public function __construct($config = []) {
            $this->config = $config;
            $this->logger = new Logger();
        }
        
        // 抽象方法 - 子类必须实现
        abstract public function process($input);
        abstract protected function validate($input);
        abstract protected function sanitize($input);
        
        // 具体方法 - 子类可直接使用
        public function handle($input) {
            $this->logger->log("开始处理输入", 'INFO');
            
            try {
                // 验证输入
                if (!$this->validate($input)) {
                    throw new Exception('输入验证失败');
                }
                
                // 清理输入
                $sanitized = $this->sanitize($input);
                
                // 处理输入
                $result = $this->process($sanitized);
                
                $this->logger->log("输入处理成功", 'INFO');
                return $result;
                
            } catch (Exception $e) {
                $this->logger->log("输入处理失败: " . $e->getMessage(), 'ERROR');
                throw $e;
            }
        }
        
        protected function logSecurityEvent($message, $level = 'WARNING') {
            $this->logger->log("[SECURITY] $message", $level);
        }
    }
    
    // 用户输入处理器
    class UserInputHandler extends SecurityHandler {
        public function process($input) {
            // 具体的用户输入处理逻辑
            return [
                'processed_input' => $input,
                'timestamp' => time(),
                'safe' => true
            ];
        }
        
        protected function validate($input) {
            // 检查输入长度
            if (strlen($input) > 1000) {
                $this->logSecurityEvent('输入长度超过限制');
                return false;
            }
            
            // 检查危险字符
            $dangerousPatterns = ['<script', 'javascript:', 'onload=', 'onerror='];
            foreach ($dangerousPatterns as $pattern) {
                if (stripos($input, $pattern) !== false) {
                    $this->logSecurityEvent("检测到危险模式: $pattern");
                    return false;
                }
            }
            
            return true;
        }
        
        protected function sanitize($input) {
            // HTML实体编码
            $input = htmlspecialchars($input, ENT_QUOTES, 'UTF-8');
            
            // 移除控制字符
            $input = preg_replace('/[\x00-\x1F\x7F]/', '', $input);
            
            // 去除首尾空格
            $input = trim($input);
            
            return $input;
        }
    }
    
    // 文件上传处理器
    class FileUploadHandler extends SecurityHandler {
        private $allowedTypes = ['jpg', 'png', 'gif', 'pdf'];
        private $maxSize = 5242880; // 5MB
        
        public function process($file) {
            $uploadDir = './uploads/';
            $filename = uniqid() . '.' . pathinfo($file['name'], PATHINFO_EXTENSION);
            $filepath = $uploadDir . $filename;
            
            if (move_uploaded_file($file['tmp_name'], $filepath)) {
                return [
                    'filename' => $filename,
                    'filepath' => $filepath,
                    'size' => $file['size'],
                    'uploaded' => true
                ];
            } else {
                throw new Exception('文件保存失败');
            }
        }
        
        protected function validate($file) {
            // 检查上传错误
            if ($file['error'] !== UPLOAD_ERR_OK) {
                $this->logSecurityEvent('文件上传错误: ' . $file['error']);
                return false;
            }
            
            // 检查文件大小
            if ($file['size'] > $this->maxSize) {
                $this->logSecurityEvent('文件大小超过限制: ' . $file['size']);
                return false;
            }
            
            // 检查文件类型
            $extension = strtolower(pathinfo($file['name'], PATHINFO_EXTENSION));
            if (!in_array($extension, $this->allowedTypes)) {
                $this->logSecurityEvent('不允许的文件类型: ' . $extension);
                return false;
            }
            
            return true;
        }
        
        protected function sanitize($file) {
            // 清理文件名
            $file['name'] = preg_replace('/[^a-zA-Z0-9._-]/', '_', $file['name']);
            return $file;
        }
    }
    
    // 简单的日志类
    class Logger {
        public function log($message, $level = 'INFO') {
            echo "[" . date('Y-m-d H:i:s') . "] [$level] $message\n";
        }
    }
?>
```

## 十一、Final关键字

### 11.1 Final类和方法

`final` 关键字防止类被继承或方法被重写：

```php
<?php
    // Final类 - 不能被继承
    final class CryptographicService {
        private $key;
        
        public function __construct($key) {
            if (strlen($key) < 32) {
                throw new InvalidArgumentException('密钥长度至少32字节');
            }
            $this->key = $key;
        }
        
        public function encrypt($data) {
            $iv = random_bytes(16);
            $encrypted = openssl_encrypt($data, 'AES-256-CBC', $this->key, 0, $iv);
            return base64_encode($iv . $encrypted);
        }
        
        public function decrypt($encryptedData) {
            $data = base64_decode($encryptedData);
            $iv = substr($data, 0, 16);
            $encrypted = substr($data, 16);
            return openssl_decrypt($encrypted, 'AES-256-CBC', $this->key, 0, $iv);
        }
    }
    
    // 尝试继承final类会导致错误
    // class ExtendedCrypto extends CryptographicService {} // 错误！
    
    // 包含final方法的类
    class SecurityAuditor {
        protected $auditLog = [];
        
        // Final方法 - 不能被重写
        final public function recordAuditEvent($action, $userId, $details = []) {
            $event = [
                'timestamp' => time(),
                'action' => $action,
                'user_id' => $userId,
                'details' => $details,
                'ip_address' => $_SERVER['REMOTE_ADDR'] ?? 'unknown',
                'user_agent' => $_SERVER['HTTP_USER_AGENT'] ?? 'unknown'
            ];
            
            $this->auditLog[] = $event;
            $this->persistAuditEvent($event);
        }
        
        // 可以被重写的方法
        protected function persistAuditEvent($event) {
            // 默认实现：写入文件
            $logEntry = json_encode($event) . "\n";
            file_put_contents('./audit.log', $logEntry, FILE_APPEND | LOCK_EX);
        }
        
        public function getAuditLog() {
            return $this->auditLog;
        }
    }
    
    // 子类可以重写非final方法
    class DatabaseSecurityAuditor extends SecurityAuditor {
        private $db;
        
        public function __construct($database) {
            $this->db = $database;
        }
        
        // 重写持久化方法，但不能重写recordAuditEvent
        protected function persistAuditEvent($event) {
            // 写入数据库而不是文件
            $stmt = $this->db->prepare("
                INSERT INTO audit_log (timestamp, action, user_id, details, ip_address, user_agent) 
                VALUES (?, ?, ?, ?, ?, ?)
            ");
            
            $stmt->execute([
                $event['timestamp'],
                $event['action'],
                $event['user_id'],
                json_encode($event['details']),
                $event['ip_address'],
                $event['user_agent']
            ]);
        }
        
        // 尝试重写final方法会导致错误
        // public function recordAuditEvent($action, $userId, $details = []) {} // 错误！
    }
?>
```

### 11.2 Final的安全用途

```php
<?php
    // 安全的配置管理类
    final class SecurityConfig {
        private static $instance = null;
        private $config = [];
        private $sealed = false;
        
        // 私有构造函数实现单例
        private function __construct() {}
        
        public static function getInstance() {
            if (self::$instance === null) {
                self::$instance = new self();
            }
            return self::$instance;
        }
        
        // Final方法确保配置加载逻辑不被篡改
        final public function loadConfig($configFile) {
            if ($this->sealed) {
                throw new Exception('配置已密封，无法修改');
            }
            
            if (!file_exists($configFile) || !is_readable($configFile)) {
                throw new Exception('配置文件不存在或不可读');
            }
            
            $config = include $configFile;
            if (!is_array($config)) {
                throw new Exception('配置文件格式错误');
            }
            
            $this->config = array_merge($this->config, $config);
        }
        
        // Final方法确保获取配置的安全性
        final public function get($key, $default = null) {
            $keys = explode('.', $key);
            $value = $this->config;
            
            foreach ($keys as $k) {
                if (!is_array($value) || !array_key_exists($k, $value)) {
                    return $default;
                }
                $value = $value[$k];
            }
            
            return $value;
        }
        
        // Final方法防止配置被意外修改
        final public function seal() {
            $this->sealed = true;
        }
        
        // 防止克隆
        private function __clone() {}
        
        // 防止反序列化
        public function __wakeup() {
            throw new Exception('不允许反序列化配置对象');
        }
    }
    
    // 安全的令牌生成器
    final class TokenGenerator {
        private $algorithm = 'sha256';
        private $secretKey;
        
        public function __construct($secretKey) {
            if (strlen($secretKey) < 32) {
                throw new InvalidArgumentException('密钥长度不足');
            }
            $this->secretKey = $secretKey;
        }
        
        // Final方法确保令牌生成算法不被篡改
        final public function generateToken($data, $expiry = 3600) {
            $payload = [
                'data' => $data,
                'exp' => time() + $expiry,
                'iat' => time(),
                'nonce' => bin2hex(random_bytes(16))
            ];
            
            $payloadJson = json_encode($payload);
            $payloadBase64 = base64_encode($payloadJson);
            $signature = $this->sign($payloadBase64);
            
            return $payloadBase64 . '.' . $signature;
        }
        
        // Final方法确保令牌验证逻辑不被篡改
        final public function validateToken($token) {
            $parts = explode('.', $token);
            if (count($parts) !== 2) {
                return false;
            }
            
            [$payloadBase64, $signature] = $parts;
            
            // 验证签名
            if (!hash_equals($this->sign($payloadBase64), $signature)) {
                return false;
            }
            
            // 解码载荷
            $payload = json_decode(base64_decode($payloadBase64), true);
            if (!$payload) {
                return false;
            }
            
            // 检查过期时间
            if ($payload['exp'] < time()) {
                return false;
            }
            
            return $payload['data'];
        }
        
        private function sign($data) {
            return hash_hmac($this->algorithm, $data, $this->secretKey);
        }
    }
?>
```

## 十二、Parent调用父类构造

### 12.1 Parent关键字使用

`parent` 关键字用于访问父类的方法，特别是在构造函数中：

```php
<?php
    // 基础数据库类
    class Database {
        protected $connection;
        protected $host;
        protected $database;
        protected $charset;
        
        public function __construct($host, $database, $username, $password, $charset = 'utf8mb4') {
            $this->host = $host;
            $this->database = $database;
            $this->charset = $charset;
            
            $this->connect($username, $password);
            $this->configureConnection();
        }
        
        protected function connect($username, $password) {
            try {
                $dsn = "mysql:host={$this->host};dbname={$this->database};charset={$this->charset}";
                $this->connection = new PDO($dsn, $username, $password);
                echo "数据库连接建立\n";
            } catch (PDOException $e) {
                throw new Exception('数据库连接失败: ' . $e->getMessage());
            }
        }
        
        protected function configureConnection() {
            $this->connection->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
            $this->connection->setAttribute(PDO::ATTR_DEFAULT_FETCH_MODE, PDO::FETCH_ASSOC);
            $this->connection->setAttribute(PDO::ATTR_EMULATE_PREPARES, false);
        }
        
        public function query($sql, $params = []) {
            $stmt = $this->connection->prepare($sql);
            $stmt->execute($params);
            return $stmt;
        }
    }
    
    // 安全数据库类
    class SecureDatabase extends Database {
        private $auditLog = [];
        private $maxQueryTime = 30; // 最大查询时间（秒）
        private $allowedOperations = ['SELECT', 'INSERT', 'UPDATE', 'DELETE'];
        
        public function __construct($host, $database, $username, $password, $charset = 'utf8mb4', $auditEnabled = true) {
            // 调用父类构造函数
            parent::__construct($host, $database, $username, $password, $charset);
            
            // 子类特有的初始化
            if ($auditEnabled) {
                $this->enableAuditLogging();
            }
            
            $this->configureSecuritySettings();
            echo "安全数据库类初始化完成\n";
        }
        
        // 重写父类方法，增加安全检查
        public function query($sql, $params = []) {
            // 安全检查
            $this->validateQuery($sql);
            
            // 记录查询开始时间
            $startTime = microtime(true);
            
            try {
                // 调用父类方法
                $result = parent::query($sql, $params);
                
                // 审计日志
                $this->logQuery($sql, $params, microtime(true) - $startTime, true);
                
                return $result;
            } catch (Exception $e) {
                // 记录失败的查询
                $this->logQuery($sql, $params, microtime(true) - $startTime, false, $e->getMessage());
                throw $e;
            }
        }
        
        private function enableAuditLogging() {
            echo "审计日志已启用\n";
        }
        
        private function configureSecuritySettings() {
            // 设置查询超时
            $this->connection->setAttribute(PDO::ATTR_TIMEOUT, $this->maxQueryTime);
            
            // 禁用多语句执行（防止SQL注入）
            $this->connection->setAttribute(PDO::MYSQL_ATTR_MULTI_STATEMENTS, false);
            
            echo "安全设置配置完成\n";
        }
        
        private function validateQuery($sql) {
            // 提取SQL操作类型
            $operation = strtoupper(trim(explode(' ', $sql)[0]));
            
            if (!in_array($operation, $this->allowedOperations)) {
                throw new Exception("不允许的SQL操作: $operation");
            }
            
            // 检查危险的SQL模式
            $dangerousPatterns = [
                '/;\s*(drop|alter|create|truncate)\s/i',
                '/union\s+select/i',
                '/\/\*.*\*\//i', // SQL注释
                '/--[^\r\n]*/i'   // 行注释
            ];
            
            foreach ($dangerousPatterns as $pattern) {
                if (preg_match($pattern, $sql)) {
                    throw new Exception('检测到潜在的恶意SQL代码');
                }
            }
        }
        
        private function logQuery($sql, $params, $duration, $success, $error = null) {
            $logEntry = [
                'timestamp' => time(),
                'sql' => $sql,
                'params' => $params,
                'duration' => $duration,
                'success' => $success,
                'error' => $error
            ];
            
            $this->auditLog[] = $logEntry;
            
            // 记录慢查询
            if ($duration > 1.0) {
                error_log("慢查询警告: SQL执行时间 {$duration}s - $sql");
            }
        }
        
        public function getAuditLog() {
            return $this->auditLog;
        }
    }
    
    // 使用示例
    try {
        $secureDb = new SecureDatabase('localhost', 'test_db', 'user', 'password');
        
        // 执行安全查询
        $result = $secureDb->query('SELECT * FROM users WHERE id = ?', [1]);
        
        // 尝试执行危险查询（会被阻止）
        // $secureDb->query('DROP TABLE users'); // 抛出异常
        
    } catch (Exception $e) {
        echo "错误: " . $e->getMessage() . "\n";
    }
?>
```

### 12.2 复杂继承链中的Parent调用

```php
<?php
    // 基础认证类
    class BaseAuthenticator {
        protected $config;
        protected $logger;
        
        public function __construct($config = []) {
            $this->config = array_merge($this->getDefaultConfig(), $config);
            $this->logger = new SimpleLogger();
            $this->logger->log('BaseAuthenticator 初始化');
        }
        
        protected function getDefaultConfig() {
            return [
                'max_attempts' => 3,
                'lockout_time' => 300,
                'session_timeout' => 3600
            ];
        }
        
        public function authenticate($credentials) {
            $this->logger->log('开始认证流程');
            return $this->doAuthenticate($credentials);
        }
        
        protected function doAuthenticate($credentials) {
            // 基础认证逻辑
            return false;
        }
    }
    
    // 数据库认证类
    class DatabaseAuthenticator extends BaseAuthenticator {
        protected $database;
        
        public function __construct($database, $config = []) {
            // 设置数据库
            $this->database = $database;
            
            // 调用父类构造函数
            parent::__construct($config);
            
            $this->logger->log('DatabaseAuthenticator 初始化');
        }
        
        protected function doAuthenticate($credentials) {
            $this->logger->log('使用数据库进行认证');
            
            // 调用父类方法进行基础检查
            $baseResult = parent::doAuthenticate($credentials);
            
            // 数据库认证逻辑
            $stmt = $this->database->prepare('SELECT * FROM users WHERE username = ?');
            $stmt->execute([$credentials['username']]);
            $user = $stmt->fetch();
            
            if ($user && password_verify($credentials['password'], $user['password'])) {
                return $user;
            }
            
            return false;
        }
    }
    
    // 多因子认证类
    class TwoFactorAuthenticator extends DatabaseAuthenticator {
        private $totpService;
        
        public function __construct($database, $totpService, $config = []) {
            $this->totpService = $totpService;
            
            // 调用父类构造函数
            parent::__construct($database, $config);
            
            $this->logger->log('TwoFactorAuthenticator 初始化');
        }
        
        protected function doAuthenticate($credentials) {
            $this->logger->log('开始双因子认证');
            
            // 首先进行标准数据库认证
            $user = parent::doAuthenticate($credentials);
            
            if (!$user) {
                return false;
            }
            
            // 验证TOTP令牌
            if (!isset($credentials['totp_code'])) {
                throw new Exception('需要提供TOTP验证码');
            }
            
            if (!$this->totpService->verifyCode($user['totp_secret'], $credentials['totp_code'])) {
                $this->logger->log('TOTP验证失败');
                return false;
            }
            
            $this->logger->log('双因子认证成功');
            return $user;
        }
        
        // 重写配置以增加2FA特定设置
        protected function getDefaultConfig() {
            $baseConfig = parent::getDefaultConfig();
            return array_merge($baseConfig, [
                'totp_window' => 30,
                'backup_codes_count' => 10
            ]);
        }
    }
    
    // 简单日志类
    class SimpleLogger {
        public function log($message) {
            echo "[" . date('H:i:s') . "] $message\n";
        }
    }
    
    // 简单TOTP服务
    class TotpService {
        public function verifyCode($secret, $code) {
            // 简化的验证逻辑
            return $code === '123456';
        }
    }
    
    // 使用示例
    try {
        // 模拟数据库连接
        $db = new PDO('sqlite::memory:');
        $totp = new TotpService();
        
        $auth = new TwoFactorAuthenticator($db, $totp, ['max_attempts' => 5]);
        
        $credentials = [
            'username' => 'admin',
            'password' => 'password123',
            'totp_code' => '123456'
        ];
        
        $result = $auth->authenticate($credentials);
        
    } catch (Exception $e) {
        echo "认证错误: " . $e->getMessage() . "\n";
    }
?>
```

## 十三、超级全局变量

### 13.1 超级全局变量概述

PHP提供了几个内置的超级全局变量，这些变量在所有作用域中都可直接访问。在面向对象编程中，正确处理这些变量对安全至关重要：

| 超级全局变量 | 说明 | 安全风险 | 安全处理建议 |
|--------------|------|----------|--------------|
| `$_GET` | HTTP GET参数 | URL参数污染、XSS | 严格验证和过滤 |
| `$_POST` | HTTP POST数据 | 表单数据注入、CSRF | 使用CSRF令牌，验证数据 |
| `$_SESSION` | 会话数据 | 会话劫持、固定 | 定期重新生成会话ID |
| `$_COOKIE` | Cookie数据 | Cookie注入、伪造 | 签名验证，HttpOnly标志 |
| `$_SERVER` | 服务器信息 | 信息泄露、头部伪造 | 验证和清理服务器变量 |
| `$_FILES` | 文件上传信息 | 恶意文件上传 | 严格的文件类型和大小检查 |
| `$_ENV` | 环境变量 | 配置信息泄露 | 限制访问敏感环境变量 |
| `$GLOBALS` | 全局变量引用 | 变量覆盖攻击 | 避免使用，使用类封装 |

### 13.2 安全的超级全局变量处理类

```php
<?php
    // 安全的请求数据处理类
    class SecureRequest {
        private static $instance = null;
        private $trustedProxies = [];
        private $csrfToken = null;
        
        private function __construct() {
            $this->initializeCSRFToken();
        }
        
        public static function getInstance() {
            if (self::$instance === null) {
                self::$instance = new self();
            }
            return self::$instance;
        }
        
        // 安全获取GET参数
        public function get($key, $default = null, $filter = 'string') {
            if (!isset($_GET[$key])) {
                return $default;
            }
            
            return $this->filterInput($_GET[$key], $filter);
        }
        
        // 安全获取POST参数
        public function post($key, $default = null, $filter = 'string') {
            if (!isset($_POST[$key])) {
                return $default;
            }
            
            return $this->filterInput($_POST[$key], $filter);
        }
        
        // 验证CSRF令牌
        public function validateCSRFToken($token) {
            return hash_equals($this->csrfToken, $token);
        }
        
        public function getCSRFToken() {
            return $this->csrfToken;
        }
        
        // 获取客户端真实IP
        public function getClientIP() {
            $ipHeaders = [
                'HTTP_CF_CONNECTING_IP',     // Cloudflare
                'HTTP_CLIENT_IP',            // 代理服务器
                'HTTP_X_FORWARDED_FOR',      // 负载均衡器
                'HTTP_X_FORWARDED',          // 代理服务器
                'HTTP_X_CLUSTER_CLIENT_IP',  // 集群
                'HTTP_FORWARDED_FOR',        // 代理服务器
                'HTTP_FORWARDED',            // 代理服务器
                'REMOTE_ADDR'                // 标准
            ];
            
            foreach ($ipHeaders as $header) {
                if (!empty($_SERVER[$header])) {
                    $ips = explode(',', $_SERVER[$header]);
                    $ip = trim($ips[0]);
                    
                    if ($this->isValidIP($ip)) {
                        return $ip;
                    }
                }
            }
            
            return 'unknown';
        }
        
        // 获取用户代理信息
        public function getUserAgent() {
            $userAgent = $_SERVER['HTTP_USER_AGENT'] ?? '';
            return htmlspecialchars($userAgent, ENT_QUOTES, 'UTF-8');
        }
        
        // 检查是否为HTTPS请求
        public function isHTTPS() {
            return !empty($_SERVER['HTTPS']) && $_SERVER['HTTPS'] !== 'off';
        }
        
        // 获取请求方法
        public function getMethod() {
            return strtoupper($_SERVER['REQUEST_METHOD'] ?? 'GET');
        }
        
        // 输入过滤方法
        private function filterInput($value, $filter) {
            switch ($filter) {
                case 'int':
                    return filter_var($value, FILTER_VALIDATE_INT);
                case 'float':
                    return filter_var($value, FILTER_VALIDATE_FLOAT);
                case 'email':
                    return filter_var($value, FILTER_VALIDATE_EMAIL);
                case 'url':
                    return filter_var($value, FILTER_VALIDATE_URL);
                case 'boolean':
                    return filter_var($value, FILTER_VALIDATE_BOOLEAN);
                case 'raw':
                    return $value; // 原始值，谨慎使用
                case 'string':
                default:
                    if (is_array($value)) {
                        return array_map(function($item) {
                            return htmlspecialchars(trim($item), ENT_QUOTES, 'UTF-8');
                        }, $value);
                    }
                    return htmlspecialchars(trim($value), ENT_QUOTES, 'UTF-8');
            }
        }
        
        private function initializeCSRFToken() {
            if (session_status() !== PHP_SESSION_ACTIVE) {
                session_start();
            }
            
            if (!isset($_SESSION['csrf_token'])) {
                $_SESSION['csrf_token'] = bin2hex(random_bytes(32));
            }
            
            $this->csrfToken = $_SESSION['csrf_token'];
        }
        
        private function isValidIP($ip) {
            return filter_var($ip, FILTER_VALIDATE_IP, 
                FILTER_FLAG_NO_PRIV_RANGE | FILTER_FLAG_NO_RES_RANGE) !== false;
        }
    }
    
    // 安全的会话管理类
    class SecureSession {
        private $sessionTimeout = 3600; // 1小时
        private $regenerateInterval = 300; // 5分钟
        
        public function __construct($config = []) {
            $this->sessionTimeout = $config['timeout'] ?? $this->sessionTimeout;
            $this->regenerateInterval = $config['regenerate_interval'] ?? $this->regenerateInterval;
            
            $this->configureSession();
            $this->startSession();
        }
        
        public function set($key, $value) {
            $_SESSION[$key] = $value;
        }
        
        public function get($key, $default = null) {
            return $_SESSION[$key] ?? $default;
        }
        
        public function has($key) {
            return isset($_SESSION[$key]);
        }
        
        public function remove($key) {
            unset($_SESSION[$key]);
        }
        
        public function destroy() {
            $_SESSION = [];
            
            // 删除会话cookie
            if (ini_get("session.use_cookies")) {
                $params = session_get_cookie_params();
                setcookie(session_name(), '', time() - 42000,
                    $params["path"], $params["domain"],
                    $params["secure"], $params["httponly"]
                );
            }
            
            session_destroy();
        }
        
        public function regenerateId() {
            session_regenerate_id(true);
            $this->set('last_regeneration', time());
        }
        
        private function configureSession() {
            // 安全的会话配置
            ini_set('session.use_strict_mode', 1);
            ini_set('session.use_only_cookies', 1);
            ini_set('session.cookie_httponly', 1);
            ini_set('session.cookie_secure', 1); // 仅HTTPS
            ini_set('session.cookie_samesite', 'Strict');
            ini_set('session.gc_maxlifetime', $this->sessionTimeout);
        }
        
        private function startSession() {
            if (session_status() === PHP_SESSION_NONE) {
                session_start();
            }
            
            $this->validateSession();
        }
        
        private function validateSession() {
            $now = time();
            
            // 检查会话超时
            $lastActivity = $this->get('last_activity', $now);
            if ($now - $lastActivity > $this->sessionTimeout) {
                $this->destroy();
                return;
            }
            
            // 更新最后活动时间
            $this->set('last_activity', $now);
            
            // 定期重新生成会话ID
            $lastRegeneration = $this->get('last_regeneration', 0);
            if ($now - $lastRegeneration > $this->regenerateInterval) {
                $this->regenerateId();
            }
        }
    }
    
    // 安全的Cookie管理类
    class SecureCookie {
        private $domain;
        private $secure = true;
        private $httpOnly = true;
        private $sameSite = 'Strict';
        private $encryptionKey;
        
        public function __construct($encryptionKey, $config = []) {
            $this->encryptionKey = $encryptionKey;
            $this->domain = $config['domain'] ?? '';
            $this->secure = $config['secure'] ?? true;
            $this->httpOnly = $config['httponly'] ?? true;
            $this->sameSite = $config['samesite'] ?? 'Strict';
        }
        
        public function set($name, $value, $expire = 0, $path = '/') {
            // 加密cookie值
            $encryptedValue = $this->encrypt(json_encode($value));
            
            // 设置安全cookie
            setcookie($name, $encryptedValue, [
                'expires' => $expire,
                'path' => $path,
                'domain' => $this->domain,
                'secure' => $this->secure,
                'httponly' => $this->httpOnly,
                'samesite' => $this->sameSite
            ]);
        }
        
        public function get($name, $default = null) {
            if (!isset($_COOKIE[$name])) {
                return $default;
            }
            
            try {
                $decrypted = $this->decrypt($_COOKIE[$name]);
                return json_decode($decrypted, true);
            } catch (Exception $e) {
                // Cookie被篡改或解密失败
                $this->delete($name);
                return $default;
            }
        }
        
        public function delete($name, $path = '/') {
            setcookie($name, '', [
                'expires' => time() - 3600,
                'path' => $path,
                'domain' => $this->domain,
                'secure' => $this->secure,
                'httponly' => $this->httpOnly,
                'samesite' => $this->sameSite
            ]);
            unset($_COOKIE[$name]);
        }
        
        private function encrypt($data) {
            $iv = random_bytes(16);
            $encrypted = openssl_encrypt($data, 'AES-256-CBC', $this->encryptionKey, 0, $iv);
            return base64_encode($iv . $encrypted);
        }
        
        private function decrypt($data) {
            $data = base64_decode($data);
            $iv = substr($data, 0, 16);
            $encrypted = substr($data, 16);
            return openssl_decrypt($encrypted, 'AES-256-CBC', $this->encryptionKey, 0, $iv);
        }
    }
?>
```

## 十四、Include文件处理

### 14.1 文件包含基础

PHP提供了多种文件包含方式，每种都有其特定用途和安全考虑：

| 包含方式 | 行为 | 文件不存在时 | 安全风险 | 建议使用场景 |
|----------|------|--------------|----------|--------------|
| `include` | 包含文件，继续执行 | 警告，继续执行 | 中 | 可选的配置文件 |
| `require` | 包含文件，必须成功 | 致命错误，停止执行 | 中 | 必需的配置和类文件 |
| `include_once` | 只包含一次 | 警告，继续执行 | 中 | 防止重复包含的配置 |
| `require_once` | 必须包含且只包含一次 | 致命错误，停止执行 | 中 | 类定义和重要配置 |

### 14.2 安全的文件包含类

```php
<?php
    // 安全文件加载器类
    class SecureFileLoader {
        private $allowedPaths = [];
        private $allowedExtensions = ['.php', '.inc'];
        private $cache = [];
        private $basePath;
        
        public function __construct($basePath, $allowedPaths = []) {
            $this->basePath = realpath($basePath);
            if (!$this->basePath) {
                throw new InvalidArgumentException('基础路径无效');
            }
            
            // 设置允许的路径
            foreach ($allowedPaths as $path) {
                $realPath = realpath($this->basePath . '/' . $path);
                if ($realPath && strpos($realPath, $this->basePath) === 0) {
                    $this->allowedPaths[] = $realPath;
                }
            }
            
            // 如果没有指定允许路径，默认允许基础路径
            if (empty($this->allowedPaths)) {
                $this->allowedPaths[] = $this->basePath;
            }
        }
        
        // 安全包含文件
        public function includeFile($filename, $once = true) {
            $safePath = $this->validateAndResolvePath($filename);
            
            if ($once && isset($this->cache[$safePath])) {
                return $this->cache[$safePath];
            }
            
            // 检查文件是否可读
            if (!is_readable($safePath)) {
                throw new Exception("文件不可读: $filename");
            }
            
            // 包含文件
            ob_start();
            $result = include $safePath;
            $output = ob_get_clean();
            
            // 缓存结果
            if ($once) {
                $this->cache[$safePath] = $result;
            }
            
            return $result;
        }
        
        // 安全require文件
        public function requireFile($filename, $once = true) {
            $safePath = $this->validateAndResolvePath($filename);
            
            if ($once && isset($this->cache[$safePath])) {
                return $this->cache[$safePath];
            }
            
            if (!is_readable($safePath)) {
                throw new Exception("必需文件不存在: $filename");
            }
            
            ob_start();
            $result = require $safePath;
            $output = ob_get_clean();
            
            if ($once) {
                $this->cache[$safePath] = $result;
            }
            
            return $result;
        }
        
        // 安全加载配置文件
        public function loadConfig($filename) {
            $config = $this->requireFile($filename, true);
            
            if (!is_array($config)) {
                throw new Exception("配置文件格式错误: $filename");
            }
            
            return $config;
        }
        
        // 安全加载类文件
        public function loadClass($className, $directory = 'classes') {
            $filename = $directory . '/' . $className . '.php';
            
            try {
                $this->requireFile($filename, true);
                
                if (!class_exists($className)) {
                    throw new Exception("类未找到: $className");
                }
                
                return true;
            } catch (Exception $e) {
                throw new Exception("无法加载类 $className: " . $e->getMessage());
            }
        }
        
        private function validateAndResolvePath($filename) {
            // 检查文件扩展名
            $extension = '.' . pathinfo($filename, PATHINFO_EXTENSION);
            if (!in_array($extension, $this->allowedExtensions)) {
                throw new Exception("不允许的文件扩展名: $extension");
            }
            
            // 解析真实路径
            $fullPath = $this->basePath . '/' . $filename;
            $realPath = realpath($fullPath);
            
            if (!$realPath) {
                throw new Exception("文件不存在: $filename");
            }
            
            // 检查路径是否在允许范围内
            $pathAllowed = false;
            foreach ($this->allowedPaths as $allowedPath) {
                if (strpos($realPath, $allowedPath) === 0) {
                    $pathAllowed = true;
                    break;
                }
            }
            
            if (!$pathAllowed) {
                throw new Exception("文件路径不在允许范围内: $filename");
            }
            
            return $realPath;
        }
        
        public function clearCache() {
            $this->cache = [];
        }
        
        public function getCacheInfo() {
            return [
                'cached_files' => count($this->cache),
                'files' => array_keys($this->cache)
            ];
        }
    }
    
    // 自动加载器类
    class SecureAutoloader {
        private $directories = [];
        private $classMap = [];
        private $fileLoader;
        
        public function __construct(SecureFileLoader $fileLoader) {
            $this->fileLoader = $fileLoader;
        }
        
        // 注册自动加载器
        public function register() {
            spl_autoload_register([$this, 'loadClass']);
        }
        
        // 添加类目录
        public function addDirectory($directory, $namespace = '') {
            $this->directories[$namespace] = $directory;
        }
        
        // 添加类映射
        public function addClassMap($className, $filename) {
            $this->classMap[$className] = $filename;
        }
        
        // 加载类
        public function loadClass($className) {
            // 检查类映射
            if (isset($this->classMap[$className])) {
                try {
                    $this->fileLoader->requireFile($this->classMap[$className], true);
                    return true;
                } catch (Exception $e) {
                    error_log("自动加载失败 (映射): " . $e->getMessage());
                    return false;
                }
            }
            
            // PSR-4 自动加载
            foreach ($this->directories as $namespace => $directory) {
                if ($namespace && strpos($className, $namespace) !== 0) {
                    continue;
                }
                
                $relativePath = $namespace ? 
                    substr($className, strlen($namespace)) : $className;
                $filename = $directory . '/' . str_replace('\\', '/', $relativePath) . '.php';
                
                try {
                    $this->fileLoader->requireFile($filename, true);
                    return true;
                } catch (Exception $e) {
                    // 继续尝试下一个目录
                    continue;
                }
            }
            
            error_log("无法自动加载类: $className");
            return false;
        }
    }
    
    // 模块管理器类
    class ModuleManager {
        private $fileLoader;
        private $loadedModules = [];
        private $moduleConfig = [];
        
        public function __construct(SecureFileLoader $fileLoader) {
            $this->fileLoader = $fileLoader;
        }
        
        // 加载模块
        public function loadModule($moduleName, $config = []) {
            if (isset($this->loadedModules[$moduleName])) {
                return $this->loadedModules[$moduleName];
            }
            
            $moduleFile = "modules/$moduleName/module.php";
            
            try {
                // 设置模块配置
                $this->moduleConfig[$moduleName] = $config;
                
                // 加载模块文件
                $module = $this->fileLoader->requireFile($moduleFile, true);
                
                // 初始化模块
                if (is_object($module) && method_exists($module, 'initialize')) {
                    $module->initialize($config);
                }
                
                $this->loadedModules[$moduleName] = $module;
                
                error_log("模块加载成功: $moduleName");
                return $module;
                
            } catch (Exception $e) {
                error_log("模块加载失败 $moduleName: " . $e->getMessage());
                throw $e;
            }
        }
        
        // 卸载模块
        public function unloadModule($moduleName) {
            if (!isset($this->loadedModules[$moduleName])) {
                return false;
            }
            
            $module = $this->loadedModules[$moduleName];
            
            // 调用模块清理方法
            if (is_object($module) && method_exists($module, 'cleanup')) {
                $module->cleanup();
            }
            
            unset($this->loadedModules[$moduleName]);
            unset($this->moduleConfig[$moduleName]);
            
            error_log("模块已卸载: $moduleName");
            return true;
        }
        
        public function getLoadedModules() {
            return array_keys($this->loadedModules);
        }
        
        public function getModule($moduleName) {
            return $this->loadedModules[$moduleName] ?? null;
        }
    }
?>
```

## 十五、命名空间

### 15.1 命名空间基础

命名空间解决了类名冲突问题，特别在大型项目中非常重要：

```php
<?php
    // 定义命名空间
    namespace Security\Authentication;
    
    class User {
        private $username;
        private $roles = [];
        
        public function __construct($username) {
            $this->username = $username;
        }
        
        public function addRole($role) {
            if (!in_array($role, $this->roles)) {
                $this->roles[] = $role;
            }
        }
        
        public function hasRole($role) {
            return in_array($role, $this->roles);
        }
        
        public function getUsername() {
            return $this->username;
        }
    }
    
    class AuthenticationService {
        private $users = [];
        
        public function registerUser($username, $password) {
            $user = new User($username); // 同一命名空间内的类
            $this->users[$username] = [
                'user' => $user,
                'password' => password_hash($password, PASSWORD_DEFAULT)
            ];
            
            return $user;
        }
        
        public function authenticate($username, $password) {
            if (!isset($this->users[$username])) {
                return false;
            }
            
            $userData = $this->users[$username];
            if (password_verify($password, $userData['password'])) {
                return $userData['user'];
            }
            
            return false;
        }
    }
    
    // 常量也可以在命名空间中
    const MAX_LOGIN_ATTEMPTS = 5;
    const LOCKOUT_DURATION = 300;
    
    // 函数也可以在命名空间中
    function hashPassword($password) {
        return password_hash($password, PASSWORD_DEFAULT);
    }
?>
```

### 15.2 多命名空间和使用声明

```php
<?php
    // 加密相关命名空间
    namespace Security\Encryption {
        class AESEncryption {
            private $key;
            private $method = 'AES-256-CBC';
            
            public function __construct($key) {
                $this->key = $key;
            }
            
            public function encrypt($data) {
                $iv = random_bytes(16);
                $encrypted = openssl_encrypt($data, $this->method, $this->key, 0, $iv);
                return base64_encode($iv . $encrypted);
            }
            
            public function decrypt($encryptedData) {
                $data = base64_decode($encryptedData);
                $iv = substr($data, 0, 16);
                $encrypted = substr($data, 16);
                return openssl_decrypt($encrypted, $this->method, $this->key, 0, $iv);
            }
        }
        
        function generateKey($length = 32) {
            return random_bytes($length);
        }
    }
    
    // 日志相关命名空间
    namespace Security\Logging {
        class SecurityLogger {
            private $logFile;
            
            public function __construct($logFile) {
                $this->logFile = $logFile;
            }
            
            public function logEvent($event, $level = 'INFO', $context = []) {
                $timestamp = date('Y-m-d H:i:s');
                $contextJson = json_encode($context);
                $logEntry = "[$timestamp] [$level] $event $contextJson\n";
                
                file_put_contents($this->logFile, $logEntry, FILE_APPEND | LOCK_EX);
            }
        }
    }
    
    // 主应用命名空间
    namespace Security\Application {
        // 使用其他命名空间的类
        use Security\Authentication\AuthenticationService;
        use Security\Authentication\User;
        use Security\Encryption\AESEncryption;
        use Security\Logging\SecurityLogger;
        
        // 也可以使用别名
        use Security\Encryption\generateKey as generateEncryptionKey;
        
        class SecureApplication {
            private $auth;
            private $encryption;
            private $logger;
            
            public function __construct() {
                $this->auth = new AuthenticationService();
                
                $encryptionKey = generateEncryptionKey();
                $this->encryption = new AESEncryption($encryptionKey);
                
                $this->logger = new SecurityLogger('./security.log');
            }
            
            public function login($username, $password) {
                $this->logger->logEvent('登录尝试', 'INFO', ['username' => $username]);
                
                $user = $this->auth->authenticate($username, $password);
                
                if ($user) {
                    $this->logger->logEvent('登录成功', 'INFO', ['username' => $username]);
                    return $user;
                } else {
                    $this->logger->logEvent('登录失败', 'WARNING', ['username' => $username]);
                    return false;
                }
            }
            
            public function encryptSensitiveData($data) {
                return $this->encryption->encrypt($data);
            }
            
            public function decryptSensitiveData($encryptedData) {
                return $this->encryption->decrypt($encryptedData);
            }
        }
    }
    
    // 在全局命名空间中使用
    namespace {
        use Security\Application\SecureApplication;
        
        // 创建应用实例
        $app = new SecureApplication();
        
        // 使用应用
        $result = $app->login('admin', 'password123');
        if ($result) {
            echo "登录成功: " . $result->getUsername() . "\n";
        } else {
            echo "登录失败\n";
        }
    }
?>
```

### 15.3 命名空间的高级用法

```php
<?php
    namespace Security\Validation {
        
        // 抽象验证器基类
        abstract class AbstractValidator {
            protected $errors = [];
            
            abstract public function validate($input);
            
            public function getErrors() {
                return $this->errors;
            }
            
            public function hasErrors() {
                return !empty($this->errors);
            }
            
            protected function addError($message) {
                $this->errors[] = $message;
            }
            
            public function reset() {
                $this->errors = [];
            }
        }
        
        // 输入验证器
        class InputValidator extends AbstractValidator {
            private $rules = [];
            
            public function addRule($field, $rule, $params = []) {
                $this->rules[$field][] = compact('rule', 'params');
                return $this;
            }
            
            public function validate($input) {
                $this->reset();
                
                foreach ($this->rules as $field => $fieldRules) {
                    $value = $input[$field] ?? null;
                    
                    foreach ($fieldRules as $ruleData) {
                        if (!$this->applyRule($field, $value, $ruleData['rule'], $ruleData['params'])) {
                            // 如果某个规则失败，继续验证其他规则
                        }
                    }
                }
                
                return !$this->hasErrors();
            }
            
            private function applyRule($field, $value, $rule, $params) {
                switch ($rule) {
                    case 'required':
                        if (empty($value)) {
                            $this->addError("字段 $field 是必需的");
                            return false;
                        }
                        break;
                        
                    case 'minLength':
                        $minLength = $params['length'] ?? 0;
                        if (strlen($value) < $minLength) {
                            $this->addError("字段 $field 长度至少 $minLength 个字符");
                            return false;
                        }
                        break;
                        
                    case 'maxLength':
                        $maxLength = $params['length'] ?? 255;
                        if (strlen($value) > $maxLength) {
                            $this->addError("字段 $field 长度不能超过 $maxLength 个字符");
                            return false;
                        }
                        break;
                        
                    case 'email':
                        if (!filter_var($value, FILTER_VALIDATE_EMAIL)) {
                            $this->addError("字段 $field 必须是有效的邮箱地址");
                            return false;
                        }
                        break;
                        
                    case 'pattern':
                        $pattern = $params['pattern'] ?? '';
                        if (!preg_match($pattern, $value)) {
                            $message = $params['message'] ?? "字段 $field 格式不正确";
                            $this->addError($message);
                            return false;
                        }
                        break;
                }
                
                return true;
            }
        }
    }
    
    namespace Security\Sanitization {
        
        class DataSanitizer {
            private $filters = [];
            
            public function addFilter($field, $filter, $options = []) {
                $this->filters[$field][] = compact('filter', 'options');
                return $this;
            }
            
            public function sanitize($input) {
                $sanitized = [];
                
                foreach ($input as $field => $value) {
                    if (isset($this->filters[$field])) {
                        $sanitized[$field] = $this->applyFilters($value, $this->filters[$field]);
                    } else {
                        // 默认过滤
                        $sanitized[$field] = $this->defaultFilter($value);
                    }
                }
                
                return $sanitized;
            }
            
            private function applyFilters($value, $filters) {
                foreach ($filters as $filterData) {
                    $value = $this->applyFilter($value, $filterData['filter'], $filterData['options']);
                }
                return $value;
            }
            
            private function applyFilter($value, $filter, $options) {
                switch ($filter) {
                    case 'trim':
                        return trim($value);
                        
                    case 'htmlspecialchars':
                        $flags = $options['flags'] ?? ENT_QUOTES;
                        $encoding = $options['encoding'] ?? 'UTF-8';
                        return htmlspecialchars($value, $flags, $encoding);
                        
                    case 'strip_tags':
                        $allowed = $options['allowed'] ?? '';
                        return strip_tags($value, $allowed);
                        
                    case 'filter_var':
                        $filterType = $options['filter'] ?? FILTER_SANITIZE_STRING;
                        $flags = $options['flags'] ?? 0;
                        return filter_var($value, $filterType, $flags);
                        
                    case 'preg_replace':
                        $pattern = $options['pattern'] ?? '';
                        $replacement = $options['replacement'] ?? '';
                        return preg_replace($pattern, $replacement, $value);
                        
                    default:
                        return $value;
                }
            }
            
            private function defaultFilter($value) {
                if (is_string($value)) {
                    return htmlspecialchars(trim($value), ENT_QUOTES, 'UTF-8');
                }
                return $value;
            }
        }
    }
    
    // 综合使用示例
    namespace Security\FormProcessor {
        
        use Security\Validation\InputValidator;
        use Security\Sanitization\DataSanitizer;
        
        class SecureFormProcessor {
            private $validator;
            private $sanitizer;
            
            public function __construct() {
                $this->validator = new InputValidator();
                $this->sanitizer = new DataSanitizer();
            }
            
            public function processRegistrationForm($formData) {
                // 配置验证规则
                $this->validator
                    ->addRule('username', 'required')
                    ->addRule('username', 'minLength', ['length' => 3])
                    ->addRule('username', 'maxLength', ['length' => 20])
                    ->addRule('username', 'pattern', [
                        'pattern' => '/^[a-zA-Z0-9_]+$/',
                        'message' => '用户名只能包含字母、数字和下划线'
                    ])
                    ->addRule('email', 'required')
                    ->addRule('email', 'email')
                    ->addRule('password', 'required')
                    ->addRule('password', 'minLength', ['length' => 8])
                    ->addRule('password', 'pattern', [
                        'pattern' => '/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/',
                        'message' => '密码必须包含大小写字母和数字'
                    ]);
                
                // 配置清理规则
                $this->sanitizer
                    ->addFilter('username', 'trim')
                    ->addFilter('username', 'htmlspecialchars')
                    ->addFilter('email', 'trim')
                    ->addFilter('email', 'filter_var', ['filter' => FILTER_SANITIZE_EMAIL])
                    ->addFilter('bio', 'trim')
                    ->addFilter('bio', 'strip_tags', ['allowed' => '<p><br><strong><em>']);
                
                // 先清理数据
                $sanitizedData = $this->sanitizer->sanitize($formData);
                
                // 再验证数据
                $isValid = $this->validator->validate($sanitizedData);
                
                return [
                    'valid' => $isValid,
                    'data' => $sanitizedData,
                    'errors' => $this->validator->getErrors()
                ];
            }
        }
    }
?>
```

## 十六、综合实验：面向对象安全管理系统

### 16.1 实验目标

创建一个完整的面向对象安全管理系统，综合运用本章学习的所有概念。

### 16.2 系统架构

```php
<?php
    // 配置文件 config.php
    return [
        'database' => [
            'host' => 'localhost',
            'name' => 'security_system',
            'username' => 'root',
            'password' => 'password'
        ],
        'security' => [
            'password_min_length' => 8,
            'max_login_attempts' => 5,
            'lockout_duration' => 900,
            'session_timeout' => 3600
        ],
        'encryption' => [
            'key' => 'your-32-byte-encryption-key-here',
            'algorithm' => 'AES-256-CBC'
        ]
    ];
?>
```

```php
<?php
    // 主系统文件 security_system.php
    
    // 启用错误报告（开发环境）
    error_reporting(E_ALL);
    ini_set('display_errors', 1);
    
    // 设置字符编码
    mb_internal_encoding('UTF-8');
    
    // 启用会话
    if (session_status() === PHP_SESSION_NONE) {
        session_start();
    }
    
    // 命名空间和类定义在单独文件中，这里模拟完整系统
    require_once 'classes/Application.php';
    
    use Security\Application\SecureApplication;
    
    try {
        // 创建应用实例
        $app = new SecureApplication('./config.php');
        
        // 处理HTTP请求
        $app->handleRequest();
        
    } catch (Exception $e) {
        // 全局异常处理
        error_log('应用程序错误: ' . $e->getMessage());
        
        http_response_code(500);
        echo json_encode([
            'success' => false,
            'message' => '系统错误，请稍后重试'
        ]);
    }
    
    // 完整的应用程序类
    namespace Security\Application {
        
        use Security\Authentication\AuthenticationManager;
        use Security\Authorization\AuthorizationManager;
        use Security\Validation\InputValidator;
        use Security\Logging\SecurityLogger;
        use Security\Database\SecureDatabase;
        
        class SecureApplication {
            private $config;
            private $auth;
            private $authz;
            private $validator;
            private $logger;
            private $database;
            
            public function __construct($configFile) {
                $this->loadConfiguration($configFile);
                $this->initializeComponents();
            }
            
            public function handleRequest() {
                $method = $_SERVER['REQUEST_METHOD'] ?? 'GET';
                $action = $_POST['action'] ?? $_GET['action'] ?? 'dashboard';
                
                // 记录请求
                $this->logger->logRequest($method, $action, $this->getClientIP());
                
                // 路由请求
                switch ($action) {
                    case 'login':
                        $this->handleLogin();
                        break;
                    case 'register':
                        $this->handleRegister();
                        break;
                    case 'logout':
                        $this->handleLogout();
                        break;
                    case 'profile':
                        $this->handleProfile();
                        break;
                    case 'admin':
                        $this->handleAdmin();
                        break;
                    default:
                        $this->handleDashboard();
                        break;
                }
            }
            
            private function handleLogin() {
                if ($_SERVER['REQUEST_METHOD'] === 'POST') {
                    $username = $this->validator->sanitize($_POST['username'] ?? '');
                    $password = $_POST['password'] ?? '';
                    $rememberMe = isset($_POST['remember_me']);
                    
                    try {
                        $user = $this->auth->authenticate($username, $password);
                        
                        if ($user) {
                            $this->auth->createSession($user, $rememberMe);
                            $this->logger->logSecurityEvent('LOGIN_SUCCESS', $username);
                            
                            $this->jsonResponse(['success' => true, 'message' => '登录成功']);
                        } else {
                            $this->logger->logSecurityEvent('LOGIN_FAILED', $username);
                            $this->jsonResponse(['success' => false, 'message' => '用户名或密码错误']);
                        }
                    } catch (Exception $e) {
                        $this->logger->logSecurityEvent('LOGIN_ERROR', $username, ['error' => $e->getMessage()]);
                        $this->jsonResponse(['success' => false, 'message' => $e->getMessage()]);
                    }
                } else {
                    $this->renderLoginForm();
                }
            }
            
            private function handleRegister() {
                if ($_SERVER['REQUEST_METHOD'] === 'POST') {
                    $userData = [
                        'username' => $_POST['username'] ?? '',
                        'email' => $_POST['email'] ?? '',
                        'password' => $_POST['password'] ?? '',
                        'confirm_password' => $_POST['confirm_password'] ?? ''
                    ];
                    
                    // 验证输入
                    $validation = $this->validateRegistration($userData);
                    
                    if (!$validation['valid']) {
                        $this->jsonResponse([
                            'success' => false,
                            'message' => '注册信息有误',
                            'errors' => $validation['errors']
                        ]);
                        return;
                    }
                    
                    try {
                        $user = $this->auth->registerUser(
                            $validation['data']['username'],
                            $validation['data']['email'],
                            $validation['data']['password']
                        );
                        
                        $this->logger->logSecurityEvent('USER_REGISTERED', $user->getUsername());
                        $this->jsonResponse(['success' => true, 'message' => '注册成功']);
                        
                    } catch (Exception $e) {
                        $this->logger->logSecurityEvent('REGISTRATION_ERROR', $userData['username'], ['error' => $e->getMessage()]);
                        $this->jsonResponse(['success' => false, 'message' => $e->getMessage()]);
                    }
                } else {
                    $this->renderRegistrationForm();
                }
            }
            
            private function handleDashboard() {
                if (!$this->auth->isLoggedIn()) {
                    header('Location: ?action=login');
                    exit;
                }
                
                $user = $this->auth->getCurrentUser();
                $this->renderDashboard($user);
            }
            
            private function handleProfile() {
                if (!$this->auth->isLoggedIn()) {
                    $this->jsonResponse(['success' => false, 'message' => '请先登录']);
                    return;
                }
                
                if (!$this->authz->hasPermission($this->auth->getCurrentUser(), 'profile_access')) {
                    $this->jsonResponse(['success' => false, 'message' => '权限不足']);
                    return;
                }
                
                $user = $this->auth->getCurrentUser();
                $this->renderProfile($user);
            }
            
            private function handleAdmin() {
                if (!$this->auth->isLoggedIn()) {
                    $this->jsonResponse(['success' => false, 'message' => '请先登录']);
                    return;
                }
                
                if (!$this->authz->hasRole($this->auth->getCurrentUser(), 'admin')) {
                    $this->logger->logSecurityEvent('UNAUTHORIZED_ACCESS_ATTEMPT', 
                        $this->auth->getCurrentUser()->getUsername(), 
                        ['attempted_resource' => 'admin']
                    );
                    $this->jsonResponse(['success' => false, 'message' => '需要管理员权限']);
                    return;
                }
                
                $this->renderAdminPanel();
            }
            
            private function validateRegistration($userData) {
                $this->validator->reset();
                
                // 用户名验证
                if (empty($userData['username'])) {
                    $this->validator->addError('用户名不能为空');
                } elseif (strlen($userData['username']) < 3) {
                    $this->validator->addError('用户名至少3个字符');
                } elseif (!preg_match('/^[a-zA-Z0-9_]+$/', $userData['username'])) {
                    $this->validator->addError('用户名只能包含字母、数字和下划线');
                }
                
                // 邮箱验证
                if (empty($userData['email'])) {
                    $this->validator->addError('邮箱不能为空');
                } elseif (!filter_var($userData['email'], FILTER_VALIDATE_EMAIL)) {
                    $this->validator->addError('邮箱格式不正确');
                }
                
                // 密码验证
                if (empty($userData['password'])) {
                    $this->validator->addError('密码不能为空');
                } elseif (strlen($userData['password']) < $this->config['security']['password_min_length']) {
                    $this->validator->addError('密码长度至少' . $this->config['security']['password_min_length'] . '位');
                } elseif ($userData['password'] !== $userData['confirm_password']) {
                    $this->validator->addError('两次输入的密码不一致');
                }
                
                return [
                    'valid' => !$this->validator->hasErrors(),
                    'errors' => $this->validator->getErrors(),
                    'data' => [
                        'username' => htmlspecialchars(trim($userData['username']), ENT_QUOTES, 'UTF-8'),
                        'email' => filter_var($userData['email'], FILTER_SANITIZE_EMAIL),
                        'password' => $userData['password']
                    ]
                ];
            }
            
            private function loadConfiguration($configFile) {
                if (!file_exists($configFile)) {
                    throw new Exception('配置文件不存在');
                }
                
                $this->config = require $configFile;
                
                if (!is_array($this->config)) {
                    throw new Exception('配置文件格式错误');
                }
            }
            
            private function initializeComponents() {
                // 初始化数据库
                $this->database = new SecureDatabase($this->config['database']);
                
                // 初始化日志
                $this->logger = new SecurityLogger('./logs/security.log');
                
                // 初始化验证器
                $this->validator = new InputValidator();
                
                // 初始化认证管理器
                $this->auth = new AuthenticationManager($this->database, $this->config['security']);
                
                // 初始化授权管理器
                $this->authz = new AuthorizationManager($this->database);
            }
            
            private function getClientIP() {
                $headers = ['HTTP_X_FORWARDED_FOR', 'HTTP_CLIENT_IP', 'REMOTE_ADDR'];
                foreach ($headers as $header) {
                    if (!empty($_SERVER[$header])) {
                        return $_SERVER[$header];
                    }
                }
                return 'unknown';
            }
            
            private function jsonResponse($data) {
                header('Content-Type: application/json');
                echo json_encode($data);
            }
            
            private function renderLoginForm() {
                // 渲染登录表单HTML
                echo '<!DOCTYPE html>
                <html>
                <head><title>安全管理系统 - 登录</title></head>
                <body>
                    <h1>系统登录</h1>
                    <form method="POST">
                        <input type="hidden" name="action" value="login">
                        <p><label>用户名: <input type="text" name="username" required></label></p>
                        <p><label>密码: <input type="password" name="password" required></label></p>
                        <p><label><input type="checkbox" name="remember_me"> 记住我</label></p>
                        <p><button type="submit">登录</button></p>
                        <p><a href="?action=register">注册新账户</a></p>
                    </form>
                </body>
                </html>';
            }
            
            private function renderRegistrationForm() {
                echo '<!DOCTYPE html>
                <html>
                <head><title>安全管理系统 - 注册</title></head>
                <body>
                    <h1>用户注册</h1>
                    <form method="POST">
                        <input type="hidden" name="action" value="register">
                        <p><label>用户名: <input type="text" name="username" required></label></p>
                        <p><label>邮箱: <input type="email" name="email" required></label></p>
                        <p><label>密码: <input type="password" name="password" required></label></p>
                        <p><label>确认密码: <input type="password" name="confirm_password" required></label></p>
                        <p><button type="submit">注册</button></p>
                        <p><a href="?action=login">返回登录</a></p>
                    </form>
                </body>
                </html>';
            }
            
            private function renderDashboard($user) {
                echo '<!DOCTYPE html>
                <html>
                <head><title>安全管理系统 - 仪表板</title></head>
                <body>
                    <h1>欢迎，' . htmlspecialchars($user->getUsername()) . '！</h1>
                    <nav>
                        <a href="?action=profile">个人资料</a>
                        <a href="?action=admin">管理面板</a>
                        <a href="?action=logout">退出登录</a>
                    </nav>
                    <h2>系统概览</h2>
                    <p>当前时间: ' . date('Y-m-d H:i:s') . '</p>
                    <p>用户角色: ' . implode(', ', $user->getRoles()) . '</p>
                </body>
                </html>';
            }
        }
    }
?>
```

## 十七、课程总结

### 17.1 本章知识点总结

| 核心概念 | 主要内容 | 安全应用 |
|----------|----------|----------|
| **面向对象基础** | 类、对象、属性、方法 | 封装敏感数据和安全逻辑 |
| **构造析构函数** | 对象生命周期管理 | 安全初始化和资源清理 |
| **继承** | 代码复用和扩展 | 安全类的层次化设计 |
| **访问控制** | public、protected、private | 保护敏感信息和方法 |
| **接口和抽象类** | 契约定义和抽象设计 | 统一的安全接口标准 |
| **常量** | 不可变的配置值 | 安全配置和状态常量 |
| **命名空间** | 代码组织和避免冲突 | 安全模块的分离和管理 |

### 17.2 安全编程最佳实践

1. **封装原则**
   - 将敏感数据设为private
   - 通过公共方法控制访问
   - 验证所有输入参数
   - 清理所有输出数据

2. **继承设计**
   - 合理设计继承层次
   - 保护重要方法不被重写
   - 正确调用父类构造函数
   - 考虑使用final关键字

3. **接口使用**
   - 定义清晰的安全契约
   - 统一错误处理方式
   - 标准化验证接口
   - 模块化安全组件

### 17.3 下一步学习方向

完成PHP类与对象学习后，接下来将学习：
1. **PHP正则表达式** - 模式匹配和数据验证
2. **PHP调用MySQL** - 数据库操作和安全

通过本章学习，你已经掌握了PHP面向对象编程的核心概念和安全编程实践，能够设计和实现安全可靠的面向对象系统。
```

由于内容较长，我会继续完成剩余的部分。这是PHP类与对象课件的第一部分，包含了面向对象的基础概念、类定义、构造析构函数、继承、访问控制、接口、常量、抽象类、Final关键字和Parent调用等核心内容。

接下来我会继续添加剩余的内容，包括超级全局变量、include文件处理、命名空间和综合实验。