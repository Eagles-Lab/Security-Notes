# PHP正则表达式

## 一、课程目标
通过本课程的学习，学生将掌握：
- PHP正则表达式的基本概念和语法
- 掌握preg_match()、preg_match_all()等核心函数的使用
- 理解PREG常量的作用和应用场景
- 掌握preg_filter()和preg_split()的高级用法
- 在安全开发中正确使用正则表达式进行输入验证和过滤

## 二、正则表达式基础概念

### 2.1 什么是正则表达式
正则表达式（Regular Expression，简称regex或regexp）是一种强大的字符串匹配工具，用于描述字符串的模式。在PHP中，正则表达式主要用于：
- 数据验证（邮箱、电话、身份证等格式验证）
- 字符串搜索和替换
- 数据提取和解析
- 输入过滤和安全防护

### 2.2 PHP正则表达式语法基础
PHP使用PCRE（Perl兼容正则表达式）库，基本语法结构：
```php
/pattern/modifiers
```

**常用元字符：**
- `.` : 匹配任意单个字符（除换行符）
- `*` : 匹配前面字符0次或多次
- `+` : 匹配前面字符1次或多次
- `?` : 匹配前面字符0次或1次
- `^` : 匹配字符串开始
- `$` : 匹配字符串结束
- `[]` : 字符类，匹配括号内任意一个字符
- `()` : 分组，用于提取子匹配

**常用修饰符：**
- `i` : 忽略大小写
- `m` : 多行模式
- `s` : 单行模式（.匹配包括换行符）
- `u` : UTF-8模式
- `x` : 忽略空白字符和注释

## 三、preg_match()函数详解

### 3.1 函数语法
```php
preg_match($pattern, $subject, &$matches = null, $flags = 0, $offset = 0)
```

**参数说明：**
- `$pattern`: 正则表达式模式
- `$subject`: 要搜索的字符串
- `$matches`: 存储匹配结果的数组
- `$flags`: 可选标志
- `$offset`: 搜索开始位置

### 3.2 基本使用示例
```php
<?php
// 验证邮箱格式
function validateEmail($email) {
    $pattern = '/^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/';
    return preg_match($pattern, $email);
}

// 测试邮箱验证
$emails = [
    'test@example.com',
    'invalid-email',
    'user.name+tag@domain.co.uk'
];

foreach ($emails as $email) {
    if (validateEmail($email)) {
        echo "有效邮箱: $email\n";
    } else {
        echo "无效邮箱: $email\n";
    }
}

// 提取匹配内容
$text = "联系电话：138-1234-5678";
$pattern = '/(\d{3})-(\d{4})-(\d{4})/';
if (preg_match($pattern, $text, $matches)) {
    echo "完整匹配: " . $matches[0] . "\n";
    echo "区号: " . $matches[1] . "\n";
    echo "前四位: " . $matches[2] . "\n";
    echo "后四位: " . $matches[3] . "\n";
}
?>
```

### 3.3 安全应用场景
```php
<?php
// 安全的用户名验证
function validateUsername($username) {
    // 只允许字母、数字、下划线，长度3-20位
    $pattern = '/^[a-zA-Z0-9_]{3,20}$/';
    return preg_match($pattern, $username);
}

// 过滤危险字符
function filterDangerousChars($input) {
    // 检测潜在的脚本注入
    $dangerousPattern = '/<script|javascript:|onload=|onerror=/i';
    if (preg_match($dangerousPattern, $input)) {
        return false; // 发现危险内容
    }
    return true;
}

// 验证IP地址
function validateIP($ip) {
    $pattern = '/^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/';
    return preg_match($pattern, $ip);
}
?>
```

## 四、preg_match_all()函数详解

### 4.1 函数语法
```php
preg_match_all($pattern, $subject, &$matches = null, $flags = PREG_PATTERN_ORDER, $offset = 0)
```

### 4.2 基本使用示例
```php
<?php
// 提取所有邮箱地址
$text = "联系人：张三 zhang@company.com，李四 li@example.org，王五 wang@test.cn";
$pattern = '/[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/';

if (preg_match_all($pattern, $text, $matches)) {
    echo "找到 " . count($matches[0]) . " 个邮箱地址：\n";
    foreach ($matches[0] as $email) {
        echo "- $email\n";
    }
}

// 提取所有链接
$html = '<a href="http://example.com">链接1</a> <a href="https://test.org">链接2</a>';
$pattern = '/href="([^"]+)"/';

if (preg_match_all($pattern, $html, $matches)) {
    echo "找到的链接：\n";
    foreach ($matches[1] as $url) {
        echo "- $url\n";
    }
}
?>
```

### 4.3 不同的匹配标志
```php
<?php
$text = "价格：￥199.99，折扣：￥89.50，运费：￥15.00";
$pattern = '/￥(\d+\.\d+)/';

// PREG_PATTERN_ORDER（默认）
preg_match_all($pattern, $text, $matches1, PREG_PATTERN_ORDER);
echo "PREG_PATTERN_ORDER结果：\n";
print_r($matches1);

// PREG_SET_ORDER
preg_match_all($pattern, $text, $matches2, PREG_SET_ORDER);
echo "PREG_SET_ORDER结果：\n";
print_r($matches2);

// PREG_OFFSET_CAPTURE
preg_match_all($pattern, $text, $matches3, PREG_OFFSET_CAPTURE);
echo "PREG_OFFSET_CAPTURE结果：\n";
print_r($matches3);
?>
```

## 五、PREG常量详解

### 5.1 常用PREG常量
```php
<?php
// 匹配标志常量
echo "PREG_PATTERN_ORDER: " . PREG_PATTERN_ORDER . "\n";      // 1
echo "PREG_SET_ORDER: " . PREG_SET_ORDER . "\n";              // 2
echo "PREG_OFFSET_CAPTURE: " . PREG_OFFSET_CAPTURE . "\n";    // 256

// 替换标志常量
echo "PREG_REPLACE_EVAL: " . PREG_REPLACE_EVAL . "\n";        // 1（已弃用）

// 分割标志常量
echo "PREG_SPLIT_NO_EMPTY: " . PREG_SPLIT_NO_EMPTY . "\n";    // 1
echo "PREG_SPLIT_DELIM_CAPTURE: " . PREG_SPLIT_DELIM_CAPTURE . "\n"; // 2
echo "PREG_SPLIT_OFFSET_CAPTURE: " . PREG_SPLIT_OFFSET_CAPTURE . "\n"; // 4

// 错误常量
echo "PREG_NO_ERROR: " . PREG_NO_ERROR . "\n";                // 0
echo "PREG_INTERNAL_ERROR: " . PREG_INTERNAL_ERROR . "\n";    // 1
echo "PREG_BACKTRACK_LIMIT_ERROR: " . PREG_BACKTRACK_LIMIT_ERROR . "\n"; // 2
echo "PREG_RECURSION_LIMIT_ERROR: " . PREG_RECURSION_LIMIT_ERROR . "\n"; // 3
echo "PREG_BAD_UTF8_ERROR: " . PREG_BAD_UTF8_ERROR . "\n";    // 4
echo "PREG_BAD_UTF8_OFFSET_ERROR: " . PREG_BAD_UTF8_OFFSET_ERROR . "\n"; // 5
?>
```

### 5.2 实际应用示例
```php
<?php
// 使用PREG_SPLIT_NO_EMPTY避免空字符串
$text = "apple,,banana,,,cherry,";
$fruits1 = preg_split('/,/', $text);
$fruits2 = preg_split('/,/', $text, -1, PREG_SPLIT_NO_EMPTY);

echo "不使用PREG_SPLIT_NO_EMPTY：\n";
print_r($fruits1); // 包含空字符串

echo "使用PREG_SPLIT_NO_EMPTY：\n";
print_r($fruits2); // 不包含空字符串

// 使用PREG_OFFSET_CAPTURE获取位置信息
$text = "Hello World PHP";
$pattern = '/\w+/';
preg_match_all($pattern, $text, $matches, PREG_OFFSET_CAPTURE);

echo "单词及其位置：\n";
foreach ($matches[0] as $match) {
    echo "'{$match[0]}' 位置：{$match[1]}\n";
}
?>
```

## 六、preg_filter()函数详解

### 6.1 函数语法
```php
preg_filter($pattern, $replacement, $subject, $limit = -1, &$count = null)
```

### 6.2 基本使用和与preg_replace()的区别
```php
<?php
$subjects = [
    'hello world',
    'goodbye world', 
    'php programming',
    'java development'
];

// preg_replace 会返回所有元素（即使没有匹配）
$result1 = preg_replace('/world/', 'universe', $subjects);
echo "preg_replace结果：\n";
print_r($result1);

// preg_filter 只返回有匹配的元素
$result2 = preg_filter('/world/', 'universe', $subjects);
echo "preg_filter结果：\n";
print_r($result2);

// 实际应用：过滤并清理HTML标签
$htmlArray = [
    '<p>正常段落</p>',
    '<script>alert("danger")</script>',
    '<h1>标题</h1>',
    'plain text',
    '<img src="hack.jpg" onerror="alert(1)">'
];

// 只保留安全的HTML标签，移除危险内容
$safeHtml = preg_filter('/^(?!.*<script|.*onerror=).+$/', '$0', $htmlArray);
echo "安全的HTML内容：\n";
print_r($safeHtml);
?>
```

### 6.3 高级过滤应用
```php
<?php
// 批量处理用户输入数据
function batchValidateEmails($emails) {
    $pattern = '/^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/';
    return preg_filter($pattern, '$0', $emails);
}

// 批量格式化电话号码
function batchFormatPhones($phones) {
    $pattern = '/^(\d{3})(\d{4})(\d{4})$/';
    $replacement = '$1-$2-$3';
    return preg_filter($pattern, $replacement, $phones);
}

// 测试数据
$emails = [
    'valid@example.com',
    'invalid-email',
    'another@test.org',
    'bad@',
    'good@domain.co.uk'
];

$phones = [
    '13812345678',
    '1234567',  // 无效
    '15987654321',
    'abcd',     // 无效
    '18765432109'
];

echo "有效邮箱：\n";
print_r(batchValidateEmails($emails));

echo "格式化的电话号码：\n";
print_r(batchFormatPhones($phones));
?>
```

## 七、preg_split()函数详解

### 7.1 函数语法
```php
preg_split($pattern, $subject, $limit = -1, $flags = 0)
```

### 7.2 基本使用示例
```php
<?php
// 基本分割
$text = "apple,banana;cherry:orange|grape";
$fruits = preg_split('/[,;:|]/', $text);
echo "分割结果：\n";
print_r($fruits);

// 限制分割次数
$text2 = "one-two-three-four-five";
$parts = preg_split('/-/', $text2, 3);
echo "限制分割次数（3次）：\n";
print_r($parts);

// 保留分隔符
$text3 = "word1<separator>word2<separator>word3";
$result = preg_split('/(<separator>)/', $text3, -1, PREG_SPLIT_DELIM_CAPTURE);
echo "保留分隔符：\n";
print_r($result);
?>
```

### 7.3 高级分割技巧
```php
<?php
// 分割HTML内容并获取位置信息
$html = '<div>内容1</div><p>内容2</p><span>内容3</span>';
$parts = preg_split('/(<\/?\w+>)/', $html, -1, PREG_SPLIT_DELIM_CAPTURE | PREG_SPLIT_OFFSET_CAPTURE);

echo "HTML分割结果：\n";
foreach ($parts as $part) {
    if (!empty($part[0])) {
        echo "内容：'{$part[0]}' 位置：{$part[1]}\n";
    }
}

// 智能分割CSV数据（处理引号内的逗号）
function smartCSVSplit($csvLine) {
    // 匹配逗号，但不包括引号内的逗号
    $pattern = '/,(?=(?:[^"]*"[^"]*")*[^"]*$)/';
    return preg_split($pattern, $csvLine);
}

$csvData = 'name,"John, Doe",25,"Software Engineer"';
$fields = smartCSVSplit($csvData);
echo "CSV分割结果：\n";
print_r($fields);

// 分割多行文本
$multilineText = "第一行\n\n第三行\r\n第四行\n\n\n第七行";
$lines = preg_split('/\r?\n/', $multilineText, -1, PREG_SPLIT_NO_EMPTY);
echo "非空行：\n";
print_r($lines);
?>
```

### 7.4 安全应用：输入数据分割和验证
```php
<?php
// 安全地分割和验证用户输入的标签
function parseAndValidateTags($tagString) {
    // 分割标签（支持逗号、分号、空格分割）
    $tags = preg_split('/[,;\s]+/', trim($tagString), -1, PREG_SPLIT_NO_EMPTY);
    
    $validTags = [];
    foreach ($tags as $tag) {
        // 验证标签格式：只允许字母、数字、中文、下划线和连字符
        if (preg_match('/^[\w\-\u4e00-\u9fa5]+$/u', $tag) && strlen($tag) <= 20) {
            $validTags[] = htmlspecialchars($tag, ENT_QUOTES, 'UTF-8');
        }
    }
    
    return $validTags;
}

// 测试标签解析
$userInput = "PHP, web开发; javascript <script>, 数据库, very-long-tag-that-exceeds-limit";
$cleanTags = parseAndValidateTags($userInput);
echo "清理后的标签：\n";
print_r($cleanTags);
?>
```

## 八、实战应用：构建安全的数据验证系统

### 8.1 综合验证类
```php
<?php
class SecurityValidator {
    private $patterns = [
        'email' => '/^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/',
        'phone' => '/^1[3-9]\d{9}$/',
        'idcard' => '/^[1-9]\d{5}(19|20)\d{2}(0[1-9]|1[0-2])(0[1-9]|[12]\d|3[01])\d{3}[\dXx]$/',
        'username' => '/^[a-zA-Z0-9_\u4e00-\u9fa5]{2,20}$/u',
        'password' => '/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/',
        'url' => '/^https?:\/\/([\w\-]+\.)+[\w\-]+(\/[\w\-._~:\/?#[\]@!$&\'()*+,;%=]*)?$/',
        'ip' => '/^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/'
    ];
    
    private $dangerousPatterns = [
        'xss' => '/<script[^>]*>.*?<\/script>/is',
        'sql_injection' => '/(union\s+select|insert\s+into|delete\s+from|update\s+set|drop\s+table)/i',
        'php_code' => '/<\?php|<\?=/i',
        'javascript' => '/javascript:/i'
    ];
    
    public function validate($type, $input) {
        if (!isset($this->patterns[$type])) {
            throw new InvalidArgumentException("未知的验证类型: $type");
        }
        
        return preg_match($this->patterns[$type], $input);
    }
    
    public function extractMatches($type, $input) {
        if (!isset($this->patterns[$type])) {
            return [];
        }
        
        preg_match_all($this->patterns[$type], $input, $matches);
        return $matches[0];
    }
    
    public function checkSecurity($input) {
        $threats = [];
        
        foreach ($this->dangerousPatterns as $threat => $pattern) {
            if (preg_match($pattern, $input)) {
                $threats[] = $threat;
            }
        }
        
        return empty($threats) ? null : $threats;
    }
    
    public function sanitizeInput($input) {
        // 移除潜在的危险内容
        $cleaned = $input;
        
        foreach ($this->dangerousPatterns as $pattern) {
            $cleaned = preg_replace($pattern, '', $cleaned);
        }
        
        return trim($cleaned);
    }
    
    public function parseStructuredData($input, $delimiter = '/[,;\s]+/') {
        return preg_split($delimiter, trim($input), -1, PREG_SPLIT_NO_EMPTY);
    }
}

// 使用示例
$validator = new SecurityValidator();

// 验证不同类型的数据
$testData = [
    'email' => 'user@example.com',
    'phone' => '13812345678',
    'username' => '测试用户_123',
    'password' => 'SecurePass123!',
    'url' => 'https://www.example.com/path?param=value'
];

echo "=== 数据验证结果 ===\n";
foreach ($testData as $type => $data) {
    $isValid = $validator->validate($type, $data);
    echo "$type: $data - " . ($isValid ? "有效" : "无效") . "\n";
}

// 安全检查
$dangerousInput = '<script>alert("XSS")</script>用户输入内容';
$threats = $validator->checkSecurity($dangerousInput);
if ($threats) {
    echo "\n发现安全威胁: " . implode(', ', $threats) . "\n";
    echo "清理后内容: " . $validator->sanitizeInput($dangerousInput) . "\n";
}

// 提取多个邮箱地址
$emailText = "联系方式：admin@company.com, support@help.org, 还有 user@test.cn";
$emails = $validator->extractMatches('email', $emailText);
echo "\n提取到的邮箱地址：\n";
foreach ($emails as $email) {
    echo "- $email\n";
}
?>
```

### 8.2 实战练习：文件上传安全验证
```php
<?php
class FileUploadValidator {
    private $allowedExtensions = ['jpg', 'jpeg', 'png', 'gif', 'pdf', 'txt'];
    private $dangerousPatterns = [
        '/\.(php|jsp|asp|aspx|exe|bat|cmd|sh)$/i',
        '/<\?php|<%|<script/i'
    ];
    
    public function validateFileName($filename) {
        // 验证文件名格式
        $pattern = '/^[a-zA-Z0-9._\-\u4e00-\u9fa5]+$/u';
        if (!preg_match($pattern, $filename)) {
            return ['valid' => false, 'error' => '文件名包含非法字符'];
        }
        
        // 检查文件扩展名
        if (preg_match('/\.([^.]+)$/', $filename, $matches)) {
            $ext = strtolower($matches[1]);
            if (!in_array($ext, $this->allowedExtensions)) {
                return ['valid' => false, 'error' => '不允许的文件类型'];
            }
        }
        
        // 检查危险模式
        foreach ($this->dangerousPatterns as $pattern) {
            if (preg_match($pattern, $filename)) {
                return ['valid' => false, 'error' => '文件名包含危险内容'];
            }
        }
        
        return ['valid' => true, 'error' => null];
    }
    
    public function sanitizeFileName($filename) {
        // 移除危险字符
        $cleaned = preg_replace('/[^\w.\-\u4e00-\u9fa5]/u', '_', $filename);
        
        // 防止多个连续的点号（目录遍历攻击）
        $cleaned = preg_replace('/\.{2,}/', '.', $cleaned);
        
        // 限制文件名长度
        if (strlen($cleaned) > 100) {
            $cleaned = substr($cleaned, 0, 100);
        }
        
        return $cleaned;
    }
}

// 测试文件上传验证
$fileValidator = new FileUploadValidator();

$testFiles = [
    'normal.jpg',
    'document.pdf',
    'script.php',          // 危险
    'image..jpg',          // 可疑
    '../../etc/passwd',    // 危险
    '测试文档.txt',
    'file with spaces.jpg' // 需要清理
];

echo "=== 文件上传验证测试 ===\n";
foreach ($testFiles as $filename) {
    $result = $fileValidator->validateFileName($filename);
    $sanitized = $fileValidator->sanitizeFileName($filename);
    
    echo "原文件名: $filename\n";
    echo "验证结果: " . ($result['valid'] ? "通过" : "失败 - " . $result['error']) . "\n";
    echo "清理后: $sanitized\n\n";
}
?>
```

## 九、正则表达式性能优化和安全注意事项

### 9.1 性能优化技巧
```php
<?php
// 1. 使用非捕获组减少内存消耗
$text = "email1@example.com and email2@test.org";

// 低效：使用捕获组但不需要捕获内容
$pattern1 = '/([a-zA-Z0-9._%+-]+)@([a-zA-Z0-9.-]+)\.([a-zA-Z]{2,})/';

// 高效：使用非捕获组
$pattern2 = '/(?:[a-zA-Z0-9._%+-]+)@(?:[a-zA-Z0-9.-]+)\.(?:[a-zA-Z]{2,})/';

// 2. 优化字符类
// 低效
$pattern3 = '/[0-9]/';
// 高效
$pattern4 = '/\d/';

// 3. 使用锚点提高效率
// 低效：需要搜索整个字符串
$pattern5 = '/user/';
// 高效：明确指定开始位置
$pattern6 = '/^user/';

// 4. 避免灾难性回溯
// 危险模式：可能导致灾难性回溯
$dangerousPattern = '/^(a+)+b$/';

// 安全模式：使用原子组或占有量词
$safePattern = '/^(?>a+)+b$/';

// 性能测试函数
function benchmarkPattern($pattern, $subject, $iterations = 1000) {
    $start = microtime(true);
    for ($i = 0; $i < $iterations; $i++) {
        preg_match($pattern, $subject);
    }
    $end = microtime(true);
    return ($end - $start) * 1000; // 返回毫秒
}

// 测试不同模式的性能
$testString = "user@example.com";
echo "性能对比测试：\n";
echo "基本模式: " . benchmarkPattern('/user/', $testString) . "ms\n";
echo "锚定模式: " . benchmarkPattern('/^user/', $testString) . "ms\n";
?>
```

### 9.2 安全注意事项
```php
<?php
// 1. 防止ReDoS（正则表达式拒绝服务）攻击
class RegexSecurityChecker {
    private $timeLimit = 0.1; // 100毫秒时间限制
    
    public function safeMatch($pattern, $subject) {
        $start = microtime(true);
        $result = preg_match($pattern, $subject);
        $elapsed = microtime(true) - $start;
        
        if ($elapsed > $this->timeLimit) {
            throw new Exception("正则表达式执行时间过长，可能存在ReDoS风险");
        }
        
        return $result;
    }
    
    public function validatePattern($pattern) {
        $dangerousPatterns = [
            '/.*(\+.*\+|\*.*\*).*/',     // 嵌套量词
            '/.*\(\.\*\)\+.*/',          // 贪婪匹配
            '/.*\.\*\.\*.*/'             // 多个.*连用
        ];
        
        foreach ($dangerousPatterns as $dangerous) {
            if (preg_match($dangerous, $pattern)) {
                return false;
            }
        }
        
        return true;
    }
}

// 2. 输入验证和过滤
function secureRegexInput($userPattern) {
    // 移除潜在的危险修饰符
    $userPattern = preg_replace('/[^a-zA-Z0-9\s\[\](){}.*+?^$|\\-]/', '', $userPattern);
    
    // 限制长度
    if (strlen($userPattern) > 100) {
        throw new InvalidArgumentException("正则表达式过长");
    }
    
    return $userPattern;
}

// 3. 错误处理
function safeRegexOperation($pattern, $subject) {
    $result = preg_match($pattern, $subject);
    
    $error = preg_last_error();
    if ($error !== PREG_NO_ERROR) {
        $errorMessages = [
            PREG_INTERNAL_ERROR => '内部错误',
            PREG_BACKTRACK_LIMIT_ERROR => '回溯限制错误',
            PREG_RECURSION_LIMIT_ERROR => '递归限制错误',
            PREG_BAD_UTF8_ERROR => 'UTF-8错误',
            PREG_BAD_UTF8_OFFSET_ERROR => 'UTF-8偏移错误'
        ];
        
        throw new Exception($errorMessages[$error] ?? '未知正则表达式错误');
    }
    
    return $result;
}

// 使用示例
$securityChecker = new RegexSecurityChecker();

try {
    // 测试安全的模式
    $result = $securityChecker->safeMatch('/^[a-zA-Z0-9]+$/', 'test123');
    echo "匹配结果: $result\n";
    
    // 测试潜在危险的模式
    $dangerousPattern = '/^(a+)+b$/';
    if (!$securityChecker->validatePattern($dangerousPattern)) {
        echo "检测到危险的正则表达式模式\n";
    }
    
} catch (Exception $e) {
    echo "错误: " . $e->getMessage() . "\n";
}
?>
```

## 十、课程总结

### 10.1 核心知识点回顾
1. **基础函数掌握**
   - `preg_match()`: 单次匹配，用于验证和简单提取
   - `preg_match_all()`: 全局匹配，用于提取所有匹配项
   - `preg_filter()`: 过滤匹配，只返回匹配的元素
   - `preg_split()`: 正则分割，灵活的字符串分割工具

2. **PREG常量应用**
   - 匹配标志：`PREG_PATTERN_ORDER`, `PREG_SET_ORDER`, `PREG_OFFSET_CAPTURE`
   - 分割标志：`PREG_SPLIT_NO_EMPTY`, `PREG_SPLIT_DELIM_CAPTURE`
   - 错误常量：用于错误处理和调试

3. **安全实践**
   - 输入验证和数据过滤
   - 防止XSS、SQL注入等安全威胁
   - 性能优化和ReDoS攻击防护

### 10.2 最佳实践建议
1. **性能优先**：使用锚点、非捕获组、避免灾难性回溯
2. **安全第一**：验证用户输入、限制执行时间、错误处理
3. **代码可维护**：使用常量、封装验证类、添加注释
4. **测试驱动**：编写充分的测试用例，包括边界情况

### 10.3 实际应用场景
- Web应用的表单验证
- 数据清洗和格式化
- 日志分析和数据提取
- 安全过滤和威胁检测
- API接口的输入验证

### 10.4 进阶学习方向
1. **高级正则语法**：前瞻后顾断言、条件匹配
2. **Unicode处理**：多语言文本处理
3. **性能调优**：大数据量处理优化
4. **安全防护**：深入了解各种攻击模式和防护方法

## 十一、综合实验：构建企业级数据验证中台

### 11.1 实验目标
构建一个企业级的数据验证中台，集成正则表达式的各种应用场景，包括：
- 多种数据类型的验证
- 批量数据处理
- 安全威胁检测
- 性能监控
- 配置管理

### 11.2 完整实验代码
```php
<?php
/**
 * 企业级数据验证中台
 * 集成PHP正则表达式的各种应用场景
 */

// 配置文件
class ValidationConfig {
    public static $patterns = [
        // 基础数据类型
        'email' => '/^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/',
        'phone_cn' => '/^1[3-9]\d{9}$/',
        'phone_intl' => '/^\+\d{1,3}\d{10,14}$/',
        'idcard_cn' => '/^[1-9]\d{5}(19|20)\d{2}(0[1-9]|1[0-2])(0[1-9]|[12]\d|3[01])\d{3}[\dXx]$/',
        'username' => '/^[a-zA-Z0-9_\u4e00-\u9fa5]{2,30}$/u',
        'password_strong' => '/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/',
        'url' => '/^https?:\/\/([\w\-]+\.)+[\w\-]+(\/[\w\-._~:\/?#[\]@!$&\'()*+,;%=]*)?$/',
        'ip_v4' => '/^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/',
        'mac_address' => '/^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$/',
        
        // 业务特定格式
        'credit_card' => '/^\d{4}[\s-]?\d{4}[\s-]?\d{4}[\s-]?\d{4}$/',
        'social_credit' => '/^[0-9A-HJ-NPQRTUWXY]{2}\d{6}[0-9A-HJ-NPQRTUWXY]{10}$/',
        'license_plate' => '/^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领A-Z]{1}[A-Z]{1}[A-Z0-9]{4}[A-Z0-9挂学警港澳]{1}$/',
        
        // 文档和代码
        'version' => '/^\d+\.\d+\.\d+(?:-[a-zA-Z0-9]+)?$/',
        'hex_color' => '/^#[0-9A-Fa-f]{6}$/',
        'base64' => '/^[A-Za-z0-9+\/]*={0,2}$/',
        'json_string' => '/^\{.*\}$|^\[.*\]$/'
    ];
    
    public static $securityPatterns = [
        'xss' => [
            '/<script[^>]*>.*?<\/script>/is',
            '/javascript:/i',
            '/onload\s*=/i',
            '/onerror\s*=/i',
            '/onclick\s*=/i'
        ],
        'sql_injection' => [
            '/(union\s+select|insert\s+into|delete\s+from|update\s+set|drop\s+table)/i',
            '/(\'\s*(or|and)\s*\')/i',
            '/(\'\s*;\s*)/i'
        ],
        'path_traversal' => [
            '/\.\.\//',
            '/\.\.\\\\/',
            '/%2e%2e%2f/i',
            '/%2e%2e%5c/i'
        ],
        'command_injection' => [
            '/;\s*(rm|del|format|shutdown)/i',
            '/\|\s*(cat|type|dir)/i',
            '/`[^`]*`/',
            '/\$\([^)]*\)/'
        ]
    ];
}

// 验证结果类
class ValidationResult {
    public $isValid;
    public $errorMessage;
    public $securityThreats;
    public $extractedData;
    public $processingTime;
    
    public function __construct($isValid = false) {
        $this->isValid = $isValid;
        $this->errorMessage = null;
        $this->securityThreats = [];
        $this->extractedData = [];
        $this->processingTime = 0;
    }
}

// 核心验证引擎
class ValidationEngine {
    private $config;
    private $performanceTracker;
    
    public function __construct() {
        $this->config = new ValidationConfig();
        $this->performanceTracker = new PerformanceTracker();
    }
    
    // 单个数据验证
    public function validate($type, $data, $options = []) {
        $startTime = microtime(true);
        $result = new ValidationResult();
        
        try {
            // 安全检查
            $result->securityThreats = $this->checkSecurity($data);
            if (!empty($result->securityThreats) && !($options['allow_unsafe'] ?? false)) {
                $result->errorMessage = '检测到安全威胁: ' . implode(', ', $result->securityThreats);
                return $result;
            }
            
            // 格式验证
            if (!isset($this->config::$patterns[$type])) {
                throw new InvalidArgumentException("未知的验证类型: $type");
            }
            
            $pattern = $this->config::$patterns[$type];
            $result->isValid = preg_match($pattern, $data) === 1;
            
            if (!$result->isValid) {
                $result->errorMessage = "数据格式不符合 {$type} 类型要求";
            }
            
            // 提取结构化数据
            if ($result->isValid && ($options['extract_data'] ?? false)) {
                preg_match($pattern, $data, $matches);
                $result->extractedData = $matches;
            }
            
        } catch (Exception $e) {
            $result->errorMessage = $e->getMessage();
        } finally {
            $result->processingTime = (microtime(true) - $startTime) * 1000;
            $this->performanceTracker->record($type, $result->processingTime);
        }
        
        return $result;
    }
    
    // 批量验证
    public function batchValidate($type, $dataArray, $options = []) {
        $results = [];
        $successCount = 0;
        
        foreach ($dataArray as $key => $data) {
            $result = $this->validate($type, $data, $options);
            $results[$key] = $result;
            
            if ($result->isValid) {
                $successCount++;
            }
        }
        
        return [
            'results' => $results,
            'summary' => [
                'total' => count($dataArray),
                'success' => $successCount,
                'failure' => count($dataArray) - $successCount,
                'success_rate' => $successCount / count($dataArray) * 100
            ]
        ];
    }
    
    // 数据提取
    public function extractAll($type, $text, $options = []) {
        if (!isset($this->config::$patterns[$type])) {
            throw new InvalidArgumentException("未知的提取类型: $type");
        }
        
        $pattern = $this->config::$patterns[$type];
        $flags = $options['with_offset'] ?? false ? PREG_OFFSET_CAPTURE : 0;
        
        preg_match_all($pattern, $text, $matches, $flags);
        
        return [
            'matches' => $matches[0],
            'count' => count($matches[0]),
            'text_length' => strlen($text)
        ];
    }
    
    // 数据过滤
    public function filter($type, $dataArray, $options = []) {
        if (!isset($this->config::$patterns[$type])) {
            throw new InvalidArgumentException("未知的过滤类型: $type");
        }
        
        $pattern = $this->config::$patterns[$type];
        $filtered = preg_filter($pattern, '$0', $dataArray);
        
        return [
            'filtered_data' => $filtered ?? [],
            'original_count' => count($dataArray),
            'filtered_count' => count($filtered ?? []),
            'filter_rate' => count($filtered ?? []) / count($dataArray) * 100
        ];
    }
    
    // 数据分割
    public function split($delimiter, $text, $options = []) {
        $flags = 0;
        if ($options['no_empty'] ?? true) {
            $flags |= PREG_SPLIT_NO_EMPTY;
        }
        if ($options['capture_delimiter'] ?? false) {
            $flags |= PREG_SPLIT_DELIM_CAPTURE;
        }
        if ($options['with_offset'] ?? false) {
            $flags |= PREG_SPLIT_OFFSET_CAPTURE;
        }
        
        $limit = $options['limit'] ?? -1;
        $parts = preg_split($delimiter, $text, $limit, $flags);
        
        return [
            'parts' => $parts,
            'count' => count($parts),
            'original_length' => strlen($text)
        ];
    }
    
    // 安全检查
    private function checkSecurity($data) {
        $threats = [];
        
        foreach ($this->config::$securityPatterns as $threatType => $patterns) {
            foreach ($patterns as $pattern) {
                if (preg_match($pattern, $data)) {
                    $threats[] = $threatType;
                    break;
                }
            }
        }
        
        return array_unique($threats);
    }
    
    // 获取性能统计
    public function getPerformanceStats() {
        return $this->performanceTracker->getStats();
    }
}

// 性能追踪器
class PerformanceTracker {
    private $records = [];
    
    public function record($type, $time) {
        if (!isset($this->records[$type])) {
            $this->records[$type] = [];
        }
        $this->records[$type][] = $time;
    }
    
    public function getStats() {
        $stats = [];
        
        foreach ($this->records as $type => $times) {
            $stats[$type] = [
                'count' => count($times),
                'total_time' => array_sum($times),
                'avg_time' => array_sum($times) / count($times),
                'min_time' => min($times),
                'max_time' => max($times)
            ];
        }
        
        return $stats;
    }
}

// 数据清洗器
class DataSanitizer {
    public static function cleanHTML($input) {
        // 移除危险的HTML标签和属性
        $cleaned = preg_replace('/<script[^>]*>.*?<\/script>/is', '', $input);
        $cleaned = preg_replace('/on\w+\s*=\s*["\'][^"\']*["\']/', '', $cleaned);
        $cleaned = preg_replace('/javascript:/i', '', $cleaned);
        return $cleaned;
    }
    
    public static function sanitizeFileName($filename) {
        // 清理文件名中的危险字符
        $cleaned = preg_replace('/[^\w.\-\u4e00-\u9fa5]/u', '_', $filename);
        $cleaned = preg_replace('/\.{2,}/', '.', $cleaned);
        $cleaned = preg_replace('/^\.+|\.+$/', '', $cleaned);
        return substr($cleaned, 0, 255);
    }
    
    public static function normalizeWhitespace($text) {
        // 规范化空白字符
        $cleaned = preg_replace('/\s+/', ' ', $text);
        return trim($cleaned);
    }
}

// 主应用类
class ValidationPlatform {
    private $engine;
    private $logger;
    
    public function __construct() {
        $this->engine = new ValidationEngine();
        $this->logger = new ValidationLogger();
    }
    
    public function processData($request) {
        $this->logger->log("开始处理数据验证请求");
        
        $response = [
            'status' => 'success',
            'data' => [],
            'errors' => [],
            'performance' => []
        ];
        
        try {
            switch ($request['action']) {
                case 'validate':
                    $response['data'] = $this->engine->validate(
                        $request['type'], 
                        $request['data'], 
                        $request['options'] ?? []
                    );
                    break;
                    
                case 'batch_validate':
                    $response['data'] = $this->engine->batchValidate(
                        $request['type'], 
                        $request['data'], 
                        $request['options'] ?? []
                    );
                    break;
                    
                case 'extract':
                    $response['data'] = $this->engine->extractAll(
                        $request['type'], 
                        $request['text'], 
                        $request['options'] ?? []
                    );
                    break;
                    
                case 'filter':
                    $response['data'] = $this->engine->filter(
                        $request['type'], 
                        $request['data'], 
                        $request['options'] ?? []
                    );
                    break;
                    
                case 'split':
                    $response['data'] = $this->engine->split(
                        $request['delimiter'], 
                        $request['text'], 
                        $request['options'] ?? []
                    );
                    break;
                    
                default:
                    throw new InvalidArgumentException("不支持的操作: " . $request['action']);
            }
            
        } catch (Exception $e) {
            $response['status'] = 'error';
            $response['errors'][] = $e->getMessage();
            $this->logger->log("处理错误: " . $e->getMessage());
        } finally {
            $response['performance'] = $this->engine->getPerformanceStats();
            $this->logger->log("数据验证请求处理完成");
        }
        
        return $response;
    }
}

// 日志记录器
class ValidationLogger {
    private $logFile;
    
    public function __construct($logFile = 'validation.log') {
        $this->logFile = $logFile;
    }
    
    public function log($message) {
        $timestamp = date('Y-m-d H:i:s');
        $logEntry = "[{$timestamp}] {$message}" . PHP_EOL;
        file_put_contents($this->logFile, $logEntry, FILE_APPEND | LOCK_EX);
    }
}

// 使用示例和测试
function runComprehensiveTest() {
    $platform = new ValidationPlatform();
    
    echo "=== 企业级数据验证中台测试 ===\n\n";
    
    // 测试1: 单个数据验证
    echo "1. 单个数据验证测试\n";
    $request1 = [
        'action' => 'validate',
        'type' => 'email',
        'data' => 'admin@company.com.cn',
        'options' => ['extract_data' => true]
    ];
    
    $result1 = $platform->processData($request1);
    echo "邮箱验证结果: " . ($result1['data']->isValid ? "通过" : "失败") . "\n";
    if (!empty($result1['data']->securityThreats)) {
        echo "安全威胁: " . implode(', ', $result1['data']->securityThreats) . "\n";
    }
    echo "处理时间: " . number_format($result1['data']->processingTime, 2) . "ms\n\n";
    
    // 测试2: 批量验证
    echo "2. 批量数据验证测试\n";
    $testEmails = [
        'user1@example.com',
        'invalid-email',
        'admin@company.org',
        'test@domain.co.uk',
        '<script>alert("xss")</script>@hack.com'
    ];
    
    $request2 = [
        'action' => 'batch_validate',
        'type' => 'email',
        'data' => $testEmails
    ];
    
    $result2 = $platform->processData($request2);
    echo "批量验证结果:\n";
    echo "总数: {$result2['data']['summary']['total']}\n";
    echo "成功: {$result2['data']['summary']['success']}\n";
    echo "失败: {$result2['data']['summary']['failure']}\n";
    echo "成功率: " . number_format($result2['data']['summary']['success_rate'], 2) . "%\n\n";
    
    // 测试3: 数据提取
    echo "3. 数据提取测试\n";
    $contactText = "
    联系我们：
    销售部：sales@company.com，电话：138-0000-1111
    技术支持：support@company.com，电话：139-0000-2222
    客服热线：service@company.com，电话：400-123-4567
    ";
    
    $request3 = [
        'action' => 'extract',
        'type' => 'email',
        'text' => $contactText,
        'options' => ['with_offset' => true]
    ];
    
    $result3 = $platform->processData($request3);
    echo "提取到 {$result3['data']['count']} 个邮箱地址:\n";
    foreach ($result3['data']['matches'] as $match) {
        if (is_array($match)) {
            echo "- {$match[0]} (位置: {$match[1]})\n";
        } else {
            echo "- $match\n";
        }
    }
    echo "\n";
    
    // 测试4: 数据过滤
    echo "4. 数据过滤测试\n";
    $mixedData = [
        'valid@email.com',
        'not-an-email',
        'another@valid.org',
        'invalid.email',
        'test@domain.co.uk'
    ];
    
    $request4 = [
        'action' => 'filter',
        'type' => 'email',
        'data' => $mixedData
    ];
    
    $result4 = $platform->processData($request4);
    echo "过滤结果:\n";
    echo "原始数据: {$result4['data']['original_count']} 项\n";
    echo "过滤后: {$result4['data']['filtered_count']} 项\n";
    echo "过滤率: " . number_format($result4['data']['filter_rate'], 2) . "%\n";
    echo "有效邮箱: " . implode(', ', $result4['data']['filtered_data']) . "\n\n";
    
    // 测试5: 数据分割
    echo "5. 数据分割测试\n";
    $csvLine = "姓名,邮箱,电话,部门";
    
    $request5 = [
        'action' => 'split',
        'delimiter' => '/,/',
        'text' => $csvLine,
        'options' => ['no_empty' => true]
    ];
    
    $result5 = $platform->processData($request5);
    echo "CSV分割结果 ({$result5['data']['count']} 个字段):\n";
    foreach ($result5['data']['parts'] as $index => $part) {
        echo "字段" . ($index + 1) . ": $part\n";
    }
    echo "\n";
    
    // 性能统计
    echo "6. 性能统计\n";
    $stats = $result1['performance'];
    foreach ($stats as $type => $stat) {
        echo "$type 类型验证:\n";
        echo "  执行次数: {$stat['count']}\n";
        echo "  平均耗时: " . number_format($stat['avg_time'], 2) . "ms\n";
        echo "  最大耗时: " . number_format($stat['max_time'], 2) . "ms\n";
        echo "  最小耗时: " . number_format($stat['min_time'], 2) . "ms\n\n";
    }
    
    echo "=== 测试完成 ===\n";
}

// 运行综合测试
runComprehensiveTest();

// 数据清洗测试
echo "\n=== 数据清洗功能测试 ===\n";

$dangerousHTML = '<div onclick="alert(1)">正常内容</div><script>alert("XSS")</script>';
$cleanHTML = DataSanitizer::cleanHTML($dangerousHTML);
echo "原始HTML: $dangerousHTML\n";
echo "清洗后: $cleanHTML\n\n";

$dangerousFile = '../../../etc/passwd<script>.txt';
$cleanFile = DataSanitizer::sanitizeFileName($dangerousFile);
echo "原始文件名: $dangerousFile\n";
echo "清洗后: $cleanFile\n\n";

$messyText = "这是    一个   \n\n   包含    多余空白  \t  的文本";
$normalText = DataSanitizer::normalizeWhitespace($messyText);
echo "原始文本: '$messyText'\n";
echo "规范化后: '$normalText'\n";
?>
```

### 11.3 实验总结
通过本综合实验，学生将掌握：

1. **企业级架构设计**
   - 模块化设计和责任分离
   - 配置管理和扩展性设计
   - 性能监控和日志记录

2. **正则表达式实战应用**
   - 多种数据类型的验证模式
   - 批量处理和数据提取
   - 安全过滤和威胁检测

3. **性能和安全优化**
   - 执行时间监控
   - 内存使用优化
   - 安全威胁防护

4. **代码质量保证**
   - 异常处理机制
   - 单元测试设计
   - 文档和注释规范

本课程为学生提供了PHP正则表达式的全面知识体系，通过理论学习和实践操作，帮助学生在实际项目中正确、安全、高效地使用正则表达式技术。

**下一步学习建议：**
- 深入学习Unicode和多语言处理
- 研究大数据量处理的性能优化
- 了解其他编程语言中的正则表达式差异
- 学习正则表达式在网络安全中的高级应用