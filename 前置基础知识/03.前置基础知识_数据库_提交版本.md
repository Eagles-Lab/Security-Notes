# 第一章 前置基础知识 - 数据库

## 1. 数据库概念

数据库（Database，简称 DB）是**按照数据结构来组织、存储和管理数据的仓库**，它能高效实现数据的增删改查，避免数据冗余，保证数据的一致性和安全性。在网络安全领域，数据库是核心资产之一（如用户密码库、业务数据存储库），其安全直接影响整个系统的安全，因此掌握数据库基础是学习网络安全的重要前提。

### 1.1 DBMS 类别

DBMS（Database Management System，数据库管理系统）是用于管理数据库的软件，根据数据模型的不同，主要分为以下几类：



| 类别             | 特点                             | 代表产品                            | 适用场景                       |
| -------------- | ------------------------------ | ------------------------------- | -------------------------- |
| 关系型数据库         | 基于关系模型（二维表结构），支持 SQL 语言，数据一致性强 | MySQL、Oracle、SQL Server         | 金融交易、用户管理等对数据一致性要求高的场景     |
| 非关系型数据库（NoSQL） | 不依赖二维表，数据结构灵活（如键值对、文档、图形），扩展性强 | Redis（键值）、MongoDB（文档）、Neo4j（图形） | 高并发读写（如电商秒杀）、非结构化数据存储（如日志） |
| 时序数据库          | 专门存储时间序列数据（按时间戳排序），支持高效时间范围查询  | InfluxDB、Prometheus             | 系统监控、物联网设备数据采集             |

在网络安全课程中，我们以**MySQL（关系型数据库）** 为核心展开学习，因其开源免费、应用广泛，且是渗透测试、漏洞分析中常见的目标数据库。

## 2. MySQL 基础操作

MySQL 是目前最流行的开源关系型数据库，掌握其基础操作（用户管理、权限控制）是保障数据库安全的第一步 —— 许多数据库泄露事件都源于弱密码、过度授权的用户配置。

### 2.1 用户管理

MySQL 通过 `mysql` 系统数据库（存储用户信息、权限配置）实现用户管理，核心操作包括**创建用户、修改用户、删除用户、修改密码**。

#### 2.1.1 核心语法



| 操作   | 语法                                             | 说明                                                         |
| ---- | ---------------------------------------------- | ---------------------------------------------------------- |
| 创建用户 | `CREATE USER '用户名'@'主机地址' IDENTIFIED BY '密码';` | 主机地址：`localhost`（仅本地访问）、`%`（任意主机访问）、具体 IP（如 192.168.1.100） |
| 修改密码 | `ALTER USER '用户名'@'主机地址' IDENTIFIED BY '新密码';` | MySQL 8.0+ 推荐使用此语法，5.7 及以下可使用 `SET PASSWORD`               |
| 删除用户 | `DROP USER '用户名'@'主机地址';`                      | 需指定完整的 “用户名 + 主机地址”，避免误删同名不同主机的用户                          |
| 查看用户 | `SELECT user, host FROM mysql.user;`           | 从 `mysql.user` 表中查询所有用户信息                                  |

#### 2.1.2 注意事项



*   密码强度：生产环境中需设置**复杂密码**（包含大小写字母、数字、特殊符号，长度≥8 位），避免使用 `123456`、`root` 等弱密码（弱密码是暴力破解的主要目标）。

*   主机限制：尽量避免使用 `%`（任意主机访问），仅授权业务所在的 IP 地址访问，减少攻击面。

### 2.2 用户权限介绍

MySQL 采用 “**基于权限的访问控制（RBAC）** ”，即用户仅能执行被授权的操作。权限粒度从粗到细分为：全局权限（对所有数据库生效）、数据库权限（对指定数据库生效）、表权限（对指定表生效）、字段权限（对指定表的字段生效）。

#### 2.2.1 常用权限及说明



| 权限               | 作用                                   | 风险等级（过高授权）       |
| ---------------- | ------------------------------------ | ---------------- |
| `ALL PRIVILEGES` | 所有权限（除 GRANT OPTION 外）               | 极高（可删除 / 篡改所有数据） |
| `SELECT`         | 查询数据（如 `SELECT * FROM 表名`）           | 中（可能泄露敏感数据）      |
| `INSERT`         | 插入数据（如 `INSERT INTO 表名 VALUES(...)`） | 中（可能插入恶意数据）      |
| `UPDATE`         | 修改数据（如 `UPDATE 表名 SET 字段=值`）         | 高（可能篡改关键数据）      |
| `DELETE`         | 删除数据（如 `DELETE FROM 表名`）             | 极高（可能导致数据丢失）     |
| `CREATE`         | 创建数据库 / 表                            | 中（可能创建冗余对象）      |
| `DROP`           | 删除数据库 / 表                            | 极高（可能导致数据彻底丢失）   |
| `GRANT OPTION`   | 将自身权限授予其他用户                          | 高（可能扩散过度授权）      |

#### 2.2.2 权限操作语法



| 操作   | 语法                                       | 示例                                                                                       |
| ---- | ---------------------------------------- | ---------------------------------------------------------------------------------------- |
| 授予权限 | `GRANT 权限列表 ON 作用范围 TO '用户名'@'主机地址';`    | 授予 `testuser` 对 `testdb` 库所有表的查询权限：`GRANT SELECT ON testdb.* TO 'testuser'@'localhost';` |
| 回收权限 | `REVOKE 权限列表 ON 作用范围 FROM '用户名'@'主机地址';` | 回收 `testuser` 对 `testdb` 库的查询权限：`REVOKE SELECT ON testdb.* FROM 'testuser'@'localhost';` |
| 查看权限 | `SHOW GRANTS FOR '用户名'@'主机地址';`          | 查看 `testuser` 的权限：`SHOW GRANTS FOR 'testuser'@'localhost';`                              |

#### 2.2.3 安全原则



*   **最小权限原则**：仅授予用户完成业务所需的最小权限（如查询用户仅授予 `SELECT`，禁止授予 `DELETE`/`DROP`）。

*   **定期审计**：通过 `SHOW GRANTS` 定期检查用户权限，及时回收过度授权或冗余用户的权限。

## 3. SQL 语句

SQL（Structured Query Language，结构化查询语言）是操作关系型数据库的标准语言，根据功能分为 **DDL、DML、DQL、DCL** 四类。掌握 SQL 不仅是数据库操作的基础，也是理解 “SQL 注入漏洞”（网络安全核心漏洞之一）的关键。

### 3.1 DDL 数据定义语句

DDL（Data Definition Language）用于**定义数据库结构**，包括创建 / 删除数据库、创建 / 修改 / 删除表，核心关键字：`CREATE`、`DROP`、`ALTER`、`USE`。

#### 3.1.1 核心语法



1.  **数据库操作**

*   创建数据库：`CREATE DATABASE [IF NOT EXISTS] 数据库名;`（`IF NOT EXISTS` 避免数据库已存在时报错）

*   删除数据库：`DROP DATABASE [IF EXISTS] 数据库名;`（`IF EXISTS` 避免数据库不存在时报错）

*   使用数据库：`USE 数据库名;`（切换到指定数据库，后续操作默认在此数据库下执行）

1.  **表操作**

*   创建表：`CREATE TABLE [IF NOT EXISTS] 表名 (字段1 数据类型 约束, 字段2 数据类型 约束, ..., 主键约束);`

*   删除表：`DROP TABLE [IF EXISTS] 表名;`

*   修改表结构（添加字段）：`ALTER TABLE 表名 ADD 字段名 数据类型 约束;`

#### 3.1.2 MySQL 支持的数据类型

MySQL 数据类型需根据业务场景选择（不合理的类型会导致存储冗余或数据截断），常用类型如下：



| 类别     | 数据类型                                            | 说明                                                                              | 示例                                           |
| ------ | ----------------------------------------------- | ------------------------------------------------------------------------------- | -------------------------------------------- |
| 整数类型   | `TINYINT`（1 字节）、`INT`（4 字节）、`BIGINT`（8 字节）      | 存储整数，可加 `UNSIGNED`（无符号，仅存正数）                                                    | 年龄（`TINYINT UNSIGNED`）、用户 ID（`INT UNSIGNED`） |
| 字符串类型  | `CHAR`（固定长度）、`VARCHAR`（可变长度）                    | `CHAR(n)`：固定占 n 个字符（适合短文本，如手机号）；`VARCHAR(n)`：实际长度随内容变化（适合长文本，如用户名）              | 手机号（`CHAR(11)`）、用户名（`VARCHAR(20)`）           |
| 日期时间类型 | `DATE`（日期）、`DATETIME`（日期 + 时间）、`TIMESTAMP`（时间戳） | `DATE`：格式 `YYYY-MM-DD`；`DATETIME`：格式 `YYYY-MM-DD HH:MM:SS`；`TIMESTAMP`：自动记录修改时间 | 生日（`DATE`）、注册时间（`DATETIME`）                  |
| 小数类型   | `DECIMAL(M,D)`                                  | 高精度小数（M：总位数，D：小数位数），适合金额、税率等                                                    | 金额（`DECIMAL(10,2)`，如 12345678.90）            |

#### 3.1.3 表的完整性约束

约束用于**保证表中数据的正确性和一致性**，是数据库防错的重要机制，常用约束如下：



| 约束   | 关键字           | 说明                                      | 示例                                                                                  |
| ---- | ------------- | --------------------------------------- | ----------------------------------------------------------------------------------- |
| 主键约束 | `PRIMARY KEY` | 唯一标识表中每行数据，值非空且唯一                       | 用户 ID（`id INT PRIMARY KEY`）                                                         |
| 非空约束 | `NOT NULL`    | 字段值不能为 `NULL`（空值）                       | 用户名（`username VARCHAR(20) NOT NULL`）                                                |
| 唯一约束 | `UNIQUE`      | 字段值在表中唯一（允许 `NULL`，但 `NULL` 仅能出现一次）     | 手机号（`phone CHAR(11) UNIQUE`）                                                        |
| 外键约束 | `FOREIGN KEY` | 关联两个表，保证从表数据与主表数据一致（主表：被关联的表；从表：关联主表的表） | 订单表的 `user_id` 关联用户表的 `id`：`user_id INT, FOREIGN KEY (user_id) REFERENCES user(id)` |
| 默认约束 | `DEFAULT`     | 字段未赋值时，使用默认值                            | 性别（`gender CHAR(1) DEFAULT '男'`）                                                    |

### 3.2 DML 数据操作语言

DML（Data Manipulation Language）用于**操作表中的数据**，包括插入、修改、删除数据，核心关键字：`INSERT`、`UPDATE`、`DELETE`。

#### 3.2.1 核心语法



1.  **插入数据**

*   完整插入：`INSERT INTO 表名 (字段1, 字段2, ...) VALUES (值1, 值2, ...);`

*   批量插入：`INSERT INTO 表名 (字段1, 字段2, ...) VALUES (值1, 值2, ...), (值1, 值2, ...);`

*   注意：值的类型需与字段类型匹配（如 `DATE` 类型值需为 `'2024-01-01'` 格式），非空字段必须赋值。

1.  **修改数据**

*   语法：`UPDATE 表名 SET 字段1=值1, 字段2=值2, ... [WHERE 条件];`

*   注意：**必须加 **`WHERE`** 条件**（否则会修改表中所有行数据，导致大规模数据篡改）。

1.  **删除数据**

*   语法：`DELETE FROM 表名 [WHERE 条件];`

*   注意：**必须加 **`WHERE`** 条件**（否则会删除表中所有数据，且无法恢复）；若需清空表并重置自增 ID，可使用 `TRUNCATE TABLE 表名;`（比 `DELETE` 更高效，但同样不可逆）。

### 3.3 DQL 数据查询语言

DQL（Data Query Language）用于**查询表中的数据**，是最常用的 SQL 语句，核心关键字：`SELECT`，配合 `FROM`、`WHERE`、`GROUP BY`、`ORDER BY`、`LIMIT` 等实现复杂查询。

#### 3.3.1 核心语法



```
SELECT 字段列表（\* 表示所有字段）

FROM 表名

\[WHERE 筛选条件]  -- 筛选行数据（如 age > 18）

\[GROUP BY 分组字段]  -- 按字段分组（如按性别分组统计人数）

\[HAVING 分组后筛选条件]  -- 筛选分组结果（如分组后人数 > 10）

\[ORDER BY 排序字段 ASC/DESC]  -- 排序（ASC：升序，默认；DESC：降序）

\[LIMIT 起始索引, 查询条数];  -- 限制查询结果数量（常用于分页）
```

#### 3.3.2 常用示例



1.  查询所有用户信息：`SELECT * FROM user;`

2.  查询年龄大于 18 的用户名和手机号：`SELECT username, phone FROM user WHERE age > 18;`

3.  按性别分组统计人数（别名 `count` 为统计结果字段名）：`SELECT gender, COUNT(*) AS count FROM user GROUP BY gender;`

4.  查询年龄最大的 3 个用户（按年龄降序，取前 3 条）：`SELECT * FROM user ORDER BY age DESC LIMIT 0, 3;`

### 3.4 DCL 数据控制语言

DCL（Data Control Language）用于**控制用户权限**，核心操作包括授予权限（`GRANT`）和回收权限（`REVOKE`），具体语法已在 “2.2 用户权限介绍” 中详细说明，此处不再赘述。

#### 3.4.1 核心原则



*   授权时遵循 “最小权限原则”，避免过度授权；

*   回收权限时需明确 “权限列表” 和 “作用范围”，避免误回收正常权限；

## 4. 基础实验

### 实验一：MySQL 用户管理实验（续）
#### 实验目标



1.  掌握 MySQL 中用户的创建、修改密码、删除等核心操作语法；

2.  理解 “用户名 + 主机地址” 组合作为用户唯一标识的机制；

3.  验证不同主机地址配置（`localhost`/ 具体 IP/`%`）对用户访问范围的限制；

4.  培养数据库用户管理的安全意识（如强密码设置、最小访问范围控制）。

#### 实验环境



*   操作系统：Windows 10/Linux（Ubuntu 20.04 优先）；

*   软件：MySQL 8.0+（已安装并启动服务）、命令行工具（Windows：cmd；Linux：Terminal）。

#### 实验步骤



1.  **登录 MySQL 管理员账户**

    打开命令行，输入以下命令登录 root 账户（管理员账户）：



```
mysql -u root -p
```

输入 root 密码（若首次登录无密码，可直接回车，建议后续通过 `ALTER USER 'root'@'``localhost``' IDENTIFIED BY 'Root@123456';` 设置强密码）。



1.  **创建用户**

    执行以下命令创建两个用户，分别限制本地访问和指定 IP 访问：



```
\-- 创建本地用户 test\_local（仅localhost访问，密码 Test@123）

CREATE USER 'test\_local'@'localhost' IDENTIFIED BY 'Test@123';

\-- 创建远程用户 test\_remote（仅192.168.1.100访问，密码 Test@456）

CREATE USER 'test\_remote'@'192.168.1.100' IDENTIFIED BY 'Test@456';
```



1.  **查看用户**

    执行命令查询所有用户，验证创建结果：



```
SELECT user, host FROM mysql.user;
```

预期结果：列表中包含 `test_local@``localhost` 和 `test_remote@``192.168.1.100`。



1.  **修改用户密码**

    将 `test_local` 的密码修改为 `NewTest@789`：



```
ALTER USER 'test\_local'@'localhost' IDENTIFIED BY 'NewTest@789';
```



1.  **删除用户**

    删除 `test_remote` 用户（后续实验无需此用户）：



```
DROP USER 'test\_remote'@'192.168.1.100';
```

再次执行 `SELECT user, host FROM mysql.user;`，验证 `test_remote` 已被删除。

1.  **测试用户登录**

    输入新密码 `NewTest@789`，预期登录成功；若在其他主机（如 192.168.1.101）使用 `test_local` 登录，预期报错（`Host '192.168.1.101' is not allowed to connect to this MySQL server`），验证主机地址对访问范围的限制。

*   退出当前 root 会话：`exit;`

*   使用 `test_local` 登录（仅本地可登录）：



```
mysql -u test\_local -p
```

### 实验二：MySQL 权限控制实验

#### 实验目标



1.  掌握权限的授予、回收操作；

2.  理解 “最小权限原则” 的实践意义；

3.  验证不同权限对用户操作的限制。

#### 实验环境

与实验一一致（已创建 `test_local` 用户）。

#### 实验步骤



1.  **登录 root 账户并创建测试数据库 / 表**

    登录 root 后，执行以下命令创建 `testdb` 数据库和 `user_info` 表：



```
\-- 创建测试数据库

CREATE DATABASE IF NOT EXISTS testdb;

USE testdb;

\-- 创建测试表（用户信息表）

CREATE TABLE IF NOT EXISTS user\_info (

&#x20; id INT PRIMARY KEY AUTO\_INCREMENT,  -- 自增主键（用户ID）

&#x20; username VARCHAR(20) NOT NULL UNIQUE,  -- 用户名（非空且唯一）

&#x20; age TINYINT UNSIGNED,  -- 年龄（无符号整数）

&#x20; register\_time DATETIME DEFAULT CURRENT\_TIMESTAMP  -- 注册时间（默认当前时间）

);

\-- 插入测试数据

INSERT INTO user\_info (username, age) VALUES ('zhangsan', 20), ('lisi', 22);
```



1.  **授予 **`test_local`** 最小权限（仅查询）**

    执行命令授予 `test_local` 对 `testdb.user_info` 表的 `SELECT` 权限（仅能查询，无法修改 / 删除）：



```
GRANT SELECT ON testdb.user\_info TO 'test\_local'@'localhost';

\-- 查看权限是否授予成功

SHOW GRANTS FOR 'test\_local'@'localhost';
```

预期结果：权限列表中包含 `GRANT SELECT ON `testdb`.`user\_info`TO`test\_local`@`[localhost](https://localhost)\`\`。



1.  **测试权限生效范围**

*   退出 root 会话，使用 `test_local` 登录：`mysql -u test_local -p`（密码 `NewTest@789`）；

*   执行查询操作（预期成功）：



```
USE testdb;

SELECT \* FROM user\_info;  -- 预期返回 2 条测试数据
```



*   尝试执行修改操作（预期失败，无 `UPDATE` 权限）：



```
UPDATE user\_info SET age = 21 WHERE username = 'zhangsan';
```

预期报错：`ERROR 1142 (42000): UPDATE command denied to user 'test_local'@'localhost' for table 'user_info'`。



1.  **回收权限并验证**

*   重新登录 root 账户，执行回收命令：



```
REVOKE SELECT ON testdb.user\_info FROM 'test\_local'@'localhost';

\-- 再次查看权限

SHOW GRANTS FOR 'test\_local'@'localhost';
```



*   使用 `test_local` 登录，尝试查询 `user_info` 表（预期失败，权限已回收）：



```
USE testdb;

SELECT \* FROM user\_info;
```

预期报错：`ERROR 1142 (42000): SELECT command denied to user 'test_local'@'localhost' for table 'user_info'`。

### 实验三：SQL 语句综合操作实验

#### 实验目标



1.  熟练使用 DDL（创建表）、DML（增删改）、DQL（查询）语句；

2.  理解表的完整性约束（如非空、唯一、主键）的生效机制。

#### 实验环境

与实验一一致（使用 root 账户操作，避免权限限制）。

#### 实验步骤



1.  **使用 DDL 创建表（含完整性约束）**

    登录 root 后，执行以下命令创建 `product` 表（商品表），包含主键、非空、唯一、默认约束：



```
USE testdb;

CREATE TABLE IF NOT EXISTS product (

&#x20; product\_id INT PRIMARY KEY AUTO\_INCREMENT,  -- 商品ID（主键+自增）

&#x20; product\_name VARCHAR(50) NOT NULL,  -- 商品名称（非空，不可为空）

&#x20; price DECIMAL(10,2) NOT NULL CHECK (price > 0),  -- 价格（非空+数值校验，需>0）

&#x20; category VARCHAR(30) DEFAULT '未分类',  -- 分类（默认值“未分类”）

&#x20; barcode CHAR(13) UNIQUE,  -- 条形码（唯一，不可重复）

&#x20; create\_time DATETIME DEFAULT CURRENT\_TIMESTAMP  -- 创建时间（默认当前时间）

);
```



1.  **使用 DML 插入数据**

    预期三次插入均报错，分别触发 “非空约束”“CHECK 约束”“唯一约束”。

*   插入合法数据（预期成功）：



```
INSERT INTO product (product\_name, price, category, barcode)

VALUES&#x20;

('笔记本电脑', 4999.99, '电子产品', '6901234567890'),

('机械键盘', 299.00, '电脑配件', '6901234567891'),

('无线鼠标', 99.00, '', '6901234567892');  -- category 用默认值“未分类”
```



*   插入违法数据（验证约束生效，预期失败）：



```
\-- 测试非空约束：product\_name 为空

INSERT INTO product (product\_name, price, barcode) VALUES (NULL, 199.00, '6901234567893');

\-- 测试价格约束：price ≤0

INSERT INTO product (product\_name, price, barcode) VALUES ('U盘', -32.00, '6901234567894');

\-- 测试唯一约束：barcode 重复

INSERT INTO product (product\_name, price, barcode) VALUES ('耳机', 199.00, '6901234567890');
```



1.  **使用 DML 修改 / 删除数据**

*   修改数据（将 “无线鼠标” 的价格改为 89.00）：



```
UPDATE product SET price = 89.00 WHERE product\_name = '无线鼠标';
```



*   删除数据（删除 “机械键盘” 记录）：



```
DELETE FROM product WHERE product\_name = '机械键盘';
```



1.  **使用 DQL 复杂查询**

    执行以下查询语句，验证结果是否符合预期：



```
\-- 1. 查询所有商品的名称、价格、分类（按价格降序排序）

SELECT product\_name, price, category FROM product ORDER BY price DESC;

\-- 2. 查询“电子产品”分类的商品数量和平均价格

SELECT COUNT(\*) AS product\_count, AVG(price) AS avg\_price&#x20;

FROM product&#x20;

WHERE category = '电子产品';

\-- 3. 查询价格在 100-5000 元之间的商品，只显示前 2 条

SELECT \* FROM product WHERE price BETWEEN 100 AND 5000 LIMIT 0, 2;
```

#### 实验验证



*   DDL 阶段：成功创建 `product` 表，且约束（非空、唯一、CHECK）生效；

*   DML 阶段：合法数据插入成功，违法数据插入失败；修改 / 删除操作仅影响指定记录；

*   DQL 阶段：查询结果与预期一致（如价格降序、分类统计、范围筛选）。